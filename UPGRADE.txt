// $Id$

UPDATING FROM VERSION 5.x to 6.x

FOR USERS

No special instructions


FOR DEVELOPERS

Update or add install(), uninstall(), enable() and disable() hooks for your
module so each of those hooks include the function content_notify(). This
will notify the content module that a module is being added or removed so
it can remove fields, clean up views, and take other necessary action.
Without this hook, the content module has no way to know what is going on
with its field modules. The recommended place for all four of these hooks
is in the .install file. An example:

/**
 * Implementation of hook_install().
 */
function text_install() {
  content_notify('install', 'text');
}

/**
 * Implementation of hook_uninstall().
 */
function text_uninstall() {
  content_notify('uninstall', 'text');
}

/**
 * Implementation of hook_enable().
 */
function text_enable() {
  content_notify('enable', 'text');
}

/**
 * Implementation of hook_disable().
 */
function text_disable() {
  content_notify('disable', 'text');
}

There is some expanded information provided in hook_field_info().
See the text module for an example. If your module will
provide its own Views tables or arguments, change CONTENT_CALLBACK_DEFAULT
to CONTENT_CALLBACK_CUSTOM.

/**
 * Implementation of hook_field_info().
 *
 * Here we indicate that the content module will use its default
 * handling for the view of this field.
 *
 * Callbacks can be omitted if default handing is used.
 * They're included here just so this module can be used
 * as an example for custom modules that might do things
 * differently.
 */
function text_field_info() {
  return array(
    'text' => array(
      'label' => 'Text',
      'callbacks' => array(
        'tables' => CONTENT_CALLBACK_DEFAULT,
        'arguments' => CONTENT_CALLBACK_DEFAULT,
        ),
      ),
    );
}

Additional information is also provided now in hook_widget_info().
Again, you can use the text module as an example.

The content module now handles multiple values and default values
for all fields unless they opt out here by changing 'multiple values'
from CONTENT_HANDLE_CORE to CONTENT_HANDLE_MODULE and 'default value'
from CONTENT_CALLBACK_DEFAULT to CONTENT_CALLBACK_CUSTOM or
CONTENT_CALLBACK_NONE.

/**
 * Implementation of hook_widget_info().
 *
 * Here we indicate that the content module will handle
 * the default value and multiple values for these widgets.
 *
 * Callbacks can be omitted if default handing is used.
 * They're included here just so this module can be used
 * as an example for custom modules that might do things
 * differently.
 */
function text_widget_info() {
  return array(
    'text_textfield' => array(
      'label' => 'Text Field',
      'field types' => array('text'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
        ),
    ),
    'text_textarea' => array(
      'label' => 'Text Area',
      'field types' => array('text'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
        ),
    ),
  );
}

To properly handle multiple values, CCK needs a reliable method to tell if
a field is to be considered empty. To do this, each field module is
expected to add a hook_content_is_empty() that will be passed an
individual delta value and the field array. That hook should return
TRUE if the item should be considered empty and FALSE otherwise.

This system makes it possible for fields that have multiple columns
to declare an element is empty only if a specific column is missing a value.

/**
 * Implementation of hook_content_is_empty().
 */
function userreference_content_is_empty($item, $field) {
  if (empty($item['uid'])) {
    return TRUE;
  }
  return FALSE;
}

There are significant changes in the way that widgets work in the D6 version.
We now expect each widget to handle its own processing using FAPI. In
older versions, hook_widget() was called multiple times with different ops
to do pre processing, create a form, do post processing, do validation, etc.
The widget module was responsible for creating multiple values where needed,
and deciding when to keep or throw away empty values. Plus the old version
never passed the $form array to the widget, so there was no way for the
widget to directly manipulate the $form.

Now hook_widget() has no operations, it is only used to place the element
into the form. If the widget is leaving the handling of multiple values up to
the content module, it will only return a single delta item each time it is
called. The widget is passed a reference to the $form and to $form_state that
it can use in any way it wants, and it also receives a $delta value that
it can use to tell which delta the content module is processing.

The widget could still build out a complete form element in this stage,
but the core elements now only create a placeholder at this point, and
are built out more completely using #process and are validated using
#element_validate. They also use hook_elements() to make themselves
available as FAPI element types.

This construct makes it possible to nest and reuse elements. For instance,
the nodereference select field uses the optionwidgets select element and
the nodereference autocomplete field uses the text element. There are plans
to build on this capability to create 'combo' widgets that allow you to
combine various elements together into a single widget. Contributed CCK
modules can follow this example if they want their widgets to be reusable.

Look at any of the core field modules for examples of how they use
hook_elements(), and note that if you use hook_elements() you must also
provide a theme for each element.

/**
 * Implementation of hook_widget().
 *
 * Attach a single form element to the form. It will be built out and
 * validated in the callback(s) listed in hook_elements. We build it
 * out in the callbacks rather than here in hook_widget so it can be
 * plugged into any module that can provide it with valid
 * $field information.
 *
 * Content module will set the weight, field name and delta values
 * for each form element. This is a change from earlier CCK versions
 * where the widget managed its own multiple values.
 *
 * If there are multiple values for this field, the content module will
 * call this function as many times as needed.
 *
 * @param $form
 *   the entire form array, $form['#node'] holds node information
 * @param $form_state
 *   the form_state, $form_state['values'] holds the form values.
 * @param $field
 *   the field array
 * @param $delta
 *   the order of this item in the array of subelements (0, 1, 2, etc)
 *
 * @return
 *   the form item for a single element for this field
 */
function number_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  $element = array(
    '#type' => $field['widget']['type'],
    '#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
  );
  return $element;
}

One other thing to point out is that we now use #columns to identify
the column names, rather than hard-coding them into the elements.
This is done to make it easier to share and reuse widgets. In the old
code, you would have seen $element['value'] = array(...), now you
see $element[$field_key] = array(...), where $field_key is a value
taken from #columns. This is what makes it possible for both nodereference,
which has a column named 'nid', and text, which uses a column named 'value',
to use optionwidgets select and checkboxes.

The content module adds the #column values to the element, so they are
available in all #process and #element_validate functions.

/**
 * Process an individual element.
 *
 * Build the form element. When creating a form using FAPI #process,
 * note that $element['#value'] is already set.
 *
 */
function text_textfield_process($element, $edit, $form_state, $form) {
  $field = $form['#field_info'][$element['#field_name']];
  $field_key = $element['#columns'][0];
  $delta = $element['#delta'];

  $element[$field_key] = array(
    '#type' => 'textfield',
    '#title' => t($field['widget']['label']),
    '#description' => t($field['widget']['description']),
    '#required' => $element['#required'],
    '#default_value' => isset($element['#value'][$field_key]) ? $element['#value'][$field_key] : NULL,
    '#autocomplete_path' => $element['#autocomplete_path'],
  );
  return $element;
}