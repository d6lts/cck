<?php
// $Id$
/**
 * @file
 * Allows administrators to associate custom fields to content types.
 */

/**
 * Implementation of hook_perm().
 */
function cck_permission() {
  return array(
    // TODO : simplify machine name and update existing perms ?
    'Use PHP input for field settings (dangerous - grant with care)' => array(
      'title' => t('Use PHP input for field settings'),
      'description' => t('Enter PHP code in the field for the field settings that allow it. Warning: Give to trusted roles only; this permission has security implications.'),
    ),
  );
}

/**
 * Implementation of hook_menu_alter().
 */
function cck_menu_alter(&$items) {
  // Customize the content types page with our own callback
  $items['admin/build/types']['page callback'] = 'cck_types_overview';
  $items['admin/build/types']['file'] = 'cck.admin.inc';
  $items['admin/build/types']['file path'] = drupal_get_path('module', 'cck') .'/includes';
  // TODO : same thing for admin/content/taxonomy
}

function cck_debug_field_info() {
  if (drupal_function_exists('dsm')) {
    module_load_include('inc', 'field', 'field.info');
    dsm(_field_info_collate_types());
    dsm(_field_info_collate_fields());
    return '';
  }
  else {
    return t('You need to enable devel.module to see this page');
  }
}

/**
 * We store all settings in a flat text field, but some settings
 * will be arrays that need to be serialized and unserialized,
 * like the default_value.
 */
function cck_serialized_settings() {
  return array('default_value');
}

/**
 * Helper function to retrieve field settings stored by CCK.
 *
 * CCK uses the 'cck_field_settings' table to store custom settings
 * not used by core.
 *
 * Field settings will have no $instance nor a db bundle column.
 */
function cck_field_get_setting($setting, $setting_type, $field, $instance = NULL) {
  if ($setting_type == 'field' || empty($instance)) {
    $value = db_select('cck_field_settings', 'fs')->fields('fs', array('setting_option'))
      ->condition('fs.setting', $setting)
      ->condition('fs.setting_type', $setting_type)
      ->condition('fs.field_name', $field['field_name'])
      ->execute()->fetchField();
  }
  else {
    $value = db_select('cck_field_settings', 'fs')->fields('fs', array('setting_option'))
      ->condition('fs.setting', $setting)
      ->condition('fs.setting_type', $setting_type)
      ->condition('fs.field_name', $field['field_name'])
      ->condition('fs.bundle', $instance['bundle'])
      ->execute()->fetchField();
  }

  if (in_array($setting, cck_serialized_settings())) {
    $value = unserialize($value);
  }
  return $value;
}

/**
 * Helper function to set field settings stored by CCK.
 *
 * CCK uses the 'cck_field_settings' table to store custom settings
 * not used by core.
 *
 * Field settings will have no $instance nor a db bundle column.
 */
function cck_field_set_setting($setting, $setting_type, $value, $field, $instance = NULL) {
  // Delete any prior values.
  $bundle = ($setting_type == 'field' || empty($instance)) ? NULL : $instance['bundle'];
  $entity_type = ($setting_type == 'field' || empty($instance)) ? NULL : $instance['entity_type'];
  if ($setting_type == 'field' || empty($instance)) {
    db_delete('cck_field_settings')
      ->condition('field_name', $field['field_name'])
      ->condition('setting', $setting)
      ->condition('setting_type', $setting_type)
      ->execute();
  }
  else {
    db_delete('cck_field_settings')
      ->condition('field_name', $field['field_name'])
      ->condition('entity_type', $entity_type)
      ->condition('bundle', $bundle)
      ->condition('setting', $setting)
      ->condition('setting_type', $setting_type)
      ->execute();
  }
  // Create the new values.
  if (in_array($setting, cck_serialized_settings())) {
    $value = serialize($value);
  }
  $record = array(
    'field_name' => $field['field_name'],
    'entity_type' => $entity_type,
    'bundle' => $bundle,
    'setting' => $setting,
    'setting_option' => $value,
    'setting_type' => $setting_type,
  );
  $primary_keys = array();
  drupal_write_record('cck_field_settings', $record, $primary_keys);
}

/**
 * Implementation of hook_field_default_value().
 *
 * Helper function to return the correct default value for a field
 * on behalf of fields managed in the CCK UI.
 *
 *  @param $obj_type
 *    The object type.
 *  @param $object
 *    The object.
 *  @param $field
 *    The field array.
 *  @param $instance
 *    The field array.
 *  @return
 *    The default value for that field.
 */
function cck_field_default_value($obj_type, $object, $field, $instance) {
  $default_value = array();
  $default_setting = cck_field_get_setting('default_value', 'instance', $field, $instance);
  $default_setting_php = cck_field_get_setting('default_value_php', 'instance', $field, $instance);
  if (!empty($default_setting_php)) {
    ob_start();
    $result = eval($default_setting_php);
    if (is_array($result)) {
      $default_value = $result;
    }
  }
  elseif (!empty($default_setting)) {
    $default_value = $default_setting;
  }
  return (array) $default_value;
}

/**
 * Helper function to identify inactive fields.
 */
function cck_inactive_fields($type_name = NULL) {
//  module_load_include('inc', 'field', 'includes/field.crud');
//  if (!empty($type_name)) {
//    $param = array('type_name' => $type_name);
//    $inactive = array($type_name => array());
//  }
//  else {
//    $param = array();
//    $inactive = array();
//  }
//  $all = field_field_instance_read($param, TRUE);
//  $active = array_keys(field_fields());
//  foreach ($all as $field) {
//    if (!in_array($field['field_name'], $active)) {
//      $inactive[$field['type_name']][$field['field_name']] = field_field_instance_expand($field);
//    }
//  }
//  if (!empty($type_name)) {
//    return $inactive[$type_name];
//  }
//  return $inactive;
}
