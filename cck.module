<?php
// $Id$
/**
 * @file
 * Allows administrators to associate custom fields to content types.
 */

/**
 * Implementation of hook_help().
 */
function cck_help($path, $arg) {
  switch ($path) {
    case 'admin/help#cck':
      // TODO Rewrite help to refer to only the appropriate functions and files for the new system.
      return '';
    case 'admin/build/fields':
      return t('The list below shows all fields currently in use for easy reference.');

  }
}

/**
 * Implementation of hook_perm().
 */
function cck_perm() {
  return array(
    // TODO : simplify machine name and update existing perms ?
    'Use PHP input for field settings (dangerous - grant with care)' => array(
      'title' => t('Use PHP input for field settings'),
      'description' => t('Enter PHP code in the field for the field settings that allow it. Warning: Give to trusted roles only; this permission has security implications.'),
    ),
  );
}

/**
 * Implementation of hook_init().
 */
function cck_init() {
  // TODO D7 : be smarter ?
  drupal_add_css(drupal_get_path('module', 'cck') .'/theme/cck.css');
}

/**
 * Implementation of hook_menu_alter().
 */
function cck_menu_alter(&$items) {
  // Customize the content types page with our own callback
  $items['admin/build/types']['page callback'] = 'cck_types_overview';
  $items['admin/build/types']['file'] = 'cck.admin.inc';
  $items['admin/build/types']['file path'] = drupal_get_path('module', 'cck') .'/includes';
  // TODO : same thing for admin/content/taxonomy
}

function cck_debug_field_info() {
  if (drupal_function_exists('dsm')) {
    module_load_include('inc', 'field', 'field.info');
    dsm(_field_info_collate_types());
    dsm(_field_info_collate_fields());
    return '';
  }
  else {
    return t('You need to enable devel.module to see this page');
  }
}

/**
 * Implementation of hook_field_attach_form().
 */
function cck_field_attach_form($obj_type, &$object, &$form, &$form_state) {
  // Add identifier to the object to be used to alter extra fields in the form.
  list($id, $vid, $bundle) = field_attach_extract_ids($obj_type, $object);
  $form['#fieldable'] = TRUE;
  $form['#bundle'] = $bundle;
  $form['#pre_render'][] = 'cck_alter_extra_weights';
  $form['#cck_extra_fields'] = cck_extra_field_values($bundle);
}

/**
 * Implementation of hook_field_attach_view().
 */
function cck_field_attach_view($output, $obj_type, &$object, $teaser) {
  // Add identifier to the object to be used to alter extra fields in the view.
  list($id, $vid, $bundle) = field_attach_extract_ids($obj_type, $object);
  $object->content['#fieldable'] = TRUE;
  $object->content['#bundle'] = $bundle;

  // TODO : doesn't work for user profiles, because template_preprocess_user_profile()
  // uses its own hack to generate separate template variables, and never calls
  // drupal_render() on the whole object. Depending on how this evolves (or not),
  // we might need to move the #pre_render callback on each separate element.
  $object->content['#pre_render'][] = 'cck_alter_extra_weights';
  $object->content['#cck_extra_fields'] = cck_extra_field_values($bundle);

  return $output;
}

/**
 * Implementation of hook_field_attach_pre_insert().
 */
function cck_field_attach_pre_insert($obj_type, &$object) {
  // Add identifier to the object to be used to alter extra fields in the view.
  list($id, $vid, $bundle) = field_attach_extract_ids($obj_type, $object);
}

/**
 * Pre-render callback to adjust weights of non-CCK fields.
 */
function cck_alter_extra_weights($elements) {
  if (isset($elements['#cck_extra_fields'])) {
    foreach ($elements['#cck_extra_fields'] as $key => $value) {
      // Some core 'fields' use a different key in node forms and in 'view'
      // render arrays. Check we're not on a form first.
      if (!isset($elements['#build_id']) && isset($value['view']) && isset($elements[$value['view']])) {
        $elements[$value['view']]['#weight'] = $value['weight'];
      }
      elseif (isset($elements[$key])) {
        $elements[$key]['#weight'] = $value['weight'];
      }
    }
  }
  return $elements;
}

/**
 * Implementation of hook_cck_extra_fields.
 */
function cck_cck_extra_fields($bundle_name) {
  if ($bundle_name == 'user') {
    return _cck_user_extra_fields();
  }
  // TODO: we'll need to recognize other non single-mundle fieldable types.
  else {
    return _cck_node_extra_fields($bundle_name);
  }
}

// TODO Add other user elements here.
// How to do this for users? The form elements are totally different
// than the view elements.
function _cck_user_extra_fields() {
  $extra = array();
  $extra['account'] = array(
    'label' => 'User name and password',
    'description' => t('User module form element'),
    'weight' => -10
  );
  $extra['timezone'] = array(
    'label' => 'Timezone',
    'description' => t('User module form element.'),
    'weight' => 6
  );
  $extra['summary'] = array(
    'label' => 'History',
    'description' => t('User module view element.'),
    'weight' => 5
  );
  return $extra;
}

function _cck_node_extra_fields($type_name) {
  $extra = array();
  if ($type = node_type_get_type($type_name)) {
    if ($type->has_title) {
      $extra['title'] = array(
        'label' => $type->title_label,
        'description' => t('Node module element.'),
        'weight' => -5
      );
    }
    $extra['revision_information'] = array(
      'label' => t('Revision information'),
      'description' => t('Node module form.'),
      'weight' => 20
    );
    $extra['author'] = array(
      'label' => t('Authoring information'),
      'description' => t('Node module form.'),
      'weight' => 20
    );
    $extra['options'] = array(
      'label' => t('Publishing options'),
      'description' => t('Node module form.'),
      'weight' => 25
    );
    if (module_exists('comment') && variable_get("comment_$type_name", 2) != 0) {
      $extra['comment_settings'] = array(
        'label' => t('Comment settings'),
        'description' => t('Comment module form.'),
        'weight' => 30
      );
    }
    if (module_exists('locale') && variable_get("language_content_type_$type_name", 0)) {
      $extra['language'] = array(
        'label' => t('Language'),
        'description' => t('Locale module element.'),
        'weight' => 0
      );
    }
    if (module_exists('menu')) {
      $extra['menu'] = array(
        'label' => t('Menu settings'),
        'description' => t('Menu module element.'),
        'weight' => -2
      );
    }
    if (module_exists('taxonomy') && taxonomy_get_vocabularies($type_name)) {
      $extra['taxonomy'] = array(
        'label' => t('Taxonomy'),
        'description' => t('Taxonomy module element.'),
        'weight' => -3
      );
    }
    if (module_exists('book')) {
      $extra['book'] = array(
        'label' => t('Book'),
        'description' => t('Book module element.'),
        'weight' => 10
      );
    }
    if ($type_name == 'poll' && module_exists('poll')) {
      $extra['title'] = array(
        'label' => t('Poll title'),
        'description' => t('Poll module title.'),
        'weight' => -5
      );
      $extra['choice_wrapper'] = array(
        'label' => t('Poll choices'),
        'description' => t('Poll module choices.'),
        'weight' => -4
      );
      $extra['settings'] = array(
        'label' => t('Poll settings'),
        'description' => t('Poll module settings.'),
        'weight' => -3
      );
    }
    if (module_exists('upload') && variable_get("upload_$type_name", TRUE)) {
      $extra['attachments'] = array(
        'label' => t('File attachments'),
        'description' => t('Upload module element.'),
        'weight' => 30,
        'view' => 'files'
      );
    }
  }

  return $extra;
}

/**
 * Retrieve the user-defined weight for non-CCK node 'fields'.
 *
 * CCK's 'Manage fields' page lets users reorder node fields, including non-CCK
 * items (body, taxonomy, other hook_nodeapi-added elements by contrib modules...).
 * Contrib modules that want to have their 'fields' supported need to expose
 * them with hook_cck_extra_fields, and use this function to retrieve the
 * user-defined weight.
 *
 * @param $type_name
 *   The content type name.
 * @param $pseudo_field_name
 *   The name of the 'field'.
 * @return
 *   The weight for the 'field', respecting the user settings stored
 *   by field.module.
 */
function cck_extra_field_weight($bundle_name, $pseudo_field_name) {
  $extra = cck_extra_field_values($bundle_name);
  if (isset($extra[$pseudo_field_name])) {
    return $extra[$pseudo_field_name]['weight'];
  }
}

function cck_extra_field_values($bundle_name) {
  static $info = array();

  if (empty($info)) {
    $info = array();
    $bundles = field_info_bundles();
    foreach ($bundles as $name => $bundle_info) {
      // Gather information about non-CCK 'fields'.
      $extra = module_invoke_all('cck_extra_fields', $name);
      drupal_alter('cck_extra_fields', $extra, $name);

      // Add saved weights.
      foreach (variable_get('cck_extra_weights_'. $name, array()) as $key => $value) {
        // Some stored entries might not exist anymore, for instance if uploads
        // have been disabled, or vocabularies removed...
        if (isset($extra[$key])) {
          $extra[$key]['weight'] = $value;
        }
      }
      $info[$name] = $extra;
    }
  }
  if (array_key_exists($bundle_name, $info)) {
    return $info[$bundle_name];
  }
  else {
    return array();
  }
}


function cck_build_modes($obj_type, $tab_selector = NULL) {
  static $info;

  if (!isset($info[$obj_type])) {
    $info[$obj_type] = module_invoke_all('cck_build_modes');
    // Collect titles, and filter out non active modes.
    $active_modes = field_build_modes($obj_type);
    foreach ($info[$obj_type] as $tab => $values) {
      $modes = array();
      foreach ($info[$obj_type][$tab]['build modes'] as $mode) {
        if (isset($active_modes[$mode])) {
          $modes[$mode] = $active_modes[$mode];
        }
      }
      if ($modes) {
        $info[$obj_type][$tab]['build modes'] = $modes;
      }
      else {
        unset($info[$obj_type][$tab]);
      }
    }
  }
  if ($tab_selector) {
    return isset($info[$obj_type][$tab_selector]) ? $info[$obj_type][$tab_selector]['build modes'] : array();
  }
  else {
    return $info[$obj_type];
  }
}

/**
 *  Implementation of hook_node_type().
 *
 *  TODO D7: This should be done in hook_field_[create|rename|delete]_bundle().
 */
function cck_node_type($op, $info) {
  switch ($op) {
    case 'insert':
      // TODO Fix this.
      // Trying to get the Manage Fields screen for a new content type to
      // work immediately after the new type is created. Even this won't do it,
      // MF screen is still 'Page not found' after the new type is created.
      menu_rebuild();
      field_cache_clear();
      break;

    case 'update':
      if (isset($info->old_type) && $info->old_type !== $info->type && $extra = variable_get('cck_extra_weights_'. $info->old_type, array())) {
        variable_set('cck_extra_weights_'. $info->type, $extra);
        variable_del('cck_extra_weights_'. $info->old_type);
      }
      break;
    case 'delete':
      variable_del('cck_extra_weights_'. $info->type);
      break;
  }
}

/**
 * We store all settings in a flat text field, but some settings
 * will be arrays that need to be serialized and unserialized,
 * like the default_value.
 */
function cck_serialized_settings() {
  return array('default_value');
}

/**
 * Helper function to retrieve field settings stored by CCK.
 *
 * CCK uses the 'cck_field_settings' table to store custom settings
 * not used by core.
 *
 * Field settings will have no $instance nor a db bundle column.
 */
function cck_field_get_setting($setting, $setting_type, $field, $instance = NULL) {
  if ($setting_type == 'field' || empty($instance)) {
    $value = db_select('cck_field_settings', 'fs')->fields('fs', array('setting_option'))
      ->condition('fs.setting', $setting)
      ->condition('fs.setting_type', $setting_type)
      ->condition('fs.field_name', $field['field_name'])
      ->execute()->fetchField();
  }
  else {
    $value = db_select('cck_field_settings', 'fs')->fields('fs', array('setting_option'))
      ->condition('fs.setting', $setting)
      ->condition('fs.setting_type', $setting_type)
      ->condition('fs.field_name', $field['field_name'])
      ->condition('fs.bundle', $instance['bundle'])
      ->execute()->fetchField();
  }

  if (in_array($setting, cck_serialized_settings())) {
    $value = unserialize($value);
  }
  return $value;
}

/**
 * Helper function to set field settings stored by CCK.
 *
 * CCK uses the 'cck_field_settings' table to store custom settings
 * not used by core.
 *
 * Field settings will have no $instance nor a db bundle column.
 */
function cck_field_set_setting($setting, $setting_type, $value, $field, $instance = NULL) {
  // Delete any prior values.
  $bundle = ($setting_type == 'field' || empty($instance)) ? NULL : $instance['bundle'];
  if ($setting_type == 'field' || empty($instance)) {
    db_delete('cck_field_settings')
      ->condition('field_name', $field['field_name'])
      ->condition('setting', $setting)
      ->condition('setting_type', $setting_type)
      ->execute();
  }
  else {
    db_delete('cck_field_settings')
      ->condition('field_name', $field['field_name'])
      ->condition('bundle', $bundle)
      ->condition('setting', $setting)
      ->condition('setting_type', $setting_type)
      ->execute();
  }
  // Create the new values.
  if (in_array($setting, cck_serialized_settings())) {
    $value = serialize($value);
  }
  $record = array(
    'field_name' => $field['field_name'],
    'bundle' => $bundle,
    'setting' => $setting,
    'setting_option' => $value,
    'setting_type' => $setting_type,
  );
  $primary_keys = array();
  drupal_write_record('cck_field_settings', $record, $primary_keys);
}

/**
 * Implementation of hook_field_default_value().
 *
 * Helper function to return the correct default value for a field
 * on behalf of fields managed in the CCK UI.
 *
 *  @param $obj_type
 *    The object type.
 *  @param $object
 *    The object.
 *  @param $field
 *    The field array.
 *  @param $instance
 *    The field array.
 *  @return
 *    The default value for that field.
 */
function cck_field_default_value($obj_type, $object, $field, $instance) {
  $default_value = array();
  $default_setting = cck_field_get_setting('default_value', 'instance', $field, $instance);
  $default_setting_php = cck_field_get_setting('default_value_php', 'instance', $field, $instance);
  if (!empty($default_setting_php)) {
    ob_start();
    $result = eval($default_setting_php);
    if (is_array($result)) {
      $default_value = $result;
    }
  }
  elseif (!empty($default_setting)) {
    $default_value = $default_setting;
  }
  return (array) $default_value;
}

/**
 * Helper function to identify inactive fields.
 */
function cck_inactive_fields($type_name = NULL) {
//  module_load_include('inc', 'field', 'includes/field.crud');
//  if (!empty($type_name)) {
//    $param = array('type_name' => $type_name);
//    $inactive = array($type_name => array());
//  }
//  else {
//    $param = array();
//    $inactive = array();
//  }
//  $all = field_field_instance_read($param, TRUE);
//  $active = array_keys(field_fields());
//  foreach ($all as $field) {
//    if (!in_array($field['field_name'], $active)) {
//      $inactive[$field['type_name']][$field['field_name']] = field_field_instance_expand($field);
//    }
//  }
//  if (!empty($type_name)) {
//    return $inactive[$type_name];
//  }
//  return $inactive;
}
