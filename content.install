<?php
// $Id$

/**
 * Implementation of hook_install().
 */
function content_install() {
  variable_set('content_schema_version', 6001);
  drupal_install_schema('content');
}


/**
 * Implementation of hook_uninstall().
 */
function content_uninstall() {
  variable_del('content_schema_version');
  drupal_uninstall_schema('content');
}

/**
 * Implementation of hook_enable().
 */
function content_enable() {
}

/**
 * Implementation of hook_disable().
 */
function content_disable() {
}

/**
 * Implementation of hook_schema.
 */
function content_schema() {

  // Static (meta) tables.

  $schema['content_node_field'] = array(
    'fields' => array(
      'field_name'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type'            => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
      'global_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'required'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'multiple'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'db_storage'      => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 1),
      'module'          => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
      'columns'         => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
    ),
    'primary key' => array('field_name'),
  );
  $schema['content_node_field_instance'] = array(
    'fields' => array(
      'field_name'       => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type_name'        => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'label'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'widget_type'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'widget_settings'  => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'display_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'description'      => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'widget_module'    => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
    ),
    'primary key' => array('field_name', 'type_name'),
  );
  $schema['cache_content'] = drupal_get_schema_unprocessed('system', 'cache');

  // Dynamic (data) tables.
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');


  // When the module is first installed, the remaining code in the schema
  // will create errors, since these tables have not yet been created.
  // We don't need to create those tables on initial installation anyway
  // since no fields have been created yet, so just return with this much
  // of the schema.

  if (!db_table_exists('content_node_field') || !db_table_exists('content_node_field_instance')) {
    return $schema;
  }

  // Can't use many helper functions here, like content_fields() or
  // content_types() or we risk creating a fatal loop from circular
  // logic when they call other functions that use this schema, so create
  // the schema directly from a fresh query of the database.

  // content_table_schema() and content_database_info() have no
  // circular logic and are safe to use here.

  $db_result = db_query("SELECT * FROM {". content_instance_tablename() ."} nfi ".
    " LEFT JOIN {". content_field_tablename() ."} nf ON nf.field_name = nfi.field_name");
  while ($field = db_fetch_array($db_result)) {
    $field['columns'] = unserialize($field['columns']);
    $content_table = _content_tablename($field['type_name'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
    $field_table = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);

    // We always add a 'per content type' table.
    // TODO : is that really still needed ?
    if (!isset($schema[$content_table])) {
      $schema[$content_table] = content_table_schema();
    }

    // Add the 'per field' table if needed.
    if (!isset($schema[$field_table]) && $field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD) {
      $schema[$field_table] = content_table_schema($field);
    }
    else {
      $schema[$content_table] = array_merge($schema[$content_table], content_table_schema($field));
    }
  }
  return $schema;
}

/**
 * Add storage for per-field help text.
 */
function content_update_2() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_column_exists(content_instance_tablename(), 'description')) {
    return $ret;
  }
  db_add_field($ret, content_instance_tablename(), 'description', array('type' => 'text', 'not null' => TRUE, 'default' => ''));
  return $ret;
}

/**
 * Add information about where data is stored.
 */
function content_update_3() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_column_exists(content_field_tablename(), 'db_storage')) {
      return $ret;
  }
  db_add_field($ret, content_field_tablename(), 'db_storage', array('type' => 'int', 'not null' => TRUE, 'default' => 0));
  return $ret;
}

/**
 * Add tables for content types to store their data.
 */
function content_update_4() {
  $ret = array();

  // Figure out what table to update. If node_type exists and node_type_content does not, this update is
  // being done by an early version of core that did not rename the node_type table, so use the original name, node_type.
  // If both table names exist, core has renamed the table, so use the renamed table name, node_type_content.
  if (!db_table_exists('node_type_content')) {
    // If there is no column 'node_type' in this table, this is not the CCK table, so return.
    if (!db_column_exists('node_type', 'type_name')) {
      return $ret;
    }
    else {
      $result = db_query("SELECT type_name FROM {node_type}");
    }
  }
  else {
    $result = db_query("SELECT type_name FROM {node_type_content}");
  }
  $base_schema = content_table_schema();

  while ($type = db_fetch_object($result)) {
    $base_tablename = _content_tablename($type->type_name, CONTENT_DB_STORAGE_PER_CONTENT_TYPE, 1);
    if (!db_table_exists($base_tablename)) {
      db_create_table($ret, $base_tablename, $base_schema);
    }
  }
  return $ret;
}

/**
 * Move data from per-field storage to per-content-type storage where possible.
 */
function content_update_5() {
  $ret = array();
  // update_5() had a mistake that was later corrected in update_10() for 4.7
  // and update_1004() in 5.x. Instead of repeating variations of the same
  // update several times, the fix is done entirely in update_6003().
  return $ret;
}

/**
 * The cache for nodes has changed to account for revisions correctly.
 */
function content_update_6() {
  return array(update_sql('DELETE FROM {cache}'));
}

/**
 * Rename the "content-" prefix to "content_" to aid in form theming.
 */
function content_update_7() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();

  // Figure out what table to update. If node_type exists and node_type_content does not, this update is
  // being done by an early version of core that did not rename the node_type table, so use the original name, node_type.
  // If both table names exist, core has renamed the table, so use the renamed table name, node_type_content.
  if (!db_table_exists('node_type_content')) {
    if (!db_column_exists('node_type', 'type_name')) {
      // If there is no column 'node_type' in the node_type table, it is not the CCK table, so return.
      return $ret;
    }
    else {
      $table_name = 'node_type';
    }
  }
  else {
    $table_name = 'node_type_content';
  }
  $type_result = db_query("SELECT type_name FROM {". $table_name ."} WHERE type_name LIKE 'content-%%'");

  if (db_num_rows($type_result)) {
    // Multi-part update
    if (!isset($_SESSION['content_update_7'])) {
      $_SESSION['content_update_7']['current'] = 0;
      $_SESSION['content_update_7']['max'] = db_num_rows($type_result);
    }

    $type = db_fetch_object($type_result);
    $old_type_name = $type->type_name;
    $new_type_name = str_replace('content-', 'content_', $old_type_name);
    $ret[] = update_sql("UPDATE {node} SET type = '". $new_type_name ."' WHERE type = '". $old_type_name ."'");
    $ret[] = update_sql("UPDATE {". $table_name ."} SET type_name = '". $new_type_name ."' WHERE type_name = '". $old_type_name ."'");
    $ret[] = update_sql("UPDATE {". content_instance_tablename(1) ."} SET type_name = '". $new_type_name ."' WHERE type_name = '". $old_type_name ."'");
    $ret[] = update_sql("UPDATE {vocabulary_node_types} SET type = '". $new_type_name ."' WHERE type = '". $old_type_name ."'");

    $variable_result = db_query("SELECT name, value FROM {variable} WHERE name LIKE '%%%s%%' OR value LIKE '%%%s%%'", $old_type_name, $old_type_name);
    while ($variable = db_fetch_object($variable_result)) {
      $new_name = str_replace($old_type_name, $new_type_name, $variable->name);
      $new_value = str_replace($old_type_name, $new_type_name, $variable->value);
      db_query("UPDATE {variable} SET name = '%s', value = '%s' WHERE name = '%s'", $new_name, $new_value, $variable->name);
    }

    $ret[] = update_sql('DELETE FROM {cache}');

    $_SESSION['content_update_7']['current']++;
    $ret['#finished'] = $_SESSION['content_update_7']['current'] / $_SESSION['content_update_7']['max'];
    return $ret;
  }
}

/**
 * Rename the "node_type" table to avoid a conflict with a later core addition
 */
function content_update_8() {
  $ret = array();
  if (!db_table_exists('node_type_content') && db_column_exists('node_type', 'type_name')) {
    db_rename_table($ret, 'node_type', 'node_type_content');
  }
  return $ret;
}

/**
 *  Fix corrupted db due to a bug in 1.3 release (http://drupal.org/node/115332)
 */
function content_update_10() {
  $ret = array();
  // update_5() had a mistake that was later corrected in update_10() for 4.7
  // and update_1004() in 5.x. Instead of repeating variations of the same
  // update several times, the fix is done entirely in update_6003().
  return $ret;
}

/**
 *  Start 5.0 update series
 *
 *  First, catch up for databases which did not get node_type table renamed in 4.7 before updating to 5.0
 *  We'll know them because update_8 will rename the node_type table to node_content_type leaving no table named node_type
 *  A core patch has been submitted to get the rename done by the system module, so we need to test whether the table is already renamed
 */

function content_update_1000() {
  $ret = array();
  if (!db_table_exists('node_type')) {
    // rerun system_update_1005(), if it failed the first time it was run
    $ret = system_update_1005();
  }
  return $ret;
}

/**
 *  Copy node_type_content table back to core node_type table
 */
function content_update_1001() {
  $ret = array();
  if (db_table_exists('node_type_content')) {
    $result = db_query("SELECT type_name, label, description, help, title_label FROM {node_type_content}");
    while ($data = db_fetch_object($result)) {
      $ret[] = update_sql("INSERT INTO {node_type}
         (type, name, module, description, help, has_title, title_label, has_body, body_label, custom, orig_type, min_word_count)
           VALUES ('". db_escape_string($data->type_name) ."', '". db_escape_string($data->label) ."', 'node', '". db_escape_string($data->description) ."', '". db_escape_string($data->help) ."', 1, '". db_escape_string($data->title_label) ."', 0, '', 1, '". db_escape_string($data->type_name) ."', 0)");
    }
    db_drop_table($ret, 'node_type_content');
    $ret[] = update_sql('DELETE FROM {cache}');
  }
  return $ret;
}

/**
 * Add display_settings column
 */
function content_update_1002() {
  $ret = array();
  // See if this column was already added in 4.7.
  if (!db_column_exists(content_field_tablename(), 'display_settings')) {
    db_add_field($ret, content_field_tablename(), 'display_settings', array('type' => 'text', 'not null' => TRUE, 'default' => ''));
  }
  return $ret;
}

/**
 *  Rename data tables to avoid collision with core node_* tables
 */
function content_update_1003() {
  $ret = array();

  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');

  $rename = array();

  $types = content_types();
  $fields = content_fields();

  // "per content type" tables
  foreach ($types as $type) {
    $old_name = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
    $new_name = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE, 1003);
    if (db_table_exists($old_name)) {
      if (!in_array($old_name, array('node_access',  'node_comments_statistics', 'node_counter', 'node_field', 'node_field_instance', 'content_group', 'content_group_fields', 'node_revisions', 'node_type'))) {
        $rename[$old_name] = $new_name;
      }
      else {
        // TODO : what ? create the table ?
      }
    }
  }

  // "per field" tables
  foreach ($fields as $field) {
    $old_name = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);
    $new_name = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD, 1003);
    $old_name = 'node_data_'.$field['field_name'];
    $new_name = 'content_'. $field['field_name'];
    if (db_table_exists($old_name)) {
      $rename[$old_name] = $new_name;
    }
  }

  // rename
  foreach ($rename as $old_name => $new_name) {
    db_rename_table(&$ret, $old_name, $new_name);
  }

  variable_set('content_schema_version', 1003);
  // Set a followup flag for content_update_1005.
  $_SESSION['content_update_1003_followup'] = TRUE;

  return $ret;
}

/**
 * Fix corrupted db due to a bug in 1.3 release (http://drupal.org/node/115332).
 */
function content_update_1004() {
  $ret = array();
  // update_5() had a mistake that was later corrected in update_10() for 4.7
  // and update_1004() in 5.x. Instead of repeating variations of the same
  // update several times, the fix is done entirely in update_6003().
  return $ret;
}

/**
 *  Regenerate views (was in content_update_1003, but was later moved out in a separate update
 */
function content_update_1005() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_views.inc');
  $ret = array();
  if (isset($_SESSION['content_update_1003_followup'])) {
    content_clear_type_cache();
    if (module_exists('views')) {
      $updated_views = _content_views_rebuild_views(array_keys(content_fields()));
      foreach ($updated_views as $view) {
        $ret[] = array(
          'query' => strtr('The views %view has been regenerated.', array('%view' => $view)),
          'success' => TRUE
        );
      }
    }
  }
  return $ret;
}

/**
 *  Set text db columns to accept NULL values for mysql (see http://drupal.org/node/108094)
 *
 * No longer needed, we now require all columns to accept NULL values.
 */
function content_update_1006() {
  $ret = array();
  return $ret;
}


/**
 *  Add separate cache_content table
 */
function content_update_1007() {
  $ret = array();
  db_create_table($ret, 'cache_content', drupal_get_schema_unprocessed('system', 'cache'));
  return $ret;
}

/**
 *  Placeholder for CCK 1.5 / Views 1.6 message - not relevant for D6 ?
 */
function content_update_1008() {
  return array();
}

/**
 * Add module name to fields table to make it easier to identify the fields to delete when a module
 * is uninstalled.
 *
 * Needed because the value drops out of content_info() when module is disabled, so there
 * is no other way to find the associated fields.
 */
function content_update_6000() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_column_exists(content_field_tablename(), 'columns')) {
    return $ret;
  }
  db_add_field($ret, content_field_tablename(), 'module', array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''));
  db_add_field($ret, content_field_tablename(), 'columns', array('type' => 'text', 'not null' => TRUE, 'default' => ''));
  db_add_field($ret, content_instance_tablename(), 'widget_module', array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''));

  foreach (module_list() as $module) {
    $module_field_types = module_invoke($module, 'field_info');
    if ($module_field_types) {
      foreach ($module_field_types as $name => $field_info) {
        $ret[] = update_sql("UPDATE {". content_field_tablename() ."} SET module = '". $module ."' WHERE type = '". $name ."'");
        foreach (content_fields() as $field) {
          if ($field['type'] == $name) {
            $columns = module_invoke($module, 'field_settings', 'database columns', $field);
            if ($columns) {
              // Using db_query() instead of update_sql() here because serialized arrays
              // lose data in the escaping done by update_sql().
              db_query("UPDATE {". content_field_tablename() ."} SET columns = '%s' WHERE field_name = '%s'", serialize($columns), $field['field_name']);
            }
          }
        }
      }
    }
    $module_widgets = module_invoke($module, 'widget_info');
    if ($module_widgets) {
      foreach ($module_widgets as $name => $widget_info) {
        $ret[] = update_sql("UPDATE {". content_instance_tablename() ."} SET widget_module = '". $module ."' WHERE widget_type = '". $name ."'");
      }
    }

  }
  return $ret;
}

/**
 * Rename node_field and node_field_instance tables.
 *
 * This is a carryover from when the data tables were renamed,
 * postponed so we wouldn't create any more havoc than necessary
 * until a major version change.
 *
 * Using 'content_node_field' instead of 'content_field'
 * to avoid conflicts with field tables that will be prefixed
 * with 'content_field'.
 */
function content_update_6001() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_table_exists('content_node_field')) {
    return $ret;
  }
  db_rename_table($ret, 'node_field', 'content_node_field');
  db_rename_table($ret, 'node_field_instance', 'content_node_field_instance');
  variable_set('content_schema_version', 6001);
  content_clear_type_cache(TRUE);
  return $ret;
}

/**
 * Get rid of automatic per content tables for content types that have no fields.
 * Switching to adding those tables only when needed.
 */
function content_update_6002() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $db_types = content_types();

  $result = db_query("SELECT DISTINCT type_name FROM {". content_instance_tablename() ."}");
  while ($type = db_fetch_array($result)) {
    $field_types[] = $type['type_name'];
  }

  foreach ($db_types as $content_type) {
    if (!in_array($content_type, $field_types)) {
      $table = _content_tablename($content_type, CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
      db_drop_table($ret, $table);
    }
  }
  content_clear_type_cache(TRUE);
}

/**
 * Fix corrupted db due to a bug in 1.3 release (http://drupal.org/node/115332).
 *
 * The original problem was that update_5() moved all data that had multiple = 0
 * to per content tables, but shared fields should have stayed in per field tables,
 * so this update checks for that and changes the database back.
 *
 * This may have been originally created in 4.7 in update_5() and fixed in 4.7
 * in update_10() or in 5.x in update_1004() but repeated here in a way that
 * will fix the database no matter what the state, eliminating the need for
 * three confusingly similar updates.
 */
function content_update_6003() {
  global $base_url;
  $ret = array();
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');

  // drop fields with no field instances.
  $fields = array();
  $result = db_query("SELECT DISTINCT(field_name) FROM {". content_instance_tablename() ."}");
  while ($row = db_fetch_array($result)) {
    $fields[] = $row['field_name'];
  }
  $ret[] = update_sql("DELETE FROM {". content_field_tablename() ."} WHERE field_name NOT IN ('". implode("','", $fields) ."')");

  // Check the status of all non-multiple fields to be sure storage is set correctly.
  $result = db_query("SELECT field_name, db_storage FROM {". content_field_tablename() ."} WHERE multiple = 0");
  while ($row = db_fetch_array($result)) {
    $field = content_fields($row['field_name']);
    $db_info = content_database_info($field);
    $field['columns'] = $db_info['columns'];
    // Insert the actual value from the database, since it may have been
    // corrected in the cached array.
    $field['db_storage'] = $row['db_storage'];
    $new_field = $field;
    $instances = db_result(db_query("SELECT COUNT(*) FROM {". content_instance_tablename() ."} WHERE field_name = '%s'", $row['field_name']));
    if ($field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD && $instances == 1) {
      $new_field['db_storage'] = CONTENT_DB_STORAGE_PER_CONTENT_TYPE;
      $ret[] = update_sql("UPDATE {". content_field_tablename() ."} SET db_storage = ". $new_field['db_storage'] ." WHERE field_name ='". $new_field['field_name'] ."'");
      content_alter_schema($field, $new_field);
    }
    elseif ($field['db_storage'] == CONTENT_DB_STORAGE_PER_CONTENT_TYPE && $instances > 1) {
      $new_field['db_storage'] = CONTENT_DB_STORAGE_PER_FIELD;
      $ret[] = update_sql("UPDATE {". content_field_tablename() ."} SET db_storage = ". $new_field['db_storage'] ." WHERE field_name ='". $new_field['field_name'] ."'");
      content_alter_schema($field, $new_field);
    }
  }
  return $ret;
}
