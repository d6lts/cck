<?php
// $Id$

/**
 * 'Safe' version of content_types() to use in updates and installs.
 *
 * Can't safely use content_fields() or content_types() in an update to get
 * a fields array, especially without knowing what field modules are enabled,
 * or the current state of the database and cache, so create a fields array
 * from database info that is limited to fields from modules that are
 * currently enabled.
 */
function content_install_types() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  foreach (module_list() as $module) {
    if ($field_type = module_invoke($module, 'field_info')) {
      $module_field_types[$module] = $field_type;
    }
    if ($widget_type = module_invoke($module, 'widget_info')) {
      $module_widgets[$module] = $widget_type;
    }
  }
  $fields = array();
  $db_result = db_query("SELECT * FROM {". content_instance_tablename() ."} nfi ".
    " LEFT JOIN {". content_field_tablename() ."} nf ON nf.field_name = nfi.field_name");
  while ($field = db_fetch_array($db_result)) {
    // There may be module data available for currently disabled modules,
    // or missing module data for currently enabled modules, so start over
    // to get only field info for enabled modules.
    unset($field['module']);
    unset($field['widget_module']);
    foreach ($module_field_types as $module => $types) {
      foreach ($types as $type_name => $type) {
        if ($field['type'] == $type_name) {
          $field['module'] = $module;
        }
      }
    }
    foreach ($module_widgets as $module => $types) {
      foreach ($types as $type_name => $type) {
        if ($field['widget_type'] == $type_name) {
          $field['widget_module'] = $module;
        }
      }
    }
    if (!empty($field['module']) && !empty($field['widget_module'])) {
      $field['widget_settings'] = unserialize($field['widget_settings']);
      $field['display_settings'] = unserialize($field['display_settings']);
      $field['columns'] = module_invoke($field['module'], 'field_settings', 'database columns', $field);
      $fields[$field['type_name']][$field['field_name']] = $field;
    }
  }
  return $fields;
}

/**
 * Implementation of hook_install().
 */
function content_install() {
  variable_set('content_schema_version', 6002);
  drupal_install_schema('content');
}


/**
 * Implementation of hook_uninstall().
 */
function content_uninstall() {
  variable_del('content_schema_version');
  drupal_uninstall_schema('content');
}

/**
 * Implementation of hook_enable().
 */
function content_enable() {
  // Make sure old data is emptied out of the caches, since it
  // may no longer be valid since the module was last enabled,
  // especially if not all the same field modules are enabled
  // as before. Especially needed during updates.
  cache_clear_all('*', 'cache_content', TRUE);
  content_clear_type_cache(TRUE);
}

/**
 * Implementation of hook_disable().
 */
function content_disable() {
  // Make sure old data is emptied out of the caches, since it
  // may no longer be valid when the module is re-enabled.
  cache_clear_all('*', 'cache_content', TRUE);
  content_clear_type_cache(TRUE);
}

/**
 * Test and report Content module installation requirements.
 */
function content_requirements($phase) {
  $requirements = array();

  // Ensure translations don't break at install time
  $t = get_t();

  $current_version = drupal_get_installed_schema_version('content');
  $minimum_version = 1008;

  if ($current_version < $minimum_version) {
    $requirements['content_version'] = array(
      'title' => $t('Content Version'),
      'value' => $t('Your CCK database is not up to date and will not work correctly in this version of the Content module. Please upgrade your database in Drupal 5.x to at least Content update %number, using the latest 5.x version of the Content module, before upgrading to Drupal 6.x.', array('%number' => $minimum_version)),
      'severity' => REQUIREMENT_ERROR,
    );
  }
  return $requirements;
}

/**
 * Implementation of hook_schema.
 */
function content_schema() {

  // Static (meta) tables.

  $schema['content_node_field'] = array(
    'fields' => array(
      'field_name'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type'            => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
      'global_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'required'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'multiple'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'db_storage'      => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 1),
      'module'          => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
      'columns'         => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
    ),
    'primary key' => array('field_name'),
  );
  $schema['content_node_field_instance'] = array(
    'fields' => array(
      'field_name'       => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type_name'        => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'label'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'widget_type'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'widget_settings'  => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'display_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'description'      => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'widget_module'    => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
    ),
    'primary key' => array('field_name', 'type_name'),
  );
  $schema['cache_content'] = drupal_get_schema_unprocessed('system', 'cache');

  // When the module is first installed, the remaining code in the schema
  // will create errors, since these tables have not yet been created.
  // We don't need to create data tables on initial installation anyway
  // since no fields have been created yet, so just return with this much
  // of the schema.

  if (!db_table_exists('content_node_field') || !db_table_exists('content_node_field_instance')) {
    return $schema;
  }

  // Dynamic (data) tables.
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');

  // We can't use many helper functions here, like content_fields() or
  // content_types() or we risk creating a fatal loop from circular
  // logic when they call other functions that use this schema, so create
  // the schema directly from a fresh query of the database.

  // content_table_schema() and content_database_info() have no
  // circular logic and are safe to use here.

  $db_result = db_query("SELECT * FROM {". content_instance_tablename() ."} nfi ".
    " LEFT JOIN {". content_field_tablename() ."} nf ON nf.field_name = nfi.field_name");
  while ($field = db_fetch_array($db_result)) {
    $field['columns'] = unserialize($field['columns']);
    $content_table = _content_tablename($field['type_name'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
    $field_table = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);


    // We always add a 'per content type' table for each content type that
    // has fields.
    if (!isset($schema[$content_table])) {
      $schema[$content_table] = content_table_schema();
    }

    $base_schema = content_table_schema($field);
    if ($field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD) {
      // Per-field storage : add the 'per field' table if needed.
      if (!isset($schema[$field_table])) {
        $schema[$field_table] = $base_schema;
      }
    }
    else {
      // Per-type storage : merge the information for the field
      // in the existing table.
      $schema[$content_table]['fields'] = array_merge($schema[$content_table]['fields'], $base_schema['fields']);
      $schema[$content_table]['content fields'] = array_merge($schema[$content_table]['content fields'], $base_schema['content fields']);
    }
  }
  return $schema;
}

/**
 * Add module name to fields table to make it easier to identify the fields to delete when a module
 * is uninstalled.
 *
 * Needed because the value drops out of content_info() when module is disabled, so there
 * is no other way to find the associated fields.
 */
function content_update_6000() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_column_exists(content_field_tablename(), 'columns')) {
    return $ret;
  }
  db_add_field($ret, content_field_tablename(), 'module', array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''));
  db_add_field($ret, content_field_tablename(), 'columns', array('type' => 'text', 'not null' => TRUE, 'default' => ''));
  db_add_field($ret, content_instance_tablename(), 'widget_module', array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''));

  foreach (module_list() as $module) {
    content_associate_fields($module);
  }

  // Fix the cache_content schema
  if (db_table_exists('cache_content')) {
    db_drop_table($ret, 'cache_content');
  }
  db_create_table($ret, 'cache_content', drupal_get_schema_unprocessed('system', 'cache'));
  variable_set('content_schema_version', 6000);

  // The cache table had to be used to store data until this update ran,
  // so clear cache out now that we're switching back to the cache_content table.
  $ret[] = update_sql('DELETE FROM {cache}');

  return $ret;
}

/**
 * Rename node_field and node_field_instance tables.
 *
 * This is a carryover from when the data tables were renamed,
 * postponed so we wouldn't create any more havoc than necessary
 * until a major version change.
 *
 * Using 'content_node_field' instead of 'content_field'
 * to avoid conflicts with field tables that will be prefixed
 * with 'content_field'.
 */
function content_update_6001() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_table_exists('content_node_field')) {
    return $ret;
  }
  db_rename_table($ret, 'node_field', 'content_node_field');
  db_rename_table($ret, 'node_field_instance', 'content_node_field_instance');
  variable_set('content_schema_version', 6001);
  content_clear_type_cache(TRUE);
  return $ret;
}

/**
 * Get rid of automatic per content tables for content types that have no fields.
 * Switching to adding those tables only when needed.
 */
function content_update_6002() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();

  $db_types = content_install_types();
  $field_types = array();

  $result = db_query("SELECT DISTINCT type_name FROM {". content_instance_tablename() ."}");
  while ($type = db_fetch_array($result)) {
    $field_types[] = $type['type_name'];
  }

  foreach ($db_types as $content_type => $content_info) {
    if (!in_array($content_type, $field_types)) {
      $table = _content_tablename($content_type, CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
      if (db_table_exists($table)) {
        db_drop_table($ret, $table);
      }
    }
  }
  variable_set('content_schema_version', 6002);
  content_clear_type_cache(TRUE);
  return $ret;
}