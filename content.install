<?php
// $Id$

/**
 * Implementation of hook_install().
 */
function content_install() {
  variable_set('content_schema_version', 6001);
  drupal_install_schema('content');
}


/**
 * Implementation of hook_uninstall().
 */
function content_uninstall() {
  variable_del('content_schema_version');
  drupal_uninstall_schema('content');
}

/**
 * Implementation of hook_schema.
 */
function content_schema() {

  // Static (meta) tables.

  $schema['content_field'] = array(
    'fields' => array(
      'field_name'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type'            => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
      'global_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'required'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'multiple'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'db_storage'      => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'module'          => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
    ),
    'primary key' => array('field_name'),
  );
  $schema['content_field_instance'] = array(
    'fields' => array(
      'field_name'       => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type_name'        => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'label'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'widget_type'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'widget_settings'  => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'display_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'description'      => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE, 'default' => ''),
      'module'           => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
    ),
    'primary key' => array('field_name', 'type_name'),
  );
  $schema['cache_content'] = drupal_get_schema_unprocessed('system', 'cache');

  // Dynamic (data) tables.
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');

  foreach (content_types() as $type) {
    // We always add a 'per content type' table.
    // TODO : is that really still needed ?
    $table = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
    $schema[$table] = _content_table_schema();
    foreach ($type['fields'] as $field) {
      $db_info = content_database_info($field);
      $table = $db_info['table'];

      // Add the 'per field' table if needed.
      if ($field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD && !isset($schema[$table])) {
        $schema[$table] = _content_table_schema($field['multiple']);
      }

      // Add the data columns.
      foreach ($db_info['columns'] as $column => $attributes) {
        $column_name = $attributes['column'];
        unset($attributes['column']);
        unset($attributes['sortable']);
        $schema[$table]['fields'][$column_name] = $attributes;
      }

      // Meta-data : content fields stored in that table.
      $schema[$table]['content fields'][] = $field['field_name'];
    }
  }
  return $schema;
}

/**
 * Add storage for per-field help text.
 */
function content_update_2() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'node_field_instance', 'description', 'text', array('not null' => TRUE, 'default' => ''));
      break;

    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {". _content_field_instance_tablename() ."} ADD COLUMN description mediumtext NOT NULL");
      break;
  }

  return $ret;
}

/**
 * Add information about where data is stored.
 */
function content_update_3() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'node_field', 'db_storage', 'integer', array('not null' => TRUE, 'default' => '0'));
      break;

    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {". _content_field_tablename() ."} ADD COLUMN db_storage int NOT NULL default 0");
      break;
  }

  return $ret;
}

/**
 * Add tables for content types to store their data.
 */
function content_update_4() {
  $ret = array();

  // Figure out what table to update. If node_type exists and node_type_content does not, this update is
  // being done by an early version of core that did not rename the node_type table, so use the original name, node_type.
  // If both table names exist, core has renamed the table, so use the renamed table name, node_type_content.
  if (!db_table_exists('node_type_content')) {
    $result = db_query("SELECT type_name FROM {node_type}");
  }
  else {
    $result = db_query("SELECT type_name FROM {node_type_content}");
  }
  while ($type = db_fetch_object($result)) {
    switch ($GLOBALS['db_type']) {
      case 'mysql':
      case 'mysqli':
        $ret[] = update_sql("CREATE TABLE {node_". strtr($type->type_name, '-', '_') ."} (
            vid int unsigned NOT NULL default '0',
            nid int unsigned NOT NULL default '0',
            PRIMARY KEY (vid)
          ) /*!40100 DEFAULT CHARACTER SET utf8 */");
        break;

      case 'pgsql':
        $ret[] = update_sql("CREATE TABLE {node_". strtr($type->type_name, '-', '_') ."} (
            vid int_unsigned NOT NULL default '0',
            nid int_unsigned NOT NULL default '0',
            PRIMARY KEY (vid)
          )");
        break;
    }
  }

  return $ret;
}

/**
 * Move data from per-field storage to per-content-type storage where possible.
 */
function content_update_5() {
  $ret = array();

  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');

  content_clear_type_cache();

  $result = db_query('SELECT nf.field_name FROM {". _content_field_tablename() ."} nf LEFT JOIN {". _content_field_instance_tablename() ."} nfi ON nfi.field_name = nf.field_name WHERE nf.multiple = 0 AND nf.db_storage = 0 GROUP BY nfi.field_name HAVING COUNT(*) = 1');

  if (db_num_rows($result)) {
    // Multi-part update
    if (!isset($_SESSION['content_update_5'])) {
      $_SESSION['content_update_5'] = 0;
      $_SESSION['content_update_5_max'] = db_num_rows($result);
    }

    $field = db_fetch_array($result);
    $fields = content_fields();
    $field = $fields[$field['field_name']];
    $columns = content_invoke_columns($field);

    $ret[] = update_sql("UPDATE {". _content_field_tablename() ."} SET db_storage = ". CONTENT_DB_STORAGE_PER_CONTENT_TYPE ." WHERE field_name = '". $field['field_name'] ."'");
    if (is_array($columns) && count($columns)) {
      $new_field = $field;
      $new_field['db_storage'] = CONTENT_DB_STORAGE_PER_CONTENT_TYPE;
      content_alter_db_field($field, $columns, $new_field, $columns);
    }

    $_SESSION['content_update_5']++;
    $ret['#finished'] = $_SESSION['content_update_5'] / $_SESSION['content_update_5_max'];
    return $ret;
  }
}

/**
 * The cache for nodes has changed to account for revisions correctly.
 */
function content_update_6() {
  return array(update_sql('DELETE FROM {cache}'));
}

/**
 * Rename the "content-" prefix to "content_" to aid in form theming.
 */
function content_update_7() {
  $ret = array();

  // Figure out what table to update. If node_type exists and node_type_content does not, this update is
  // being done by an early version of core that did not rename the node_type table, so use the original name, node_type.
  // If both table names exist, core has renamed the table, so use the renamed table name, node_type_content.
  if (!db_table_exists('node_type_content')) {
    $table_name = 'node_type';
  }
  else {
    $table_name = 'node_type_content';
  }
  $type_result = db_query("SELECT type_name FROM {". $table_name ."} WHERE type_name LIKE 'content-%%'");

  if (db_num_rows($type_result)) {
    // Multi-part update
    if (!isset($_SESSION['content_update_7'])) {
      $_SESSION['content_update_7'] = 0;
      $_SESSION['content_update_7_max'] = db_num_rows($type_result);
    }

    $type = db_fetch_object($type_result);
    $old_type_name = $type->type_name;
    $new_type_name = str_replace('content-', 'content_', $old_type_name);
    $ret[] = update_sql("UPDATE {node} SET type = '". $new_type_name ."' WHERE type = '". $old_type_name ."'");
    $ret[] = update_sql("UPDATE {". $table_name ."} SET type_name = '". $new_type_name ."' WHERE type_name = '". $old_type_name ."'");
    $ret[] = update_sql("UPDATE {". _content_field_instance_tablename() ."} SET type_name = '". $new_type_name ."' WHERE type_name = '". $old_type_name ."'");
    $ret[] = update_sql("UPDATE {vocabulary_node_types} SET type = '". $new_type_name ."' WHERE type = '". $old_type_name ."'");

    $variable_result = db_query("SELECT name, value FROM {variable} WHERE name LIKE '%%%s%%' OR value LIKE '%%%s%%'", $old_type_name, $old_type_name);
    while ($variable = db_fetch_object($variable_result)) {
      $new_name = str_replace($old_type_name, $new_type_name, $variable->name);
      $new_value = str_replace($old_type_name, $new_type_name, $variable->value);
      db_query("UPDATE {variable} SET name = '%s', value = '%s' WHERE name = '%s'", $new_name, $new_value, $variable->name);
    }

    $ret[] = update_sql('DELETE FROM {cache}');

    $_SESSION['content_update_7']++;
    $ret['#finished'] = $_SESSION['content_update_7'] / $_SESSION['content_update_7_max'];
    return $ret;
  }
}

/**
 * Rename the "node_type" table to avoid a conflict with a later core addition
 */
function content_update_8() {
  $ret = array();
  if (!db_table_exists('node_type_content')) {
    switch ($GLOBALS['db_type']) {
      case 'mysql':
      case 'mysqli':
        $ret[] = update_sql('RENAME TABLE {node_type} TO {node_type_content}');
        break;

      case 'pgsql':
        $ret[] = update_sql('ALTER TABLE {node_type} RENAME TO {node_type_content}');
        break;
    }
  }
  return $ret;
}

/**
 *  Fix corrupted db due to a bug in 1.3 release (http://drupal.org/node/115332)
 */
function content_update_10() {
  $ret = array();

  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');

  // drop fields with no field instances
  $fields = array();
  $result = db_query("SELECT DISTINCT(field_name)  FROM {". _content_field_instance_tablename() ."}");
  while ($row = db_fetch_array($result)) {
    $fields[] = "'". $row['field_name'] ."'";
  }
  $ret[] = update_sql("DELETE FROM {". _content_field_tablename() ."} WHERE field_name NOT IN (". implode(', ', $fields) .")");

  // set invalid 'per field storage' back to 'per content type'
  $result = db_query("SELECT field_name FROM {". _content_field_tablename() ."} WHERE multiple = 0 AND db_storage = %d", CONTENT_DB_STORAGE_PER_FIELD);
  while ($row = db_fetch_array($result)) {
    $count = db_num_rows(db_query("SELECT field_name FROM {". _content_field_instance_tablename() ."} WHERE field_name = '%s'", $row['field_name']));
    if ($count == 1) {
      $field = content_fields($row['field_name']);
      $db_info = content_database_info($field);
      $new_field = $field;
      $new_field['db_storage'] = CONTENT_DB_STORAGE_PER_CONTENT_TYPE;
      content_alter_db_field($field, $db_info['columns'], $new_field, $db_info['columns']);
    }
  }

  return $ret;
}

/**
 *  Start 5.0 update series
 *
 *  First, catch up for databases which did not get node_type table renamed in 4.7 before updating to 5.0
 *  We'll know them because update_8 will rename the node_type table to node_content_type leaving no table named node_type
 *  A core patch has been submitted to get the rename done by the system module, so we need to test whether the table is already renamed
 */

function content_update_1000() {
  $ret = array();

  if (!db_table_exists('node_type')) {
    // rerun system_update_1005(), if it failed the first time it was run
    $ret = system_update_1005();
  }
  return $ret;
}

/**
 *  Copy node_type_content table back to core node_type table
 */
function content_update_1001() {
  $ret = array();

  if (db_table_exists('node_type_content')) {
    $result = db_query("SELECT type_name, label, description, help, title_label FROM {node_type_content}");
    while ($data = db_fetch_object($result)) {
      $ret[] = update_sql("INSERT INTO {node_type}
         (type, name, module, description, help, has_title, title_label, has_body, body_label, custom, orig_type, min_word_count)
           VALUES ('". db_escape_string($data->type_name) ."', '". db_escape_string($data->label) ."', 'node', '". db_escape_string($data->description) ."', '". db_escape_string($data->help) ."', 1, '". db_escape_string($data->title_label) ."', 0, '', 1, '". db_escape_string($data->type_name) ."', 0)");
    }
    $ret[] = update_sql("DROP TABLE {node_type_content}");
    $ret[] = update_sql('DELETE FROM {cache}');
  }

  return $ret;
}

/**
 * Add display_settings column
 */
function content_update_1002() {
  $ret = array();

  // See if this column was already added in 4.7.
  $result = db_fetch_array(db_query_range("SELECT * FROM {". _content_field_instance_tablename() ."}", array(), 0, 1));
  if (isset($result['display_settings'])) {
    return $ret;
  }

  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'node_field_instance', 'display_settings', 'text', array('not null' => TRUE, 'default' => "''"));
      break;

    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {". _content_field_instance_tablename() ."} ADD COLUMN display_settings mediumtext NOT NULL");
      break;
  }

  return $ret;
}

/**
 *  Rename data tables to avoid collision with core node_* tables
 */
function content_update_1003() {
  $ret = array();

  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');

  $rename = array();

  $types = content_types();
  $fields = content_fields();

  // "per content type" tables
  foreach ($types as $type) {
    $old_name = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
    $new_name = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE, 1003);
    if (db_table_exists($old_name)) {
      if (!in_array($old_name, array('node_access',  'node_comments_statistics', 'node_counter', 'node_field', 'node_field_instance', 'content_group', 'content_group_fields', 'node_revisions', 'node_type'))) {
        $rename[$old_name] = $new_name;
      }
      else {
        // TODO : what ? create the table ?
      }
    }
  }

  // "per field" tables
  foreach ($fields as $field) {
    $old_name = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);
    $new_name = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD, 1003);
    $old_name = 'node_data_'.$field['field_name'];
    $new_name = 'content_'. $field['field_name'];
    if (db_table_exists($old_name)) {
      $rename[$old_name] = $new_name;
    }
  }

  // rename
  foreach ($rename as $old_name => $new_name) {
    switch ($GLOBALS['db_type']) {
      case 'mysql':
      case 'mysqli':
        $ret[] = update_sql("RENAME TABLE {". $old_name ."} TO {". $new_name ."}");
        break;

      case 'pgsql':
        $ret[] = update_sql("ALTER TABLE {". $old_name ."} RENAME TO {". $new_name ."}");
        break;
    }
  }

  variable_set('content_schema_version', 1003);
  // Set a followup flag for content_update_1005.
  $_SESSION['content_update_1003_followup'] = TRUE;

  return $ret;
}

/**
 *  Fix corrupted db due to a bug in 1.3 release (http://drupal.org/node/115332)
 */
function content_update_1004() {
  $ret = array();

  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');

  // drop fields with no field instances
  $fields = array();
  $result = db_query("SELECT DISTINCT(field_name) FROM {". _content_field_instance_tablename() ."}");
  while($row = db_fetch_array($result)) {
    $fields[] = "'". $row['field_name'] ."'";
  }
  if ($fields) {
    $ret[] = update_sql("DELETE FROM {". _content_field_tablename() ."} WHERE field_name NOT IN (". implode(', ', $fields) .")");
  }

  // drop 'content_type_' table
  $table = _content_tablename('', CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  if (db_table_exists($table)) {
    $ret[] = update_sql("DROP TABLE {".$table."}");
  }

  // set invalid 'per field storage' back to 'per content type'
  $result = db_query("SELECT field_name FROM {". _content_field_tablename() ."} WHERE multiple = 0 AND db_storage = %d", CONTENT_DB_STORAGE_PER_FIELD);
  while ($row = db_fetch_array($result)) {
    $count = db_num_rows(db_query("SELECT field_name FROM {". _content_field_instance_tablename() ."} WHERE field_name = '%s'", $row['field_name']));
    if ($count == 1) {
      $field = content_fields($row['field_name']);
      $db_info = content_database_info($field);
      $new_field = $field;
      $new_field['db_storage'] = CONTENT_DB_STORAGE_PER_CONTENT_TYPE;
      content_alter_db_field($field, $db_info['columns'], $new_field, $db_info['columns']);
    }
  }

  return $ret;
}

/**
 *  Regenerate views (was in content_update_1003, but was later moved out in a separate update
 */
function content_update_1005() {
  $ret = array();

  if (isset($_SESSION['content_update_1003_followup'])) {
    content_clear_type_cache();
    if (module_exists('views')) {
      include_once('./'. drupal_get_path('module', 'content') .'/content_views.inc');
      $updated_views = _content_views_rebuild_views(array_keys(content_fields()));
      foreach ($updated_views as $view) {
        $ret[] = array(
          'query' => strtr('The views %view has been regenerated.', array('%view' => $view)),
          'success' => TRUE
        );
      }
    }
  }

  return $ret;
}

/**
 *  Set text db columns to accept NULL values for mysql (see http://drupal.org/node/108094)
 */
function content_update_1006() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      include_once('./'. drupal_get_path('module', 'content') .'/content.module');
      include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');

      $types = content_types();
      $fields = content_fields();

      foreach ($fields as $field) {
        $db_info = content_database_info($field);
        foreach ($db_info['columns'] as $column => $attributes) {
          if (in_array($attributes['type'], array('text', 'mediumtext', 'longtext'))) {
            db_change_field($ret, $db_info['table'], $attributes['column'], $attributes['column'], $attributes);
            $ret[] = array(
              'query' => strtr('The text field %field has been updated to accept NULL values.', array('%field' => $field['field_name'])),
              'success' => TRUE
            );
          }
        }
      }
  }

  return $ret;
}


/**
 *  Add separate cache_content table
 */
function content_update_1007() {
  $ret = array();

  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("CREATE TABLE {cache_content} (
        cid varchar(255) NOT NULL default '',
        data longblob,
        expire int NOT NULL default '0',
        created int NOT NULL default '0',
        headers text,
        PRIMARY KEY (cid),
        INDEX expire (expire)
      ) /*!40100 DEFAULT CHARACTER SET UTF8 */ ");
      break;
    case 'pgsql':
      $ret[] = update_sql("CREATE TABLE {cache_content} (
        cid varchar(255) NOT NULL default '',
        data bytea,
        expire int NOT NULL default '0',
        created int NOT NULL default '0',
        headers text,
        PRIMARY KEY (cid)
      )");
      $ret[] = update_sql("CREATE INDEX {cache_content}_expire_idx ON {cache_content} (expire)");
      break;
  }

  return $ret;
}

/**
 *  Placeholder for CCK 1.5 / Views 1.6 message - not relevant for D6 ?
 */
function content_update_1008() {
  return array();
}

/**
 * Add module name to fields table to make it easier to identify the fields to delete when a module
 * is uninstalled.
 *
 * Needed because the value drops out of content_info() when module is disabled, so there
 * is no other way to find the associated fields.
 */
function content_update_6000() {
  $ret = array();
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  include_once('./'. drupal_get_path('module', 'content') .'/content_admin.inc');
  switch ($GLOBALS['db_type']) {
    case 'pgsql':
      db_add_column($ret, 'node_field', 'module', 'varchar(127)', array('not null' => TRUE, 'default' => "''"));
      db_add_column($ret, 'node_field_instance', 'module', 'varchar(127)', array('not null' => TRUE, 'default' => "''"));
      break;

    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {". _content_field_tablename() ."} ADD COLUMN module varchar(127) NOT NULL");
      $ret[] = update_sql("ALTER TABLE {". _content_field_instance_tablename() ."} ADD COLUMN module varchar(127) NOT NULL");
      break;
  }
  foreach (_content_field_types() as $type => $field) {
    if (!empty($type)) {
      $ret[] = update_sql("UPDATE {". _content_field_tablename() ."} SET module = '". $field['module'] ."' WHERE type = '". $type ."'");
    }
  }
  foreach (_content_widget_types() as $type => $field) {
    if (!empty($type)) {
      $ret[] = update_sql("UPDATE {". _content_field_instance_tablename() ."} SET module = '". $field['module'] ."' WHERE widget_type = '". $type ."'");
    }
  }
  return $ret;
}

function content_update_6001() {
  $ret = array();
  // If a field named 'field_instance' already exists, change it so we
  // won't have a table name clash with new content_field_instance table.
  $fields = content_fields();
  if (in_array('field_instance', array_keys($fields))) {
    if (db_table_exists('content_field_instance')) {
      db_rename_table($ret, 'content_field_instance', 'content_field_instance2');
    }
    $ret = sql_query("UPDATE {node_field} SET field_name = 'content_field_instance2' WHERE field_name = 'field_instance'");
    $ret = sql_query("UPDATE {node_field_instance} SET field_name = 'field_instance2' WHERE field_name = 'field_instance'");
    // Content module should be getting updated before fieldgroup, but just in case...
    if (db_table_exists('node_group_fields')) {
      $ret = sql_query("UPDATE {node_group_fields} SET field_name = 'field_instance2' WHERE field_name = 'field_instance'");
    }
    elseif (db_table_exists('content_group_fields')) {
      $ret = sql_query("UPDATE {content_group_fields} SET field_name = 'field_instance2' WHERE field_name = 'field_instance'");
    }
  }
  db_rename_table($ret, 'node_field', 'content_field');
  db_rename_table($ret, 'node_field_instance', 'content_field_instance');
  variable_set('content_schema_version', 6001);
  return $ret;
}