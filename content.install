<?php
// $Id$

/**
 * Implementation of hook_install().
 */
function content_install() {
  variable_set('content_schema_version', 6002);
  drupal_install_schema('content');
}


/**
 * Implementation of hook_uninstall().
 */
function content_uninstall() {
  variable_del('content_schema_version');
  drupal_uninstall_schema('content');
}

/**
 * Implementation of hook_enable().
 */
function content_enable() {
}

/**
 * Implementation of hook_disable().
 */
function content_disable() {
}

/**
 * Test and report Content module installation requirements.
 */
function content_requirements($phase) {
  $requirements = array();

  // Ensure translations don't break at install time
  $t = get_t();

  $current_version = drupal_get_installed_schema_version('content');
  $minimum_version = 1008;

  if ($current_version < $minimum_version) {
    $requirements['content_version'] = array(
      'title' => $t('Content Version'),
      'value' => $t('Your CCK database is not up to date and will not work correctly in this version of the Content module. Please upgrade your database in Drupal 5.x to at least Content update %number, using the latest 5.x version of the Content module, before upgrading to Drupal 6.x.', array('%number' => $minimum_version)),
      'severity' => REQUIREMENT_ERROR,
    );
  }
  return $requirements;
}

/**
 * Implementation of hook_schema.
 */
function content_schema() {

  // Static (meta) tables.

  $schema['content_node_field'] = array(
    'fields' => array(
      'field_name'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type'            => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
      'global_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'required'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'multiple'        => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0),
      'db_storage'      => array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 1),
      'module'          => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
      'columns'         => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
    ),
    'primary key' => array('field_name'),
  );
  $schema['content_node_field_instance'] = array(
    'fields' => array(
      'field_name'       => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'type_name'        => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),
      'label'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),
      'widget_type'      => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),
      'widget_settings'  => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'display_settings' => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'description'      => array('type' => 'text', 'size' => 'medium', 'not null' => TRUE),
      'widget_module'    => array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''),
    ),
    'primary key' => array('field_name', 'type_name'),
  );
  $schema['cache_content'] = drupal_get_schema_unprocessed('system', 'cache');

  // Dynamic (data) tables.
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');

  // When the module is first installed, the remaining code in the schema
  // will create errors, since these tables have not yet been created.
  // We don't need to create those tables on initial installation anyway
  // since no fields have been created yet, so just return with this much
  // of the schema.

  if (!db_table_exists('content_node_field') || !db_table_exists('content_node_field_instance')) {
    return $schema;
  }

  // Can't use many helper functions here, like content_fields() or
  // content_types() or we risk creating a fatal loop from circular
  // logic when they call other functions that use this schema, so create
  // the schema directly from a fresh query of the database.

  // content_table_schema() and content_database_info() have no
  // circular logic and are safe to use here.

  $db_result = db_query("SELECT * FROM {". content_instance_tablename() ."} nfi ".
    " LEFT JOIN {". content_field_tablename() ."} nf ON nf.field_name = nfi.field_name");
  while ($field = db_fetch_array($db_result)) {
    $field['columns'] = unserialize($field['columns']);
    $content_table = _content_tablename($field['type_name'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
    $field_table = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);

    // We always add a 'per content type' table.
    // TODO : is that really still needed ?
    if (!isset($schema[$content_table])) {
      $schema[$content_table] = content_table_schema();
    }

    // Add the 'per field' table if needed.
    if (!isset($schema[$field_table]) && $field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD) {
      $schema[$field_table] = content_table_schema($field);
    }
    else {
      $content_schema = content_table_schema($field);
      $schema[$content_table]['fields'] = array_merge($schema[$content_table]['fields'], $content_schema['fields']);
      $schema[$content_table]['content fields'] = array_merge($schema[$content_table]['content fields'], $content_schema['content fields']);
    }
  }
  return $schema;
}

/**
 * Add module name to fields table to make it easier to identify the fields to delete when a module
 * is uninstalled.
 *
 * Needed because the value drops out of content_info() when module is disabled, so there
 * is no other way to find the associated fields.
 */
function content_update_6000() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_column_exists(content_field_tablename(), 'columns')) {
    return $ret;
  }
  db_add_field($ret, content_field_tablename(), 'module', array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''));
  db_add_field($ret, content_field_tablename(), 'columns', array('type' => 'text', 'not null' => TRUE, 'default' => ''));
  db_add_field($ret, content_instance_tablename(), 'widget_module', array('type' => 'varchar', 'length' => 127, 'not null' => TRUE, 'default' => ''));

  foreach (module_list() as $module) {
    $module_field_types = module_invoke($module, 'field_info');
    if ($module_field_types) {
      foreach ($module_field_types as $name => $field_info) {
        $ret[] = update_sql("UPDATE {". content_field_tablename() ."} SET module = '". $module ."' WHERE type = '". $name ."'");
        foreach (content_fields() as $field) {
          if ($field['type'] == $name) {
            $columns = module_invoke($module, 'field_settings', 'database columns', $field);
            if ($columns) {
              // Using db_query() instead of update_sql() here because serialized arrays
              // lose data in the escaping done by update_sql().
              db_query("UPDATE {". content_field_tablename() ."} SET columns = '%s' WHERE field_name = '%s'", serialize($columns), $field['field_name']);
            }
          }
        }
      }
    }
    $module_widgets = module_invoke($module, 'widget_info');
    if ($module_widgets) {
      foreach ($module_widgets as $name => $widget_info) {
        $ret[] = update_sql("UPDATE {". content_instance_tablename() ."} SET widget_module = '". $module ."' WHERE widget_type = '". $name ."'");
      }
    }

  }
  return $ret;
}

/**
 * Rename node_field and node_field_instance tables.
 *
 * This is a carryover from when the data tables were renamed,
 * postponed so we wouldn't create any more havoc than necessary
 * until a major version change.
 *
 * Using 'content_node_field' instead of 'content_field'
 * to avoid conflicts with field tables that will be prefixed
 * with 'content_field'.
 */
function content_update_6001() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();
  if (db_table_exists('content_node_field')) {
    return $ret;
  }
  db_rename_table($ret, 'node_field', 'content_node_field');
  db_rename_table($ret, 'node_field_instance', 'content_node_field_instance');
  variable_set('content_schema_version', 6001);
  content_clear_type_cache(TRUE);
  return $ret;
}

/**
 * Get rid of automatic per content tables for content types that have no fields.
 * Switching to adding those tables only when needed.
 */
function content_update_6002() {
  include_once('./'. drupal_get_path('module', 'content') .'/content.module');
  $ret = array();

  $db_types = content_types();
  $field_types = array();

  $result = db_query("SELECT DISTINCT type_name FROM {". content_instance_tablename() ."}");
  while ($type = db_fetch_array($result)) {
    $field_types[] = $type['type_name'];
  }

  foreach ($db_types as $content_type => $content_info) {
    if (!in_array($content_type, $field_types)) {
      $table = _content_tablename($content_type, CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
      if (db_table_exists($table)) {
        db_drop_table($ret, $table);
      }
    }
  }
  variable_set('content_schema_version', 6002);
  content_clear_type_cache(TRUE);
  return $ret;
}