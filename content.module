<?php
// $Id$
/**
 * @file
 * Allows administrators to associate custom fields to content types.
 */

define('CONTENT_DB_STORAGE_PER_FIELD', 0);
define('CONTENT_DB_STORAGE_PER_CONTENT_TYPE', 1);

define('CONTENT_CALLBACK_NONE', 0x0001);
define('CONTENT_CALLBACK_DEFAULT', 0x0002);
define('CONTENT_CALLBACK_CUSTOM', 0x0004);

define('CONTENT_HANDLE_CORE', 0x0001);
define('CONTENT_HANDLE_MODULE', 0x0002);

function content_help($path, $arg) {
  if (preg_match('!^admin/content/types/.*/display$!', $path)) {
    return t("Configure how this content type's fields and field labels should be displayed when it's viewed in teaser and full-page mode.");
  }
}

/**
 * Implementation of hook_devel_caches().
 * Include {cache_content} in the list of tables cleared by devel's 'empty cache'
 */
function content_devel_caches() {
  return array(content_cache_tablename());
}

/**
 * Implementation of hook_init().
 */
function content_init() {
  drupal_add_css(drupal_get_path('module', 'content') .'/content.css');
  if (module_exists('views')) {
    module_load_include('inc', 'content', 'content_views');
  }
  if (module_exists('pathauto')) {
    module_load_include('inc', 'content', 'content_pathauto');
  }
  // When adding new content types and fields, a menu rebuild is needed,
  // but sometimes it won't work right until other processes complete.
  // This session variable provides a way to delay the rebuild until
  // the next page load.
  if (isset($_SESSION['content_menu_needs_rebuild'])) {
    content_clear_type_cache(TRUE);
    menu_rebuild();
    unset($_SESSION['content_menu_needs_rebuild']);
  }
}

/**
 * Implementation of hook_menu().
 */
function content_menu() {
  $items = array();
  $items['admin/content/types/fields'] = array(
    'title' => 'Fields',
    'page callback' => '_content_admin_type_fields',
    'access arguments' => array('administer content types'),
    'file' => 'content_admin.inc',
    'file path' => drupal_get_path('module', 'content'),
    'type' => MENU_LOCAL_TASK,
  );
  // Callback for AHAH add more buttons.
  $items['content/js_add_more'] = array(
    'page callback' => 'content_add_more_js',
    // TODO : access rule ?
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  foreach (node_get_types() as $type) {
    $type_name = $type->type;
    $content_type = content_types($type_name);

    // Make sure this doesn't fire until content_types is working,
    // needed to avoid errors on initial installation.
    if (!empty($content_type)) {
      $type_url_str = $content_type['url_str'];
      $items['admin/content/types/'. $type_url_str .'/edit'] = array(
        'title' => t('Edit'),
        'type' => MENU_DEFAULT_LOCAL_TASK,
      );
      $items['admin/content/types/'. $type_url_str .'/fields'] = array(
        'title' => 'Manage fields',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('content_admin_field_overview_form', $type_name),
        'access arguments' => array('administer content types'),
        'file' => 'content_admin.inc',
        'file path' => drupal_get_path('module', 'content'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 1,
      );
      $items['admin/content/types/'. $type_url_str .'/display'] = array(
        'title' => 'Display fields',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('content_admin_display_overview_form', $type_name),
        'access arguments' => array('administer content types'),
        'file' => 'content_admin.inc',
        'file path' => drupal_get_path('module', 'content'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 2,
      );
      $items['admin/content/types/'. $type_url_str .'/add_field'] = array(
        'title' => 'Add field',
        'page callback' => '_content_admin_field_add',
        'page arguments' => array($type_name),
        'access arguments' => array('administer content types'),
        'file' => 'content_admin.inc',
        'file path' => drupal_get_path('module', 'content'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 3,
      );
      foreach ($content_type['fields'] as $field) {
        $field_name = $field['field_name'];
        $items['admin/content/types/'. $type_url_str .'/fields/'. $field_name] = array(
          'title' => t($field['widget']['label']),
          'page callback' => 'drupal_get_form',
          'page arguments' => array('_content_admin_field', $type_name, $field_name),
          'access arguments' => array('administer content types'),
          'file' => 'content_admin.inc',
          'file path' => drupal_get_path('module', 'content'),
          'type' => MENU_LOCAL_TASK,
        );
        $items['admin/content/types/'. $type_url_str .'/fields/'. $field_name .'/remove'] = array(
          'title' => 'Remove field',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('_content_admin_field_remove', $type_name, $field_name),
          'access arguments' => array('administer content types'),
          'file' => 'content_admin.inc',
          'file path' => drupal_get_path('module', 'content'),
          'type' => MENU_CALLBACK,
        );
      }
    }
  }
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function content_theme() {
  return array(
    'field' => array(
      'template' => 'field',
      'arguments' => array('node' => NULL, 'field' => NULL, 'items' => NULL, 'teaser' => FALSE, 'page' => FALSE),
    ),
    'content_admin_field_overview_form' => array(
      'arguments' => array('form' => NULL),
    ),
    'content_admin_display_overview_form' => array(
      'arguments' => array('form' => NULL),
    ),
    'content_admin_field_add_new_field_widget_type' => array(
      'arguments' => array('form' => NULL),
    ),
    'content_view_multiple_field' => array(
      'arguments' => array('items' => NULL, 'field' => NULL, 'data' => NULL),
    ),
    'content_multiple_values' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Load data for a node type's fields.
 *
 * When loading one of the content.module nodes, we need to let each field handle
 * its own loading. This can make for a number of queries in some cases, so we
 * cache the loaded object structure and invalidate it during the update process.
 */
function content_load($node) {
  $cid = 'content:'. $node->nid .':'. $node->vid;
  if ($cached = cache_get($cid, content_cache_tablename())) {
    return $cached->data;
  }
  else {
    $default_additions = _content_field_invoke_default('load', $node);
    if ($default_additions) {
      foreach ($default_additions as $key => $value) {
        $node->$key = $value;
      }
    }
    $additions = _content_field_invoke('load', $node);
    if ($additions) {
      foreach ($additions as $key => $value) {
        $node->$key = $value;
        $default_additions[$key] = $value;
      }
    }
    cache_set($cid, $default_additions, content_cache_tablename());
    return $default_additions;
  }
}

/**
 * Create fields' form for a content type.
 *
 * Widget_invoke() is gone, this is the only place the widget function
 * is called.
 *
 * Each field defines its own component of the content entry form, via its
 * chosen widget.
 */
function content_form(&$form, &$form_state) {
  $node = $form['#node'];
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  if (count($type['fields'])) {
    foreach ($type['fields'] as $field_name => $field) {
      $form['#field_info'][$field['field_name']] = $field;
      $form += (array) content_field_form($form, $form_state, $field);
    }
  }
  return $form;
}

/**
 * Create a separate form element for each field.
 *
 * Extracted from content_form() to make it possible to get a subform
 * for just a single field at a time.
 *
 * Hook_widget() picks up two new values, $count and $delta, to help
 * widgets know what information to return since multiple values are
 * sometimes controlled by the content module.
 *
 * @param $form
 *   the form to add this field element to
 * @param $form_state
 *   the form_state for the above form
 * @param $field
 *   the field array to use to create the form element
 * @param $get_delta
 *   use to get only a specific delta value of a multiple value field, otherwise
 *   function will return the entire $field form element.
 */
function content_field_form(&$form, &$form_state, $field, $get_delta = NULL) {
  $form['#cache'] = FALSE;
  $node = $form['#node'];
  $addition = array();
  $form_element = array();
  $function = $field['widget']['module'] .'_widget';
  $field_name = $field['field_name'];
  if (function_exists($function)) {
    // Prepare the values to be filled in the widget.
    // We look in the following places :
    // - Form submitted values
    // - Node values (when editing an existing node), or pre-filled values (when
    //   creating a new node translation)
    // - Default values set for the field (when creating a new node).
    $items = array();
    if (!empty($form_state['values'][$field['field_name']])) {
      $items = $form_state['values'][$field['field_name']];
    }
    elseif (!empty($node->$field['field_name'])) {
      $items = $node->$field['field_name'];
    }
    elseif (empty($node->nid)) {
      if (content_callback('widget', 'default value', $field) != CONTENT_CALLBACK_NONE) {
        $callback = content_callback('widget', 'default value', $field) == CONTENT_CALLBACK_CUSTOM ? $module .'_default_value' : 'content_default_value';
        if (function_exists($callback)) {
          $items = $callback($form, $form_state, $field, 0);
        }
      }
    }
    // If content module handles multiple values for this form element,
    // and not selecting an individual $delta, process the multiple value form.
    if (!isset($get_delta) && content_handle('widget', 'multiple values', $field) == CONTENT_HANDLE_CORE) {
      $form_element = content_multiple_value_form($form, $form_state, $field, $items);
    }
    // If the widget is handling multiple values (e.g optionwidgets),
    // or selecting an individual element, just get a single form
    // element and make it the $delta value.
    else {
      $delta = isset($get_delta) ? $get_delta : 0;
      if ($element = $function($form, $form_state, $field, $items, $delta)) {
        $defaults = array(
          '#field_name' => $field['field_name'],
          '#required' => $get_delta > 0 ? FALSE : $field['required'],
          // TODO : should we add some logic for title and description too ?
          '#columns'  => array_keys($field['columns']),
          '#title' => t($field['widget']['label']),
          '#delta' => $delta,
        );
        $form_element[$delta] = array_merge($element, $defaults);
      }
    }

    // Field name is needed at top level as well as the individual elements
    // so the multiple values or other field level theme or processing can find it.
    if ($form_element) {
      $defaults = array(
        '#field_name' => $field['field_name'],
        '#tree' => TRUE,
        '#weight' => $field['widget']['weight'],
        '#count' => sizeof($form_element),
      );
      $addition[$field['field_name']] = array_merge($form_element, $defaults);

    }
  }
  return $addition;
}

/**
 * Special handling to create form elements for multiple values.
 *
 * Handles generic features for multiple fields :
 * - number of widgets
 * - AHAH-'add more' button
 * - drag-n-drop value reordering
 */
function content_multiple_value_form(&$form, &$form_state, $field, $items) {
  $field_name = $field['field_name'];

  switch ($field['multiple']) {
    case 0:
      $max = 0;
      break;
    case 1:
      $max = (isset($form_state['item_count'][$field_name]) ? $form_state['item_count'][$field_name] : count($items));
      break;
    default:
      $max = $field['multiple'] - 1;
      break;
  }

  $form_element = array(
    // TODO : Not sure about that one - when theming through '#type',
    // children are already rendered, and we can't do the table layout.
    //'#type' => 'content_multiple_values',
    '#theme' => 'content_multiple_values',
    '#title' => t($field['widget']['label'])
  );
  $function = $field['module'] .'_widget';

  for ($delta = 0; $delta <= $max; $delta++) {
    if ($element = $function($form, $form_state, $field, $items, $delta)) {
      $defaults = array(
        '#field_name' => $field_name,
        '#title' => ($field['multiple'] >= 1) ? '' : t($field['widget']['label']),
        '#required' => $delta == 0 && $field['required'],
        '#weight' => $delta,
        '#delta' => $delta,
        '#columns' => array_keys($field['columns']),
      );

      // Add an input field for the delta (drag-n-drop reordering), which will
      // be hidden by tabledrag js behavior.
      if ($field['multiple'] >= 1) {
        // We name the element '_weight' to avoid clashing with column names
        // defined by field modules.
        $element['_weight'] = array(
          // When JS is disabled, a weight selector will be more convenient (?),
          // but won't work well with more than 10 values.
          '#type' => ($max < 10) ? 'weight' : 'textfield',
          '#default_value' => $delta,
          '#weight' => 100,
        );
      }

      $form_element[$delta] = array_merge($element, $defaults);
    }
  }

  // Add AHAH add more button, if not working with a programmed form.
  if ($field['multiple'] == 1 && empty($form['#programmed'])) {
    // Make sure the form is cached so ahah can work.
    $form['#cache'] = TRUE;
    $content_type = content_types($form['type']['#value']);
    $field_name_css = str_replace('_', '-', $field_name);

    $form_element[$field_name .'_add_more'] = array(
      '#type' => 'submit',
      '#value' => t('Add another !field value', array('!field' => t($field['widget']['label']))),
      '#description' => t("If the amount of boxes above isn't enough, click here to add more items."),
      '#weight' => $field['widget']['weight'] + $max + 1,
      '#submit' => array('content_add_more_submit'), // If no javascript action.
      '#ahah' => array(
        'path' => 'content/js_add_more/'. $content_type['url_str'] .'/'. $field_name,
        'wrapper' => $field_name_css .'-items',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );

    // Add wrappers for the fields and 'more' button.
    // TODO : could be simplified ?
    $form_element['#prefix'] = '<div class="clear-block" id="'. $field_name_css .'-add-more-wrapper"><div id="'. $field_name_css .'-items">';
    $form_element[$field_name .'_add_more']['#prefix'] = '<div class="content-add-more">';
    $form_element[$field_name .'_add_more']['#suffix'] =  '</div></div></div>';
  }
  return $form_element;
}

/**
 * Submit handler to add more choices to a content form. This handler is used when
 * javascript is not available. It makes changes to the form state and the
 * entire form is rebuilt during the page reload.
 */
function content_add_more_submit($form, &$form_state) {
  // Set the form to rebuild and run submit handlers.
  node_form_submit_build_node($form, $form_state);

  foreach ($form['#field_info'] as $field_name => $field) {
    // Make the changes we want to the form state.
    if ($form_state['values'][$field_name][$field_name .'_add_more']) {
      $form_state['item_count'][$field_name] = count($form_state['node'][$field_name]) + 1;
    }
  }
}

/**
 * Menu callback for AHAH addition of new empty widgets.
 */
function content_add_more_js($type_name_url, $field_name) {
  $type = content_types($type_name_url);
  $field = content_fields($field_name, $type['type']);
  if ($field['multiple'] != 1) {
    // TODO : is that correct ?
    drupal_json(array('status' => 0));
  }

  // Reorder values to account for drag-n-drop reordering
  $_POST[$field_name] = _content_sort_items($field, $_POST[$field_name]);
  $delta = max(array_keys($_POST[$field_name])) + 1;
  // Retrieve the cached form.
  $form_state = array('values' => $_POST);
  $form = form_get_cache($_POST['form_build_id'], $form_state);

  // Build our new form element for the whole field,
  // and let other modules alter it.
  $form_element = content_field_form($form, $form_state, $field);
  drupal_alter('form', $form_element, array(), 'content_add_more_js');

  // Add the new element at the right place in the form.
  if (module_exists('fieldgroup') && ($group_name = _fieldgroup_field_get_group($type['type'], $field_name))) {
    $form[$group_name][$field_name] = $form_element[$field_name];
  }
  else {
    $form[$field_name] = $form_element[$field_name];
  }

  // Save the new definition of the form.
  form_set_cache($_POST['form_build_id'], $form, $form_state);

  // Build the new form so that we can render the new element.
  $_POST[$field_name][$delta]['_weight'] = $delta;   // TODO : Hack !!
  $form_state = array('submitted' => FALSE);
  $form += array(
    '#post' => $_POST,
    '#programmed' => FALSE,
  );
  $form = form_builder($_POST['form_id'], $form, $form_state);

  // TODO : bug - the new element gets an empty delta value

  // Render the new output.
  $field_form = (!empty($group_name)) ? $form[$group_name][$field_name] : $form[$field_name];
  // We add a div around the new content to receive the ahah effect.

  $field_form[$delta]['#prefix'] = '<div class="ahah-new-content">'. (isset($field_form[$delta]['#prefix']) ? $field_form[$delta]['#prefix'] : '');
  $field_form[$delta]['#suffix'] = (isset($field_form[$delta]['#suffix']) ? $field_form[$delta]['#suffix'] : '') .'</div>';
  $output = theme('status_messages') . drupal_render($field_form);
  drupal_json(array('status' => TRUE, 'data' => $output));
}

/**
 * Nodeapi 'validate' op.
 *
 */
function content_validate(&$node) {
  _content_field_invoke('validate', $node);
  _content_field_invoke_default('validate', $node);
}

/**
 * Nodeapi 'presave' op.
 *
 */
function content_presave(&$node) {
  _content_field_invoke('presave', $node);
  _content_field_invoke_default('presave', $node);
}

/**
 * Nodeapi 'insert' op.
 *
 * Insert node type fields.
 */
function content_insert(&$node) {
  _content_field_invoke('insert', $node);
  _content_field_invoke_default('insert', $node);
}

/**
 * Nodeapi 'update' op.
 *
 * Update node type fields.
 */
function content_update(&$node) {
  _content_field_invoke('update', $node);
  _content_field_invoke_default('update', $node);
  cache_clear_all('content:'. $node->nid .':'. $node->vid, content_cache_tablename());
}

/**
 * Nodeapi 'delete' op.
 *
 * Delete node type fields.
 */
function content_delete(&$node) {
  $type = content_types($node->type);
  if (!empty($type['fields'])) {
    _content_field_invoke('delete', $node);
    _content_field_invoke_default('delete', $node);
  }
  $table = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  if (db_table_exists($table)) {
    db_query('DELETE FROM {'. $table .'} WHERE nid = %d', $node->nid);
  }
  cache_clear_all('content:'. $node->nid, content_cache_tablename(), TRUE);
}

/**
 * Nodeapi 'delete_revision' op.
 *
 * Delete node type fields for a revision.
 */
function content_delete_revision(&$node) {
  $type = content_types($node->type);
  if (!empty($type['fields'])) {
    _content_field_invoke('delete revision', $node);
    _content_field_invoke_default('delete revision', $node);
  }
  $table = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  if (db_table_exists($table)) {
    db_query('DELETE FROM {'. $table .'} WHERE vid = %d', $node->vid);
  }
  cache_clear_all('content:'. $node->nid .':'. $node->vid, content_cache_tablename());
}

/**
 * Nodeapi 'view' op.
 *
 * Generate field render arrays.
 */
function content_view(&$node, $teaser = FALSE, $page = FALSE) {
  $additions = _content_field_invoke_default('view', $node);
  $node->content = array_merge((array) $node->content, $additions);
}

/**
 * Nodeapi 'prepare translation' op.
 *
 * Generate field render arrays.
 */
function content_prepare_translation(&$node) {
  $default_additions = _content_field_invoke_default('prepare translation', $node);
  $node = (object) array_merge((array) $node, $default_additions);
}

/**
 * Implementation of hook_nodeapi().
 */
function content_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'load':
      return content_load($node);

    case 'validate':
      content_validate($node);
      break;

    case 'presave':
      content_presave($node);
      break;

    case 'insert':
      content_insert($node);
      break;

    case 'update':
      content_update($node);
      break;

    case 'delete':
      content_delete($node);
      break;

    case 'delete revision':
      content_delete_revision($node);
      break;

    case 'view':
      content_view($node, $teaser, $page);
      break;

    case 'prepare translation':
      content_prepare_translation($node);
      break;

  }
}

/**
 *  Implementation of hook_form_alter().
 */
function content_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type'])) {
    if ($form['type']['#value'] .'_node_form' == $form_id) {
      $form = array_merge($form, content_form($form, $form_state));
    }
  }
}

/**
 * Modules notify Content module when uninstalled, disabled, etc.
 *
 * @param string $op
 *   the module operation: uninstall, install, enable, disable
 * @param string $module
 *   the name of the affected module.
 * @TODO
 *   figure out exactly what needs to be done by content module when
 *   field modules are installed, uninstalled, enabled or disabled.
 */
function content_notify($op, $module) {
  switch ($op) {
    case 'install':
      content_clear_type_cache();
      break;
    case 'uninstall':
      module_load_include('inc', 'content', 'content_crud');
      content_module_delete($module);
      content_clear_type_cache(TRUE);
      break;
    case 'enable':
      content_clear_type_cache();
      break;
    case 'disable':
      content_clear_type_cache(TRUE);
      break;
  }
}

/**
 * Implementation of hook_field(). Handles common field housekeeping.
 *
 * This implementation is special, as content.module does not define any field
 * types. Instead, this function gets called after the type-specific hook, and
 * takes care of default stuff common to all field types.
 */
function content_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    case 'validate':
      // TODO : here we could validate that the number of multiple data is correct ?
      // We're controlling the number of fields to fill out and saving empty
      // ones if a specified number is requested, so no reason to do any validation
      // here right now, but if later create a method to indicate whether
      // 'required' means all values must be filled out, we can come back
      // here and check that they're not empty.
      break;

    case 'presave':
      // If there was an AHAH add more button in this field, don't save it.
      // TODO : this is too late to do this : currently $items in hook_field('validate')
      // contain the extraneous 'add more' element.
      unset($items[$field['field_name']. '_add_more']);

      // If content module is handling multiple values, don't save empty items.
      if (content_handle('widget', 'multiple values', $field) == CONTENT_HANDLE_CORE) {
        // Filter out empty values.
        $items = content_set_empty($field, $items);
        // Reorder items to account for drag-n-drop reordering.
        $items = _content_sort_items($field, $items);
      }
      break;

    case 'view':
      if ($node->build_mode == NODE_BUILD_NORMAL) {
        $context = $teaser ? 'teaser' : 'full';
      }
      else {
        $context = $node->build_mode;
      }

      $formatter = isset($field['display_settings'][$context]['format']) ? $field['display_settings'][$context]['format'] : 'default';
      $value = '';

      if ($formatter != 'hidden') {
        foreach ($items as $delta => $item) {
          $items[$delta]['view'] = content_format($field, $item, $formatter, $node);
        }
        // Do not include field labels when indexing content.
        if ($context == NODE_BUILD_SEARCH_INDEX) {
          $field['display_settings']['label']['format'] = 'hidden';
        }
        $value = theme('field', $node, $field, $items, $teaser, $page);
      }
      $addition[$field['field_name']] = array(
        '#weight' => $field['widget']['weight'],
        '#value' => $value,
        '#access' => $formatter != 'hidden',
      );
      return $addition;

    case 'prepare translation':
      $addition = array();
      if (isset($node->translation_source->$field['field_name'])) {
        $addition[$field['field_name']] = $node->translation_source->$field['field_name'];
      }
      return $addition;
  }
}

/**
 * Helper function to set NULL values and unset items where needed.
 *
 * If a specified number of multiple values was requested or this is
 * the zero delta, save even if empty and keep a NULL value for each
 * of its columns so there is a marker row in the database, otherwise
 * unset the item.
 *
 * @param array $field
 * @param array $items
 * @return array
 *   returns emptied and adjusted item array
 */
function content_set_empty($field, $items) {
  $is_empty = $field['module'] .'_content_is_empty';
  $max_delta = $field['multiple'] > 1 ? $field['multiple'] : 0;
  foreach ((array) $items as $delta => $item) {
    if ($is_empty($item, $field)) {
      if ($delta <= $max_delta) {
        foreach (array_keys($field['columns']) as $column) {
          $items[$delta][$column] = NULL;
        }
      }
      else {
        unset($items[$delta]);
      }
    }
  }
  return $items;
}

function _content_sort_items($field, $items) {
  if ($field['multiple'] >= 1 && isset($items[0]['_weight'])) {
    usort($items, '_content_sort_items_helper');
    foreach($items as $delta => $item) {
      unset($items[$delta]['_weight']);
    }
  }
  return $items;
}

/**
 * Helper function to sort items in a field according to
 * user drag-n-drop reordering.
 */
function _content_sort_items_helper($a, $b) {
  return $a["_weight"] - $b["_weight"];
}

/**
 * TODO : PHPdoc
 */
function content_storage($op, $node) {
  $type_name = $node->type;
  $type = content_types($type_name);

  switch ($op) {
    case 'load':
      // OPTIMIZE : load all non multiple fields in a single JOIN query ?
      // warning : 61-join limit in MySQL ?
      $additions = array();
      // For each table used by this content type,
      foreach ($type['tables'] as $table) {
        $schema = drupal_get_schema($table);
        $query = 'SELECT * FROM {'. $table .'} WHERE vid = %d';

        // If we're loading a table for a multiple field,
        // we fetch all rows (values) ordered by delta,
        // else we only fetch one row.
        $result = isset($schema['fields']['delta']) ? db_query($query .' ORDER BY delta', $node->vid) : db_query_range($query, $node->vid, 0, 1);

        // For each table row, populate the fields.
        while ($row = db_fetch_array($result)) {
          // For each field stored in the table, add the field item.
          foreach ($schema['content fields'] as $field_name) {
            $item = array();
            $field = content_fields($field_name, $type_name);
            $db_info = content_database_info($field);
            // For each column declared by the field, populate the item.
            foreach ($db_info['columns'] as $column => $attributes) {
              $item[$column] = $row[$attributes['column']];
            }

            // Add the item to the field values for the node.
            if (!isset($additions[$field_name])) {
              $additions[$field_name] = array();
            }
            $additions[$field_name][] = $item;
          }
        }
      }
      return $additions;

    case 'update':
    case 'insert':
      foreach ($type['tables'] as $table) {
        $schema = drupal_get_schema($table);
        $record = array();
        foreach ($schema['content fields'] as $field_name) {
          $field = content_fields($field_name, $type_name);
          $db_info = content_database_info($field);
          // Multiple fields need specific handling, we'll deal with them later on.
          if ($field['multiple']) {
            continue;
          }
          foreach ($db_info['columns'] as $column => $attributes) {
            $record[$attributes['column']] = $node->{$field_name}[0][$column];
          }
        }
        if (count($record)) {
          $record['nid'] = $node->nid;
          $record['vid'] = $node->vid;
          if ($op == 'update') {
            drupal_write_record($table, $record, array('vid'));
          }
          else {
            drupal_write_record($table, $record);
          }
        }
      }

      // Handle multiple fields.
      foreach ($type['fields'] as $field) {
        if ($field['multiple']) {
          $db_info = content_database_info($field);
          // Delete and insert, rather than update, in case a value was added.
          if ($op == 'update') {
            db_query('DELETE FROM {'. $db_info['table'] .'} WHERE vid = %d', $node->vid);
          }
          foreach ($node->$field['field_name'] as $delta => $item) {
            $record = array();
            foreach ($db_info['columns'] as $column => $attributes) {
              $record[$attributes['column']] = $item[$column];
            }
            $record['nid'] = $node->nid;
            $record['vid'] = $node->vid;
            $record['delta'] = $delta;
            drupal_write_record($db_info['table'], $record);
          }
        }
      }
      break;

    case 'delete':
      foreach ($type['tables'] as $table) {
        db_query('DELETE FROM {'. $table .'} WHERE nid = %d', $node->nid);
      }
      break;

    case 'delete revision':
      foreach ($type['tables'] as $table) {
        db_query('DELETE FROM {'. $table .'} WHERE vid = %d', $node->vid);
      }
      break;
  }
}

/**
 * Invoke a field hook.
 *
 * For each operation, both this function and _content_field_invoke_default() are
 * called so that the default database handling can occur.
 */
function _content_field_invoke($op, &$node, $teaser = NULL, $page = NULL) {
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  $field_types = _content_field_types();

  $return = array();
  if (count($type['fields'])) {
    foreach ($type['fields'] as $field) {
      $items = isset($node->$field['field_name']) ? $node->$field['field_name'] : array();

      // Make sure AHAH 'add more' button isn't sent to the fields for processing.
      if (isset($items[$field['field_name'] .'_add_more'])) {
        unset($items[$field['field_name'] .'_add_more']);
      }

      $module = $field_types[$field['type']]['module'];
      $function = $module .'_field';
      if (function_exists($function)) {
        $result = $function($op, $node, $field, $items, $teaser, $page);
        if (is_array($result)) {
          $return = array_merge($return, $result);
        }
        else if (isset($result)) {
          $return[] = $result;
        }
      }
      // test for values in $items in case modules added items on insert
      if (isset($node->$field['field_name']) || count($items)) {
        $node->$field['field_name'] = $items;
      }
    }
  }
  return $return;
}

/**
 * Invoke content.module's version of a field hook.
 */
function _content_field_invoke_default($op, &$node, $teaser = NULL, $page = NULL) {
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  $field_types = _content_field_types();

  $return = array();
  // The operations involving database queries are better off handled by table
  // rather than by field.
  if (in_array($op, array('load', 'insert', 'update', 'delete','delete revision'))) {
    return content_storage($op, $node);
  }
  elseif (count($type['fields'])) {
    foreach ($type['fields'] as $field) {
      $items = isset($node->$field['field_name']) ? $node->$field['field_name'] : array();
      if (count($field['columns'])) {
        $result = content_field($op, $node, $field, $items, $teaser, $page);
        if (is_array($result)) {
          $return = array_merge($return, $result);
        }
        else if (isset($result)) {
          $return[] = $result;
        }
      }
      if (isset($node->$field['field_name'])) {
        $node->$field['field_name'] = $items;
      }
    }
  }
  return $return;
}

/**
 * Return a list of all content types.
 *
 * @param $content_type_name
 *   If set, return information on just this type.
 */
function content_types($type_name = NULL) {
  // handle type name with either an underscore or a dash
  $type_name = !empty($type_name) ? str_replace('-', '_', $type_name) : NULL;

  $info = _content_type_info();
  if (!isset($info['content types'])) {
    return array();
  }
  if (isset($type_name)) {
    if (isset($info['content types'][$type_name])) {
      return $info['content types'][$type_name];
    }
    else {
      return NULL;
    }
  }
  return $info['content types'];
}

/**
 * Return a list of all fields.
 *
 * @param $field_name
 *   If set, return information on just this field.
 * @param $content_type_name
 *   If set, return information of the field within the context of this content
 *   type.
 */
function content_fields($field_name = NULL, $content_type_name = NULL) {
  $info = _content_type_info();
  if (!isset($info['fields'])) {
    return array();
  }
  if (isset($field_name)) {
    if (isset($info['fields'][$field_name])) {
      if (isset($content_type_name)) {
        if (isset($info['content types'][$content_type_name]['fields'][$field_name])) {
          return $info['content types'][$content_type_name]['fields'][$field_name];
        }
        else {
          return NULL;
        }
      }
      else {
        return $info['fields'][$field_name];
      }
    }
    else {
      return NULL;
    }
  }
  return $info['fields'];
}

/**
 * Return a list of field types.
 */
function _content_field_types() {
  $info = _content_type_info();
  return isset($info['field types']) ? $info['field types'] : array();
}

/**
 * Return a list of widget types.
 */
function _content_widget_types() {
  $info = _content_type_info();
  return isset($info['widget types']) ? $info['widget types'] : array();
}

/**
 * Collate all information on content types, fields, and related structures.
 *
 * @param $reset
 *   If TRUE, clear the cache and fetch the information from the database again.
 */
function _content_type_info($reset = FALSE) {
  static $info;

  // Make sure this function doesn't run until the tables have been created,
  // for instance, when first enabled and called from content_menu().
  if (!db_table_exists(content_field_tablename()) || !db_table_exists(content_instance_tablename())) {
      return array();
  }
  if ($reset || !isset($info)) {
    if ($cached = cache_get('content_type_info', content_cache_tablename())) {
      $info = $cached->data;
    }
    else {
      $info = array(
        'field types' => array(),
        'widget types' => array(),
        'fields' => array(),
        'content types' => array(),
      );

      foreach (module_list() as $module) {
        $module_field_types = module_invoke($module, 'field_info');
        if ($module_field_types) {
          foreach ($module_field_types as $name => $field_info) {
            $info['field types'][$name] = $field_info;
            $info['field types'][$name]['module'] = $module;
            $info['field types'][$name]['formatters'] = array();
          }
        }
        $module_widgets = module_invoke($module, 'widget_info');
        if ($module_widgets) {
          foreach ($module_widgets as $name => $widget_info) {
            $info['widget types'][$name] = $widget_info;
            $info['widget types'][$name]['module'] = $module;
          }
        }
        $module_formatters = module_invoke($module, 'field_formatter_info');
        if ($module_formatters) {
          foreach ($module_formatters as $name => $formatter_info) {
            foreach ($formatter_info['field types'] as $field_type) {
              $info['field types'][$field_type]['formatters'][$name] = $formatter_info;
              $info['field types'][$field_type]['formatters'][$name]['module'] = $module;
            }
          }
        }
      }
      module_load_include('inc', 'content', 'content_crud');
      foreach (node_get_types() as $type_name => $data) {
        $type = (array) $data;
        $type['url_str'] = str_replace('_', '-', $type['type']);
        $type['fields'] = array();
        $type['tables'] = array();
        $fields = content_field_instance_read(array('type_name' => $type_name));
        foreach ($fields as $field) {
          $type['fields'][$field['field_name']] = $field;
          $db_info = content_database_info($field);
          $type['tables'][$db_info['table']] = $db_info['table'];
          $info['fields'][$field['field_name']] = $field;
        }
        $info['content types'][$type_name] = $type;
      }
      cache_set('content_type_info', $info, content_cache_tablename());
    }
  }
  return $info;
}

/**
 *  Implementation of hook_node_type()
 *  React to change in node types
 */
function content_node_type($op, $info) {
  switch ($op) {
    case 'insert':
      module_load_include('inc', 'content', 'content_crud');
      content_type_create($info);
      break;
    case 'update':
      module_load_include('inc', 'content', 'content_crud');
      content_type_update($info);
      break;
    case 'delete':
      module_load_include('inc', 'content', 'content_crud');
      content_type_delete($info);
      break;
  }
}

/**
 * Clear the cache of content_types; called in several places when content
 * information is changed.
 */
function content_clear_type_cache($with_schema = FALSE) {

  cache_clear_all('content_type_info', content_cache_tablename());

  _content_type_info(TRUE);

  // Refresh the schema to pick up new information.
  if ($with_schema) {
    $schema = drupal_get_schema(NULL, TRUE);
  }

  if (module_exists('views')) {
    // Needed because this can be called from .install files
    include_once('./'. drupal_get_path('module', 'views') .'/views.module');
    views_invalidate_cache();
  }
}

/**
 * Retrieve the database storage location(s) for a field.
 *
 * TODO : add a word about why it's not included in the global _content_type_info array.
 *
 * @param $field
 *   The field whose database information is requested.
 * @return
 *   An array with the keys:
 *     "table": The name of the database table where the field data is stored.
 *     "columns": An array of columns stored for this field. Each is a collection
 *       of information returned from hook_field_settings('database columns'),
 *       with the addition of a "column" attribute which holds the name of the
 *       database column that stores the data.
 */
function content_database_info($field) {
  $columns = $field['columns'];
  $db_info = array();

  if ($field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD) {
    $db_info['table'] = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);
  }
  else {
    $db_info['table'] = _content_tablename($field['type_name'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  }

  if (is_array($columns) && count($columns)) {
    $db_info['columns'] = $columns;
    foreach ($columns as $column_name => $attributes) {
      $db_info['columns'][$column_name]['column'] = $field['field_name'] .'_'. $column_name;
    }
  }
  else {
    $db_info['columns'] = array();
  }
  return $db_info;
}

/**
 * Helper function for identifying the storage type for a field.
 */
function content_storage_type($field) {
  if ($field['multiple'] > 0) {
    return CONTENT_DB_STORAGE_PER_FIELD;
  }
  else {
    $instances = content_field_instance_read(array('field_name' => $field['field_name']));
    if (count($instances) > 1) {
      return CONTENT_DB_STORAGE_PER_FIELD;
    }
    else {
      return CONTENT_DB_STORAGE_PER_CONTENT_TYPE;
    }
  }
}

/**
 * Manipulate a 2D array to reverse rows and columns.
 *
 * The default data storage for fields is delta first, column names second.
 * This is sometimes inconvenient for field modules, so this function can be
 * used to present the data in an alternate format.
 *
 * @param $array
 *   The array to be transposed. It must be at least two-dimensional, and
 *   the subarrays must all have the same keys or behavior is undefined.
 *
 * @return
 *   The transposed array.
 */
function content_transpose_array_rows_cols($array) {
  $result = array();
  if (is_array($array)) {
    foreach ($array as $key1 => $value1) {
      if (is_array($value1)) {
        foreach ($value1 as $key2 => $value2) {
          if (!isset($result[$key2])) {
            $result[$key2] = array();
          }
          $result[$key2][$key1] = $value2;
        }
      }
    }
  }
  return $result;
}

/**
 *  Create an array of the allowed values for this field.
 *
 *  Used by number and text fields, expects to find either
 *  php code that will return the correct value, or a string
 *  with keys and labels separated with '|' and with each
 *  new value on its own line.
 */
function content_allowed_values($field) {
  static $allowed_values;

  if (isset($allowed_values[$field['field_name']])) {
    return $allowed_values[$field['field_name']];
  }

  $allowed_values[$field['field_name']] = array();

  if (isset($field['allowed_values_php'])) {
    ob_start();
    $result = eval($field['allowed_values_php']);
    if (is_array($result)) {
      $allowed_values[$field['field_name']] = $result;
    }
    ob_end_clean();
  }

  if (empty($allowed_values[$field['field_name']]) && isset($field['allowed_values'])) {
    $list = explode("\n", $field['allowed_values']);
    $list = array_map('trim', $list);
    $list = array_filter($list, 'strlen');
    foreach ($list as $opt) {
      if (strpos($opt, '|') !== FALSE) {
        list($key, $value) = explode('|', $opt);
        $allowed_values[$field['field_name']][$key] = $value ? $value : $key;
      }
      else {
        $allowed_values[$field['field_name']][$opt] = $opt;
      }
    }
  }
  return $allowed_values[$field['field_name']];
}

/**
 * Format a field item for display.
 *
 * @param $field
 *   Either a field array or the name of the field.
 * @param $item
 *   The field item to be formatted (such as $node->field_foo[0]).
 * @param $formatter
 *   The name of the formatter to use.
 * @param $node
 *   Optionally, the containing node object for context purposes.
 *
 * @return
 *   A string containing the contents of the field item sanitized for display.
 *   It will have been passed through the necessary check_plain() or check_markup()
 *   functions as necessary.
 */
function content_format($field, $item, $formatter = 'default', $node = NULL) {
  if (!is_array($field)) {
    $field = content_fields($field);
  }
  $field_types = _content_field_types();
  $formatters = $field_types[$field['type']]['formatters'];

  if (!isset($formatter, $formatters)) {
    $formatter = 'default';
  }
  return module_invoke($formatters[$formatter]['module'], 'field_formatter', $field, $item, $formatter, $node);
}

/**
 * Array of possible display contexts for fields.
 */
function _content_admin_display_contexts() {
  $contexts = array(
    'teaser' => t('Teaser'),
    'full' => t('Full'),
    NODE_BUILD_RSS => t('RSS Item'),
    NODE_BUILD_PRINT => t('Print'),
  );
  if (module_exists('search')) {
    $contexts[NODE_BUILD_SEARCH_INDEX] = t('Search Index');
    $contexts[NODE_BUILD_SEARCH_RESULT] = t('Search Result');
  }

  return $contexts;
}

/**
 * Generate a table name for a field or a content type.
 *
 * @param $name
 *   The name of the content type or content field
 * @param $storage
 *   CONTENT_DB_STORAGE_PER_FIELD or CONTENT_DB_STORAGE_PER_CONTENT_TYPE
 *
 * @return
 *   A string containing the generated name for the database table
 */
function _content_tablename($name, $storage, $version = NULL) {
  if (is_null($version)) {
    $version = variable_get('content_schema_version', 0);
  }

  if ($version < 1003) {
    $version = 0;
  }
  else {
    $version = 1003;
  }

  $name = str_replace('-', '_', $name);
  switch ("$version-$storage") {
    case '0-'. CONTENT_DB_STORAGE_PER_CONTENT_TYPE :
      return "node_$name";
    case '0-'. CONTENT_DB_STORAGE_PER_FIELD :
      return "node_data_$name";
    case '1003-'. CONTENT_DB_STORAGE_PER_CONTENT_TYPE :
      return "content_type_$name";
    case '1003-'. CONTENT_DB_STORAGE_PER_FIELD :
      return "content_$name";
  }
}

/**
 * Generate table name for the content field table.
 *
 * Needed because the table name changes depending on version.
 * Using 'content_node_field' instead of 'content_field'
 * to avoid conflicts with field tables that will be prefixed
 * with 'content_field'.
 */
function content_field_tablename($version = NULL) {
  if (is_null($version)) {
    $version = variable_get('content_schema_version', 0);
  }
  return $version < 6001 ? 'node_field' : 'content_node_field';
}

/**
 * Generate table name for the content field instance table.
 *
 * Needed because the table name changes depending on version.
 */
function content_instance_tablename($version = NULL) {
  if (is_null($version)) {
    $version = variable_get('content_schema_version', 0);
  }
  return $version < 6001 ? 'node_field_instance' : 'content_node_field_instance';
}

/**
 * Generate table name for the content cache table.
 *
 * Needed because the table name changes depending on version.
 */function content_cache_tablename() {
  if (!db_table_exists('cache_content')) {
    return 'cache';
  }
  else {
    return 'cache_content';
  }
}

/**
 * A basic schema used by all field and type tables.
 *
 * Leave $field['columns'] empty to get only the base schema,
 * otherwise the function will return the whole thing.
 */
function content_table_schema($field = NULL) {
  $schema = array(
    'fields' => array(
      'vid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'nid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0)
    ),
    'primary key' => array('vid'),
  );
  if (!empty($field['multiple'])) {
    $schema['fields']['delta'] = array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0);
    $schema['primary key'][] = 'delta';
  }
  $schema['content fields'] = array();

  // This function is called from install files where it is not safe
  // to use content_fields() or content_database_info(), so we
  // just used the column values stored in the $field.

  // We also need the schema to include fields from disabled modules
  // or there will be no way to delete those fields.
  if (!empty($field['columns'])) {
    foreach ($field['columns'] as $column => $attributes) {
      $column_name =  $field['field_name'] .'_'. $column;
      unset($attributes['column']);
      unset($attributes['sortable']);
      $schema['fields'][$column_name] = $attributes;
      $schema['content fields'][] = $field['field_name'];
    }
  }
  return $schema;
}

/**
 *  Helper function for determining the behaviour of a field or a widget
 *  with respect to a given operation. (currently used for field 'view',
 *  and widget 'default values' and 'multiple values')
 *
 *  @param $entity
 *    'field' or 'widget'
 *
 *  @param $op
 *    the name of the operation ('view', 'default value'...)
 *
 *  @param $field
 *    The field array, including widget info.

 * @return
 *    CONTENT_CALLBACK_NONE    - do nothing for this operation
 *    CONTENT_CALLBACK_CUSTOM  - use the module's callback function.
 *    CONTENT_CALLBACK_DEFAULT - use content module default behaviour
 *
 */
function content_callback($entity, $op, $field) {
  switch ($entity) {
    case 'field':
      $info = module_invoke($field['module'], "field_info");
      return $info[$field['type']]['callbacks'][$op];

    case 'widget':
      $info = module_invoke($field['widget']['module'], "widget_info");
      return $info[$field['widget']['type']]['callbacks'][$op];
  }
}

/**
 *  Helper function for determining the handling of a field or a widget
 *  with respect to a given operation. (currently used for widget 'multiple values')
 *
 *  @param $entity
 *    'field' or 'widget'
 *
 *  @param $op
 *    the name of the operation ('default values'...)
 *
 *  @param $field
 *    The field array, including widget info.

 * @return
 *    CONTENT_HANDLE_CORE    - the content module handles this operation.
 *    CONTENT_HANDLE_MODULE  - the module handles this operation.
 */
function content_handle($entity, $op, $field) {
  switch ($entity) {
    case 'field':
      $info = module_invoke($field['module'], "field_info");
      return $info[$field['type']][$op];

    case 'widget':
      $info = module_invoke($field['widget']['module'], "widget_info");
      return $info[$field['widget']['type']][$op];
  }
}

/**
 *  Helper function to return the correct default value for a field.
 *
 *  @param $node
 *    The node.
 *
 *  @param $field
 *    The field array.
 *
 *  @param $items
 *    The value of the field in the node.
 *
 *  @return
 *    The default value for that field.
 */
function content_default_value(&$form, &$form_state, $field, $delta) {
  $widget_types = _content_widget_types();
  $module = $widget_types[$field['widget']['type']]['module'];

  $default_value = array();
  if (!empty($field['widget']['default_value_php'])) {
    ob_start();
    $result = eval($field['widget']['default_value_php']);
    ob_end_clean();
    if (is_array($result)) {
      $default_value = $result;
    }
  }
  elseif (!empty($field['widget']['default_value'])) {
    $default_value = $field['widget']['default_value'];
  }
  return (array) $default_value;
}

/**
 * Hook elements().
 *
 * Used to add multiple value processing, validation, and themes.
 *
 * FAPI callbacks can be declared here, and the element will be
 * passed to those callbacks.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 */
function content_elements() {
  return array(
    'content_multiple_values' => array(
      // TODO : right now this element is similar to a fieldset,
      // #input could be FALSE...
      // Do we need an 'element' at all, for that matter ?
      '#input' => TRUE,
    )
  );
}

/**
 * Theme an individual form element.
 *
 * Combine multiple values into a table with drag-n-drop reordering.
 */
function theme_content_multiple_values($element) {
  $field_name = $element['#field_name'];
  $field = content_fields($field_name);
  $output = '';

  if ($field['multiple'] >= 1) {
    $table_id = $element['#field_name'] .'_values';
    $order_class = $element['#field_name'] .'-delta-order';
    $header = array(
      // TODO : field label should be in first header with a colspan of 2,
      // but this breaks tabledrag.js column hiding...
      '',
      $element['#title'],
      t('Order')
    );
    $rows = array();

    foreach (element_children($element) as $key) {
      if ($key !== $element['#field_name'] .'_add_more') {
        $element[$key]['_weight']['#attributes']['class'] = $order_class;
        $delta_element = drupal_render($element[$key]['_weight']);
        $cells = array(
          array('data' => '', 'class' => 'content-multiple-drag'),
          drupal_render($element[$key]),
          array('data' => $delta_element, 'class' => 'delta-order'),
        );
        $rows[] = array(
          'data' => $cells,
          'class' => 'draggable',
        );
      }
    }

    $output .= theme('table', $header, $rows, array('id' => $table_id, 'class' => 'content-multiple-table'));
    $output .= drupal_render($element[$element['#field_name'] .'_add_more']);

    drupal_add_tabledrag($table_id, 'order', 'sibling', $order_class);

    // Change the button title to reflect the behavior when using JavaScript.
    $field_name_css = str_replace('_', '-', $field_name);
    drupal_add_js('if (Drupal.jsEnabled) { $(document).ready(function() { $("#edit-'. $field_name_css .'-'. $field_name_css .'-add-more").val("'. t('Add another item') .'"); }); }', 'inline');
  }
  else {
    foreach (element_children($element) as $key) {
      $output .= drupal_render($element[$key]);
    }
  }

  return $output;
}

/**
 * Process variables for field.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $node
 * - $field
 * - $items
 * - $teaser
 * - $page
 *
 * @see field.tpl.php
 */
function template_preprocess_field(&$variables) {
  $field = $variables['field'];
  $field_empty = TRUE;
  foreach ($variables['items'] as $delta => $item) {
    if (empty($item['view']) && $item['view'] !== 0) {
      $variables['items'][$delta]['empty'] = TRUE;
    }
    else {
      $field_empty = FALSE;
      $variables['items'][$delta]['empty'] = FALSE;
    }
  }
  $additions = array(
    'field_type' => $field['type'],
    'field_name' => $field['field_name'],
    'field_type_css' => strtr($field['type'], '_', '-'),
    'field_name_css' => strtr($field['field_name'], '_', '-'),
    'label' => $field['widget']['label'],
    'label_display' => isset($field['display_settings']['label']['format']) ? $field['display_settings']['label']['format'] : 'above',
    'field_empty' => $field_empty,
  );
  $variables = array_merge($variables, $additions);
}

/**
 * Debugging using hook_content_fieldapi.
 *
 * @TODO remove later
 *
 * @param unknown_type $op
 * @param unknown_type $field
 */
function content_content_fieldapi($op, $field) {
  if (module_exists('devel')) {
    //dsm($op);
    //dsm($field);
  }
}