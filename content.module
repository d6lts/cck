<?php
// $Id$

/**
 * @file
 * Allows administrators to associate custom fields to content types.
 */

define('CONTENT_DB_STORAGE_PER_FIELD', 0);
define('CONTENT_DB_STORAGE_PER_CONTENT_TYPE', 1);

define('CONTENT_CALLBACK_NONE', 0x0001);
define('CONTENT_CALLBACK_DEFAULT', 0x0002);
define('CONTENT_CALLBACK_CUSTOM', 0x0004);

define('CONTENT_HANDLE_CORE', 0x0001);
define('CONTENT_HANDLE_MODULE', 0x0002);

function content_help($path, $arg) {
  if (preg_match('!^admin/content/types/.*/display$!', $path)) {
    return t("Configure how this content type's fields and field labels should be displayed when it's viewed in teaser and full-page mode.");
  }
}

/**
 * Implementation of hook_devel_caches().
 * Include {cache_content} in the list of tables cleared by devel's 'empty cache'
 */
function content_devel_caches() {
  return array('cache_content');
}

/**
 * Implementation of hook_init().
 */
function content_init() {
  drupal_add_css(drupal_get_path('module', 'content') .'/content.css');
  if (module_exists('views')) {
    module_load_include('inc', 'content', 'content_views');
  }
  if (module_exists('pathauto')) {
    module_load_include('inc', 'content', 'content_pathauto');
  }
}

/**
 * Implementation of hook_menu().
 */
function content_menu() {
  $items = array();
  $items['admin/content/types/fields'] = array(
    'title' => 'Fields',
    'page callback' => '_content_admin_type_fields',
    'access arguments' => array('administer content types'),
    'file' => 'content_admin.inc',
    'file path' => drupal_get_path('module', 'content'),
    'type' => MENU_LOCAL_TASK,
  );

  foreach (node_get_types() as $type) {
    $type_name = $type->type;
    $content_type = content_types($type_name);
    $type_url_str = $content_type['url_str'];

    $items['admin/content/types/'. $type_url_str .'/fields'] = array(
      'title' => 'Manage fields',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('content_admin_field_overview_form', $type_name),
      'access arguments' => array('administer content types'),
      'file' => 'content_admin.inc',
      'file path' => drupal_get_path('module', 'content'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 0,
    );
    $items['admin/content/types/'. $type_url_str .'/display'] = array(
      'title' => 'Display fields',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('content_admin_display_overview_form', $type_name),
      'access arguments' => array('administer content types'),
      'file' => 'content_admin.inc',
      'file path' => drupal_get_path('module', 'content'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 1,
    );
    $items['admin/content/types/'. $type_url_str .'/add_field'] = array(
      'title' => 'Add field',
      'page callback' => '_content_admin_field_add',
      'page arguments' => array($type_name),
      'access arguments' => array('administer content types'),
      'file' => 'content_admin.inc',
      'file path' => drupal_get_path('module', 'content'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 2,
    );
    foreach ($content_type['fields'] as $field) {
      $field_name = $field['field_name'];

      // Callbacks for AHAH add more buttons.
      if ($field['multiple']) {
        $items['content/js/'. $field_name] = array(
          'title' => 'Javascript Add More Form',
          'page callback' => 'content_add_more_js',
          'page arguments' => array($field_name),
          'access arguments' => array('access content'),
          'type' => MENU_CALLBACK,
        );
      }

      // TODO how should this be handled? If type is MENU_CALLBACK, the
      // breadcrumbs and tabs disappear on this page. If type is MENU_LOCAL_TASK,
      // the breadcrumbs and main tabs are right, but we also get secondary
      // row of tabs for each field. Not losing the top tabs is probably the
      // best option, even with the extra tabs.
      $items['admin/content/types/'. $type_url_str .'/fields/'. $field_name] = array(
        'title' => t($field['widget']['label']),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('_content_admin_field', $type_name, $field_name),
        'access arguments' => array('administer content types'),
        'file' => 'content_admin.inc',
        'file path' => drupal_get_path('module', 'content'),
        'type' => MENU_LOCAL_TASK,
      );
      $items['admin/content/types/'. $type_url_str .'/fields/'. $field_name .'/remove'] = array(
        'title' => 'Remove field',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('_content_admin_field_remove', $type_name, $field_name),
        'access arguments' => array('administer content types'),
        'file' => 'content_admin.inc',
        'file path' => drupal_get_path('module', 'content'),
        'type' => MENU_CALLBACK,
      );
    }
  }
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function content_theme() {
  return array(
    'field' => array(
      'template' => 'field',
      'arguments' => array('node' => NULL, 'field' => NULL, 'items' => NULL, 'teaser' => FALSE, 'page' => FALSE),
    ),
    'content_admin_field_overview_form' => array(
      'arguments' => array('form' => NULL),
    ),
    'content_admin_display_overview_form' => array(
      'arguments' => array('form' => NULL),
    ),
    'content_admin_field_add_new_field_widget_type' => array(
      'arguments' => array('form' => NULL),
    ),
    'content_view_multiple_field' => array(
      'arguments' => array('items' => NULL, 'field' => NULL, 'data' => NULL),
    ),
    'content_multiple_values' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Load data for a node type's fields.
 *
 * When loading one of the content.module nodes, we need to let each field handle
 * its own loading. This can make for a number of queries in some cases, so we
 * cache the loaded object structure and invalidate it during the update process.
 */
function content_load($node) {
  $cid = 'content:'. $node->nid .':'. $node->vid;
  if ($cached = cache_get($cid, 'cache_content')) {
    return $cached->data;
  }
  else {
    $default_additions = _content_field_invoke_default('load', $node);
    if ($default_additions) {
      foreach ($default_additions as $key => $value) {
        $node->$key = $value;
      }
    }
    $additions = _content_field_invoke('load', $node);
    if ($additions) {
      foreach ($additions as $key => $value) {
        $node->$key = $value;
        $default_additions[$key] = $value;
      }
    }
    cache_set($cid, $default_additions, 'cache_content');
    return $default_additions;
  }
}

/**
 * Create fields' form for a content type.
 *
 * Widget_invoke() is gone, this is the only place the widget function
 * is called.
 *
 * Each field defines its own component of the content entry form, via its
 * chosen widget.
 */
function content_form(&$form, &$form_state) {
  $node = $form['#node'];
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  if (count($type['fields'])) {
    foreach ($type['fields'] as $field) {
      $form['#field_info'][$field['field_name']] = $field;
      $form += content_form_field($form, $form_state, $field);
    }
  }
  return $form;
}

/**
 * Create a separate form element for each field.
 *
 * Extracted from content_form() to make it possible to get a subform
 * for just a single field at a time.
 *
 * Hook_widget() picks up two new values, $count and $delta, to help
 * widgets know what information to return since multiple values are
 * sometimes controlled by the content module.
 *
 * @param $form
 *   the form to add this field element to
 * @param $form_state
 *   the form_state for the above form
 * @param $field
 *   the field array to use to create the form element
 * @param $get_delta
 *   use to get only a specific delta value of a multiple value field, otherwise
 *   function will return the entire $field form element.
 */
function content_form_field(&$form, &$form_state, $field, $get_delta = NULL) {
  $node = $form['#node'];
  $addition = array();
  $function = $field['module'] .'_widget';
  if (function_exists($function)) {
    // Prepare the values to be filled in the widget.
    // We look in the following places :
    // - Form submitted values
    // - Node values (when editing an existing node), or pre-filled values (when
    //   creating a new node translation)
    // - Default values set for the field (when creating a new node).
    $items = array();
    if (!empty($form_state['values'][$field['field_name']])) {
      $items = $form_state['values'][$field['field_name']];
    }
    elseif (!empty($node->$field['field_name'])) {
      $items = $node->$field['field_name'];
    }
    elseif (empty($node->nid)) {
      if (content_callback('widget', 'default value', $field) != CONTENT_CALLBACK_NONE) {
        $callback = content_callback('widget', 'default value', $field) == CONTENT_CALLBACK_CUSTOM ? $module .'_default_value' : 'content_default_value';
        if (function_exists($callback)) {
          $items = $callback($form, $form_state, $field, 0);
        }
      }
    }

    // If content module handles multiple values for this form element,
    // process the multiple value form.
    if (content_handle('widget', 'multiple values', $field) == CONTENT_HANDLE_CORE) {
       $form_element = content_multiple_value_form($form, $form_state, $field, $items, $get_delta);
    }
    // If the widget is handling multiple values (e.g optionwidgets),
    // just get the field's form element and make it the zero value.
    else {
      if ($element = $function($form, $form_state, $field, $items)) {
        $defaults = array(
          '#field_name' => $field['field_name'],
          '#required' => $field['required'],
          // TODO : should we add some logic for title and description too ?
          '#columns'  => $field['columns'],
        );
        $form_element[0] = array_merge($element, $defaults);
      }
    }

    // Field name is needed at top level as well as the individual elements
    // so the multiple values or other field level theme or processing can find it.
    if ($form_element) {
      $defaults = array(
        '#field_name' => $field['field_name'],
        '#tree' => TRUE,
        '#weight' => $field['widget']['weight'],
        '#count' => sizeof($form_element),
      );
      $addition[$field['field_name']] = array_merge($form_element, $defaults);

    }
  }
  return $addition;
}


function content_multiple_value_form(&$form, &$form_state, $field, $items, $get_delta = NULL) {

  $function = $field['module'] .'_widget';
  $field_name = $field['field_name'];
  $field_name_css = str_replace('_', '-', $field_name);

  $form_element = array();
  $count =  isset($form_state['item_count'][$field_name]) ? $form_state['item_count'][$field_name] : sizeof($items);

  $max = !empty($field['multiple']) ? $count + 2 : 0;
  $min = 0;
  if (isset($get_delta)) {
    $max = $min = $get_delta;
  }
  for ($delta = $min; $delta <= $max; $delta++) {
    if ($element = $function($form, $form_state, $field, $items, $delta)) {
      $defaults = array(
        '#field_name' => $field_name,
        '#weight'   => $delta,
        '#required' => $delta == 0 && $field['required'],
        '#delta'    => $delta,
        '#columns'  => $field['columns'],
      );
      $form_element[$delta] = array_merge($element, $defaults);
    }
  }

  // Add AHAH add more button to all multiple values for now.
  // Don't do this when working with a programmed form or if only a
  // single delta value has been requested.

  // TODO once this is working, come back and add options on the settings
  // page to either add an infinite number of items using ahah or
  // set a specific number of multiples, then check that before
  // adding the AHAH wrapper so there is a non-AHAH alternative.
  if ($field['multiple'] && empty($form['#programmed']) && !$get_delta) {
    // Make sure the form is cached so ahah can work.
    $form['#cache'] = TRUE;

    // Add a wrapper for the fields and more button.
    $form_element['#prefix'] = '<div class="clear-block" id="'. $field_name_css .'-add-more-wrapper">';
    // Container for just the field items.
    $form_element['#prefix'] .= '<div id="'. $field_name_css .'-items">';
    $form_element['#suffix'] = '</div></div>';

    // We name our button $field_name .'_add_more' to avoid conflicts with
    // other fields and other modules using AHAH-enabled buttons with the id 'more'.
    // Use a prefix to close out the container for field items and start the button container.
    $form_element[$field_name .'_add_more'] = array(
      '#prefix' => '</div><div>',
      '#suffix' => '</div>',
      '#type' => 'submit',
      '#value' => t('Add another !field field', array('!field' => t($field['widget']['label']))),
      '#description' => t("If the amount of boxes above isn't enough, click here to add more items."),
      '#weight' => $field['widget']['weight'] + $max + 1,
      '#submit' => array('content_add_more_submit'), // If no javascript action.
      '#ahah' => array(
        'path' => 'content/js/'. $field_name,
        'wrapper' => $field_name_css .'-items',
        'method' => 'replace',
        'effect' => 'fade',
      ),
    );
  }
  else {
    $form_element['#type'] = 'content_multiple_values';
  }
  return $form_element;
}

/**
 * Submit handler to add more choices to a content form. This handler is used when
 * javascript is not available. It makes changes to the form state and the
 * entire form is rebuilt during the page reload.
 */
function content_add_more_submit($form, &$form_state) {
  // Set the form to rebuild and run submit handlers.
  node_form_submit_build_node($form, $form_state);

  foreach ($form['#field_info'] as $field_name => $field) {
    // Make the changes we want to the form state.
    if ($form_state['values'][$field_name][$field_name .'_add_more']) {
      $form_state['item_count'][$field_name] = count($form[$field_name]['#count']) + 1;
    }
  }
}

/**
 * Menu callback for AHAH additions.
 */
function content_add_more_js($field_name) {
  // Add the new element to the stored form state. Without adding the element
  // to the form, Drupal is not aware of this new elements existence and will
  // not process it. We retreive the cached form, add the element, and resave.
  $delta = max(array_keys($_POST[$field_name])) + 1;
  $cache = cache_get('form_'. $_POST['form_build_id'], 'cache_form');
  $form = $cache->data;

  // Build our new form element.
  $field = $form['#field_info'][$field_name];
  $form_state = array('values' => $_POST);
  $form_element = content_form_field($form, $form_state, $field, $delta);

  drupal_alter('form', $form_element, array(), 'content_add_more_js');
  $form[$field_name][$delta] = $form_element;
  cache_set('form_'. $_POST['form_build_id'], $form, 'cache_form', $cache->expire);

  // Build the new form.
  $form_state = array('submitted' => FALSE);
  $form_state['item_count'][$field_name] = $delta;
  $form += array(
    '#post' => $_POST,
    '#programmed' => FALSE,
  );
  $form = form_builder($_POST['form_id'], $form, $form_state);

  // Render the new output.
  $output = '';
  $choice_form = $form[$field_name];
  unset($choice_form['#prefix'], $choice_form['#suffix'], $choice_form[$field_name .'_add_more']); // Prevent duplicate wrappers.
  $choice_form[$form[$field_name]['#count']]['#attributes']['class'] = empty($choice_form[$delta]['#attributes']['class']) ? 'ahah-new-content' : $choice_form[$delta]['#attributes']['class'] .' ahah-new-content';
  $output = theme('status_messages') . drupal_render($choice_form);

  drupal_json(array('status' => TRUE, 'data' => $output));
}

/**
 * Nodeapi 'validate' op.
 *
 */
function content_validate(&$node) {
  _content_field_invoke('validate', $node);
  _content_field_invoke_default('validate', $node);
}

/**
 * Nodeapi 'presave' op.
 *
 */
function content_presave(&$node) {
  _content_field_invoke('presave', $node);
  _content_field_invoke_default('presave', $node);
}

/**
 * Nodeapi 'insert' op.
 *
 * Insert node type fields.
 */
function content_insert(&$node) {
  _content_field_invoke('insert', $node);
  _content_field_invoke_default('insert', $node);
}

/**
 * Nodeapi 'update' op.
 *
 * Update node type fields.
 */
function content_update(&$node) {
  _content_field_invoke('update', $node);
  _content_field_invoke_default('update', $node);
  cache_clear_all('content:'. $node->nid .':'. $node->vid, 'cache_content');
}

/**
 * Nodeapi 'delete' op.
 *
 * Delete node type fields.
 */
function content_delete(&$node) {
  $type = content_types($node->type);
  if (!empty($type['fields'])) {
    _content_field_invoke('delete', $node);
    _content_field_invoke_default('delete', $node);
  }
  $table = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  if (db_table_exists($table)) {
    db_query('DELETE FROM {'. $table .'} WHERE nid = %d', $node->nid);
  }
  cache_clear_all('content:'. $node->nid, 'cache_content', TRUE);
}

/**
 * Nodeapi 'delete_revision' op.
 *
 * Delete node type fields for a revision.
 */
function content_delete_revision(&$node) {
  $type = content_types($node->type);
  if (!empty($type['fields'])) {
    _content_field_invoke('delete revision', $node);
    _content_field_invoke_default('delete revision', $node);
  }
  $table = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  if (db_table_exists($table)) {
    db_query('DELETE FROM {'. $table .'} WHERE vid = %d', $node->vid);
  }
  cache_clear_all('content:'. $node->nid .':'. $node->vid, 'cache_content');
}

/**
 * Nodeapi 'view' op.
 *
 * Generate field render arrays.
 */
function content_view(&$node, $teaser = FALSE, $page = FALSE) {
  $additions = _content_field_invoke_default('view', $node);
  $node->content = array_merge((array) $node->content, $additions);
}

/**
 * Nodeapi 'prepare translation' op.
 *
 * Generate field render arrays.
 */
function content_prepare_translation(&$node) {
  $default_additions = _content_field_invoke_default('prepare translation', $node);
  $node = (object) array_merge((array) $node, $default_additions);
}

/**
 * Implementation of hook_nodeapi().
 */
function content_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'load':
      return content_load($node);

    case 'validate':
      content_validate($node);
      break;

    case 'presave':
      content_presave($node);
      break;

    case 'insert':
      content_insert($node);
      break;

    case 'update':
      content_update($node);
      break;

    case 'delete':
      content_delete($node);
      break;

    case 'delete revision':
      content_delete_revision($node);
      break;

    case 'view':
      content_view($node, $teaser, $page);
      break;

    case 'prepare translation':
      content_prepare_translation($node);
      break;

  }
}

/**
 *  Implementation of hook_form_alter().
 */
function content_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type'])) {
    if ($form['type']['#value'] .'_node_form' == $form_id) {
      $form = array_merge($form, content_form($form, $form_state));
    }
  }
}

/**
 * Modules notify Content module when uninstalled, disabled, etc.
 *
 * @param string $op
 *   the module operation: uninstall, install, enable, disable
 * @param string $module
 *   the name of the affected module.
 * @TODO
 *   figure out exactly what needs to be done by content module when
 *   field modules are installed, uninstalled, enabled or disabled.
 */
function content_notify($op, $module) {
  // PLACEHOLDER
  switch ($op) {
    case 'install':
      break;
    case 'uninstall':
      break;
    case 'enable':
      break;
    case 'disable':
      break;
  }
}

/**
 *  Make sure that CCK content type info is synched with node type data
 *  any time the content module is enabled.
 */
function content_enable() {
  module_load_include('inc', 'content', 'content_admin');
  module_load_include('inc', 'content', 'content_crud');
  content_types_rebuild();
}

/**
 * Implementation of hook_field(). Handles common field housekeeping.
 *
 * This implementation is special, as content.module does not define any field
 * types. Instead, this function gets called after the type-specific hook, and
 * takes care of default stuff common to all field types.
 */
function content_field($op, &$node, $field, &$items, $teaser, $page) {
  switch ($op) {
    case 'validate':
      // TODO : here we could validate that the number of multiple data is correct ?
      break;

    case 'presave':
      // If there was an AHAH add more button in this field, don't save it.
      unset($items[$field['field_name']. '_add_more']);

      // Don't save empty items.
      // If the first item is empty, keep a NULL value for each of its columns
      // so there is a marker in the database, otherwise unset the item.
      $field_types = _content_field_types();
      $module = $field_types[$field['type']]['module'];
      $is_empty = $module .'_content_is_empty';
      foreach ((array) $items as $delta => $item) {
        if ($is_empty($item, $field)) {
          if ($delta == 0) {
            foreach (array_keys($field['columns']) as $column) {
              $items[$delta][$column] = NULL;
            }
          }
          else {
            unset($items[$delta]);
          }
        }
      }
      break;

    case 'view':
      if ($node->build_mode == NODE_BUILD_NORMAL) {
        $context = $teaser ? 'teaser' : 'full';
      }
      else {
        $context = $node->build_mode;
      }

      $formatter = isset($field['display_settings'][$context]['format']) ? $field['display_settings'][$context]['format'] : 'default';
      $value = '';

      if ($formatter != 'hidden') {
        foreach ($items as $delta => $item) {
          $items[$delta]['view'] = content_format($field, $item, $formatter, $node);
        }
        // Do not include field labels when indexing content.
        if ($context == NODE_BUILD_SEARCH_INDEX) {
          $field['display_settings']['label']['format'] = 'hidden';
        }
        $value = theme('field', $node, $field, $items, $teaser, $page);
      }
      $addition[$field['field_name']] = array(
        '#weight' => $field['widget']['weight'],
        '#value' => $value,
        '#access' => $formatter != 'hidden',
      );
      return $addition;

    case 'prepare translation':
      $addition = array();
      if (isset($node->translation_source->$field['field_name'])) {
        $addition[$field['field_name']] = $node->translation_source->$field['field_name'];
      }
      return $addition;
  }
}

/**
 * TODO : PHPdoc
 */
function content_storage($op, $node) {
  $type_name = $node->type;
  $type = content_types($type_name);

  switch ($op) {
    case 'load':
      // OPTIMIZE : load all non multiple fields in a single JOIN query ?
      // warning : 61-join limit in MySQL ?
      $additions = array();
      // For each table used by this content type,
      foreach ($type['tables'] as $table) {
        $schema = drupal_get_schema($table);
        $query = 'SELECT * FROM {'. $table .'} WHERE vid = %d';

        // If we're loading a table for a multiple field,
        // we fetch all rows (values) ordered by delta,
        // else we only fetch one row.
        $result = isset($schema['fields']['delta']) ? db_query($query .' ORDER BY delta', $node->vid) : db_query_range($query, $node->vid, 0, 1);

        // For each table row, populate the fields.
        while ($row = db_fetch_array($result)) {
          // For each field stored in the table, add the field item.
          foreach ($schema['content fields'] as $field_name) {
            $item = array();
            $field = content_fields($field_name, $type_name);
            $db_info = content_database_info($field);
            // For each column declared by the field, populate the item.
            foreach ($db_info['columns'] as $column => $attributes) {
              $item[$column] = $row[$attributes['column']];
            }

            // Add the item to the field values for the node.
            if (!isset($additions[$field_name])) {
              $additions[$field_name] = array();
            }
            $additions[$field_name][] = $item;
          }
        }
      }
      return $additions;

    case 'update':
    case 'insert':
      foreach ($type['tables'] as $table) {
        $schema = drupal_get_schema($table);
        $record = array();
        foreach ($schema['content fields'] as $field_name) {
          $field = content_fields($field_name, $type_name);
          $db_info = content_database_info($field);

          // Multiple fields need specific handling, we'll deal with them later on.
          if ($field['multiple']) {
            continue;
          }

          foreach ($db_info['columns'] as $column => $attributes) {
            $record[$attributes['column']] = $node->{$field_name}[0][$column];
          }
        }

        if (count($record)) {
          $record['nid'] = $node->nid;
          $record['vid'] = $node->vid;
          drupal_write_record($table, $record, $op == 'update' ? 'vid' : FALSE);
        }
      }

      // Handle multiple fields.
      foreach ($type['fields'] as $field) {
        if ($field['multiple']) {
          $db_info = content_database_info($field);
          // Delete and insert, rather than update, in case a value was added.
          if ($op == 'update') {
            db_query('DELETE FROM {'. $db_info['table'] .'} WHERE vid = %d', $node->vid);
          }
          foreach ($node->$field['field_name'] as $delta => $item) {
            $record = array();
            foreach ($db_info['columns'] as $column => $attributes) {
              $record[$attributes['column']] = $item[$column];
            }
            $record['nid'] = $node->nid;
            $record['vid'] = $node->vid;
            $record['delta'] = $delta;
            drupal_write_record($db_info['table'], $record);
          }
        }
      }
      break;

    case 'delete':
      foreach ($type['tables'] as $table) {
        db_query('DELETE FROM {'. $table .'} WHERE nid = %d', $node->nid);
      }
      break;

    case 'delete revision':
      foreach ($type['tables'] as $table) {
        db_query('DELETE FROM {'. $table .'} WHERE vid = %d', $node->vid);
      }
      break;
  }
}

/**
 * Invoke a field hook.
 *
 * For each operation, both this function and _content_field_invoke_default() are
 * called so that the default database handling can occur.
 */
function _content_field_invoke($op, &$node, $teaser = NULL, $page = NULL) {
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  $field_types = _content_field_types();

  $return = array();
  if (count($type['fields'])) {
    foreach ($type['fields'] as $field) {
      $items = isset($node->$field['field_name']) ? $node->$field['field_name'] : array();

      $module = $field_types[$field['type']]['module'];
      $function = $module .'_field';
      if (function_exists($function)) {
        $result = $function($op, $node, $field, $items, $teaser, $page);
        if (is_array($result)) {
          $return = array_merge($return, $result);
        }
        else if (isset($result)) {
          $return[] = $result;
        }
      }
      // test for values in $items in case modules added items on insert
      if (isset($node->$field['field_name']) || count($items)) {
        $node->$field['field_name'] = $items;
      }
    }
  }
  return $return;
}

/**
 * Invoke content.module's version of a field hook.
 */
function _content_field_invoke_default($op, &$node, $teaser = NULL, $page = NULL) {
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  $field_types = _content_field_types();

  $return = array();
  // The operations involving database queries are better off handled by table
  // rather than by field.
  if (in_array($op, array('load', 'insert', 'update', 'delete','delete revision'))) {
    return content_storage($op, $node);
  }
  elseif (count($type['fields'])) {
    foreach ($type['fields'] as $field) {
      $items = isset($node->$field['field_name']) ? $node->$field['field_name'] : array();
      if (count($field['columns'])) {
        $result = content_field($op, $node, $field, $items, $teaser, $page);
        if (is_array($result)) {
          $return = array_merge($return, $result);
        }
        else if (isset($result)) {
          $return[] = $result;
        }
      }
      if (isset($node->$field['field_name'])) {
        $node->$field['field_name'] = $items;
      }
    }
  }

  return $return;
}


/**
 * Return a list of all content types.
 *
 * @param $content_type_name
 *   If set, return information on just this type.
 */
function content_types($type_name = NULL) {
  // handle type name with either an underscore or a dash
  $type_name = !empty($type_name) ? str_replace('-', '_', $type_name) : NULL;

  $info = _content_type_info();
  if (isset($type_name)) {
    if (isset($info['content types'][$type_name])) {
      return $info['content types'][$type_name];
    }
    else {
      return NULL;
    }
  }
  return $info['content types'];
}

/**
 * Return a list of all fields.
 *
 * @param $field_name
 *   If set, return information on just this field.
 * @param $content_type_name
 *   If set, return information of the field within the context of this content
 *   type.
 */
function content_fields($field_name = NULL, $content_type_name = NULL) {
  $info = _content_type_info();
  if (isset($field_name)) {
    if (isset($info['fields'][$field_name])) {
      if (isset($content_type_name)) {
        if (isset($info['content types'][$content_type_name]['fields'][$field_name])) {
          return $info['content types'][$content_type_name]['fields'][$field_name];
        }
        else {
          return NULL;
        }
      }
      else {
        return $info['fields'][$field_name];
      }
    }
    else {
      return NULL;
    }
  }
  return $info['fields'];
}

/**
 * Return a list of field types.
 */
function _content_field_types() {
  $info = _content_type_info();
  return $info['field types'];
}

/**
 * Return a list of widget types.
 */
function _content_widget_types() {
  $info = _content_type_info();
  return $info['widget types'];
}

/**
 * Collate all information on content types, fields, and related structures.
 *
 * @param $reset
 *   If TRUE, clear the cache and fetch the information from the database again.
 */
function _content_type_info($reset = FALSE) {
  static $info;
  if ($reset || !isset($info)) {
    if ($cached = cache_get('content_type_info', 'cache_content')) {
      $info = $cached->data;
    }
    else {
      $info = array(
        'field types' => array(),
        'widget types' => array(),
        'fields' => array(),
        'content types' => array(),
      );

      foreach (module_list() as $module) {
        $module_field_types = module_invoke($module, 'field_info');
        if ($module_field_types) {
          foreach ($module_field_types as $name => $field_info) {
            $info['field types'][$name] = $field_info;
            $info['field types'][$name]['module'] = $module;
            $info['field types'][$name]['formatters'] = array();
          }
        }

        $module_widgets = module_invoke($module, 'widget_info');
        if ($module_widgets) {
          foreach ($module_widgets as $name => $widget_info) {
            $info['widget types'][$name] = $widget_info;
            $info['widget types'][$name]['module'] = $module;
          }
        }
      }
      foreach (module_list() as $module) {
        $module_formatters = module_invoke($module, 'field_formatter_info');
        if ($module_formatters) {
          foreach ($module_formatters as $name => $formatter_info) {
            foreach ($formatter_info['field types'] as $field_type) {
              $info['field types'][$field_type]['formatters'][$name] = $formatter_info;
              $info['field types'][$field_type]['formatters'][$name]['module'] = $module;
            }
          }
        }
      }
      $field_result = db_query('SELECT * FROM {node_field}');
      while ($field = db_fetch_array($field_result)) {
        $global_settings = $field['global_settings'] ? unserialize($field['global_settings']) : array();
        unset($field['global_settings']);
        // Preventative error handling for PHP5 if field nodule hasn't created an arrray.
        if (is_array($global_settings)) {
          $field = array_merge($field, $global_settings);
        }
        $instance_info = db_fetch_array(db_query("SELECT type_name, label FROM {node_field_instance} WHERE field_name = '%s'", $field['field_name']));
        $field['widget']['label'] = $instance_info['label'];
        $field['type_name'] = $instance_info['type_name'];
        $field['module'] = $info['field types'][$field['type']]['module'];
        $field['columns'] = array_keys(content_invoke_columns($field));
        $info['fields'][$field['field_name']] = $field;
      }
      $type_result = db_query('SELECT * FROM {node_type} ORDER BY type ASC');
      while ($type = db_fetch_array($type_result)) {
        $type['url_str'] = str_replace('_', '-', $type['type']);
        $type['fields'] = array();
        $type['tables'] = array();
        $field_result = db_query("SELECT * FROM {node_field_instance} nfi WHERE nfi.type_name = '%s' ORDER BY nfi.weight ASC, nfi.label ASC", $type['type']);
        while ($field = db_fetch_array($field_result)) {
          // Overwrite global field information with specific information
          $field = array_merge($info['fields'][$field['field_name']], $field);
          $widget_settings = $field['widget_settings'] ? unserialize($field['widget_settings']) : array();
          unset($field['widget_settings']);
          $field['widget'] = $widget_settings;
          $field['widget']['type'] = $field['widget_type'];
          unset($field['widget_type']);
          $field['widget']['weight'] = $field['weight'];
          unset($field['weight']);
          $field['widget']['label'] = $field['label'];
          unset($field['label']);
          $field['widget']['description'] = $field['description'];
          unset($field['description']);
          $field['type_name'] = $type['type'];
          $field['display_settings'] = $field['display_settings'] ? unserialize($field['display_settings']) : array();
          $type['fields'][$field['field_name']] = $field;
          $type['fields'][$field['field_name']]['module'] = $info['field types'][$field['type']]['module'];

          $db_info = content_database_info($field);
          $type['tables'][$db_info['table']] = $db_info['table'];

        }
        $info['content types'][$type['type']] = $type;
      }
      cache_set('content_type_info', $info, 'cache_content');
    }
  }
  return $info;
}

/**
 *  Implementation of hook_node_type()
 *  React to change in node types
 */
function content_node_type($op, $info) {
  switch ($op) {
    case 'insert':
      module_load_include('inc', 'content', 'content_crud');
      content_type_create($info);
      break;
    case 'update':
      module_load_include('inc', 'content', 'content_crud');
      content_type_update($info);
      break;
    case 'delete':
      module_load_include('inc', 'content', 'content_crud');
      content_type_delete($info);
      break;
  }
}

/**
 * Clear the cache of content_types; called in several places when content
 * information is changed.
 */
function content_clear_type_cache($with_schema = FALSE) {

  cache_clear_all('content_type_info', 'cache_content');

  _content_type_info(TRUE);

  // Refresh the schema to pick up new information.
  if ($with_schema) {
    $schema = drupal_get_schema(NULL, TRUE);
  }

  if (module_exists('views')) {
    views_invalidate_cache();
  }
}

/**
 * Retrieve the database storage location(s) for a field.
 *
 * TODO : add a word about why it's not included in the global _content_type_info array.
 *
 * @param $field
 *   The field whose database information is requested.
 * @return
 *   An array with the keys:
 *     "table": The name of the database table where the field data is stored.
 *     "columns": An array of columns stored for this field. Each is a collection
 *       of information returned from hook_field_settings('database columns'),
 *       with the addition of a "column" attribute which holds the name of the
 *       database column that stores the data.
 */
function content_database_info($field) {
  $columns = content_invoke_columns($field);
  $db_info = array();

  if ($field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD) {
    $db_info['table'] = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);
  }
  else {
    $db_info['table'] = _content_tablename($field['type_name'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  }

  if (is_array($columns) && count($columns)) {
    $db_info['columns'] = $columns;
    foreach ($columns as $column_name => $attributes) {
      $db_info['columns'][$column_name]['column'] = $field['field_name'] .'_'. $column_name;
    }
  }
  else {
    $db_info['columns'] = array();
  }
  return $db_info;
}

/**
 * Helper function to retrieve column information for a field
 * Allows content module to control column settings.
 */
function content_invoke_columns($field) {
  $module = $field['module'];
  $columns = module_invoke($module, 'field_settings', 'database columns', $field);
  if (is_array($columns)) {
    // Ensure columns always default to NULL values.
    foreach ($columns as $column_name => $column) {
      $columns[$column_name]['not null'] = FALSE;
      unset($columns[$column_name]['default']);
    }
  }
  return $columns;
}

/**
 * Manipulate a 2D array to reverse rows and columns.
 *
 * The default data storage for fields is delta first, column names second.
 * This is sometimes inconvenient for field modules, so this function can be
 * used to present the data in an alternate format.
 *
 * @param $array
 *   The array to be transposed. It must be at least two-dimensional, and
 *   the subarrays must all have the same keys or behavior is undefined.
 *
 * @return
 *   The transposed array.
 */
function content_transpose_array_rows_cols($array) {
  $result = array();
  if (is_array($array)) {
    foreach ($array as $key1 => $value1) {
      if (is_array($value1)) {
        foreach ($value1 as $key2 => $value2) {
          if (!isset($result[$key2])) {
            $result[$key2] = array();
          }
          $result[$key2][$key1] = $value2;
        }
      }
    }
  }
  return $result;
}

/**
 *  Create an array of the allowed values for this field.
 *
 *  Used by number and text fields, expects to find either
 *  php code that will return the correct value, or a string
 *  with keys and labels separated with '|' and with each
 *  new value on its own line.
 */
function content_allowed_values($field) {
  static $allowed_values;

  if (isset($allowed_values[$field['field_name']])) {
    return $allowed_values[$field['field_name']];
  }

  $allowed_values[$field['field_name']] = array();

  if (isset($field['allowed_values_php'])) {
    ob_start();
    $result = eval($field['allowed_values_php']);
    if (is_array($result)) {
      $allowed_values[$field['field_name']] = $result;
    }
    ob_end_clean();
  }

  if (empty($allowed_values[$field['field_name']]) && isset($field['allowed_values'])) {
    $list = explode("\n", $field['allowed_values']);
    $list = array_map('trim', $list);
    $list = array_filter($list, 'strlen');
    foreach ($list as $opt) {
      if (strpos($opt, '|') !== FALSE) {
        list($key, $value) = explode('|', $opt);
        $allowed_values[$field['field_name']][$key] = $value ? $value : $key;
      }
      else {
        $allowed_values[$field['field_name']][$opt] = $opt;
      }
    }
  }
  return $allowed_values[$field['field_name']];
}

/**
 * Format a field item for display.
 *
 * @param $field
 *   Either a field array or the name of the field.
 * @param $item
 *   The field item to be formatted (such as $node->field_foo[0]).
 * @param $formatter
 *   The name of the formatter to use.
 * @param $node
 *   Optionally, the containing node object for context purposes.
 *
 * @return
 *   A string containing the contents of the field item sanitized for display.
 *   It will have been passed through the necessary check_plain() or check_markup()
 *   functions as necessary.
 */
function content_format($field, $item, $formatter = 'default', $node = NULL) {
  if (!is_array($field)) {
    $field = content_fields($field);
  }
  $field_types = _content_field_types();
  $formatters = $field_types[$field['type']]['formatters'];

  if (!isset($formatter, $formatters)) {
    $formatter = 'default';
  }
  return module_invoke($formatters[$formatter]['module'], 'field_formatter', $field, $item, $formatter, $node);
}

/**
 * Generate a table name for a field or a content type.
 *
 * @param $name
 *   The name of the content type or content field
 * @param $storage
 *   CONTENT_DB_STORAGE_PER_FIELD or CONTENT_DB_STORAGE_PER_CONTENT_TYPE
 *
 * @return
 *   A string containing the generated name for the database table
 */
function _content_tablename($name, $storage, $version = NULL) {
  if (is_null($version)) {
    $version = variable_get('content_schema_version', 0);
  }

  if ($version < 1003) {
    $version = 0;
  }
  else {
    $version = 1003;
  }

  $name = str_replace('-', '_', $name);
  switch ("$version-$storage") {
    case '0-'. CONTENT_DB_STORAGE_PER_CONTENT_TYPE :
      return "node_$name";
    case '0-'. CONTENT_DB_STORAGE_PER_FIELD :
      return "node_data_$name";
    case '1003-'. CONTENT_DB_STORAGE_PER_CONTENT_TYPE :
      return "content_type_$name";
    case '1003-'. CONTENT_DB_STORAGE_PER_FIELD :
      return "content_$name";
  }
}

function _content_table_schema($field = NULL) {
  $base_schema = array(
    'fields' => array(
      'vid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'nid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0)
    ),
    'primary key' => array('vid'),
  );
  if (isset($field['multiple'])) {
    $base_schema['fields']['delta'] = array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0);
    $base_schema['primary key'][] = 'delta';
  }
  // TODO : add the $field right now ?
  $base_schema['content fields'] = array();
  return $base_schema;
}

/**
 *  Helper function for determining the behaviour of a field or a widget
 *  with respect to a given operation. (currently used for field 'view',
 *  and widget 'default values' and 'multiple values')
 *
 *  @param $entity
 *    'field' or 'widget'
 *
 *  @param $op
 *    the name of the operation ('view', 'default value'...)
 *
 *  @param $field
 *    The field array, including widget info.

 * @return
 *    CONTENT_CALLBACK_NONE    - do nothing for this operation
 *    CONTENT_CALLBACK_CUSTOM  - use the module's callback function.
 *    CONTENT_CALLBACK_DEFAULT - use content module default behaviour
 *
 */
function content_callback($entity, $op, $field) {
  switch ($entity) {
    case 'field':
      $entity_types = _content_field_types();
      $entity_type = $field['type'];
      $module = $entity_types[$entity_type]['module'];
      $info = module_invoke($module, "field_info");
      return $info[$field['type']]['callbacks'][$op];

    case 'widget':
      $entity_types = _content_widget_types();
      $entity_type = $field['widget']['type'];
      $module = $entity_types[$entity_type]['module'];
      $info = module_invoke($module, "widget_info");
      return $info[$field['widget']['type']]['callbacks'][$op];
  }
}

/**
 *  Helper function for determining the handling of a field or a widget
 *  with respect to a given operation. (currently used for widget 'multiple values')
 *
 *  @param $entity
 *    'field' or 'widget'
 *
 *  @param $op
 *    the name of the operation ('default values'...)
 *
 *  @param $field
 *    The field array, including widget info.

 * @return
 *    CONTENT_HANDLE_CORE    - the content module handles this operation.
 *    CONTENT_HANDLE_MODULE  - the module handles this operation.
 */
function content_handle($entity, $op, $field) {
  switch ($entity) {
    case 'field':
      $entity_types = _content_field_types();
      $entity_type = $field['type'];
      $module = $entity_types[$entity_type]['module'];
      $info = module_invoke($module, "field_info");
      return $info[$field['type']][$op];

    case 'widget':
      $entity_types = _content_widget_types();
      $entity_type = $field['widget']['type'];
      $module = $entity_types[$entity_type]['module'];
      $info = module_invoke($module, "widget_info");
      return $info[$field['widget']['type']][$op];
  }
}

/**
 *  Helper function to return the correct default value for a field.
 *
 *  @param $node
 *    The node.
 *
 *  @param $field
 *    The field array.
 *
 *  @param $items
 *    The value of the field in the node.
 *
 *  @return
 *    The default value for that field.
 */
function content_default_value(&$form, &$form_state, $field, $delta) {
  $widget_types = _content_widget_types();
  $module = $widget_types[$field['widget']['type']]['module'];

  $default_value = array();
  if (!empty($field['widget']['default_value_php'])) {
    ob_start();
    $result = eval($field['widget']['default_value_php']);
    ob_end_clean();
    if (is_array($result)) {
      $default_value = $result;
    }
  }
  elseif (!empty($field['widget']['default_value'])) {
    $default_value = $field['widget']['default_value'];
  }

  return (array) $default_value;
}

/**
 * Hook elements().
 *
 * Used to add multiple value processing, validation, and themes.
 *
 * FAPI callbacks can be declared here, and the element will be
 * passed to those callbacks.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 *
 * @TODO any more generic multiple value processing we could add here??
 */
function content_elements() {
  return array(
    'content_multiple_values' => array(
      '#input' => TRUE,
    ));
}

/**
 * Theme an individual form element.
 *
 * Combine multiple values into a fieldset.
 * Override the theme to eliminate the fieldset or make other changes.
 *
 * We work with $element['#children'] here instead of using drupal_render()
 * because the individual items in the element have already been rendered.
 * Alter children in the theme set on the individual element.
 */
function theme_content_multiple_values($element) {
  if (isset($element['#children'])) {
    $field_name = $element['#field_name'];
    $field = content_fields($field_name);
    $type = content_types($field['type_name']);
    $widget = $type['fields'][$field_name]['widget'];
    if (!empty($field['multiple'])) {
      // Change the button title to reflect the behavior when using JavaScript.
      drupal_add_js('if (Drupal.jsEnabled) { $(document).ready(function() { $("#edit-'. str_replace('_', '-', $field_name) .'-add-more").val("'. t('Add another item') .'"); }); }', 'inline');
    }
    return $element['#children'];
  }
}

/**
 * Process variables for field.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $node
 * - $field
 * - $items
 * - $teaser
 * - $page
 *
 * @see field.tpl.php
 */
function template_preprocess_field(&$variables) {
  $field = $variables['field'];
  $field_empty = FALSE;
  foreach ($variables['items'] as $item) {
    if (empty($item['view']) && $item['view'] !== 0) {
      $field_empty = TRUE;
    }
  }
  $additions = array(
    'field_type' => $field['type'],
    'field_name' => $field['field_name'],
    'field_type_css' => strtr($field['type'], '_', '-'),
    'field_name_css' => strtr($field['field_name'], '_', '-'),
    'label' => $field['widget']['label'],
    'label_display' => isset($field['display_settings']['label']['format']) ? $field['display_settings']['label']['format'] : 'above',
    'field_empty' => $field_empty,
  );
  $variables = array_merge($variables, $additions);
}