<?php
// $Id$
/**
 * @file
 * Allows administrators to associate custom fields to content types.
 */

define('CONTENT_DB_STORAGE_PER_FIELD', 0);
define('CONTENT_DB_STORAGE_PER_CONTENT_TYPE', 1);

define('CONTENT_CALLBACK_NONE', 0x0001);
define('CONTENT_CALLBACK_DEFAULT', 0x0002);
define('CONTENT_CALLBACK_CUSTOM', 0x0004);

define('CONTENT_HANDLE_CORE', 0x0001);
define('CONTENT_HANDLE_MODULE', 0x0002);

/**
 * Implementation of hook_flush_caches.
 */
function content_flush_caches() {
  return array('cache_content');
}

/**
 * Implementation of hook_init().
 *
 * XXX This is a temporary hack.  includes/content_crud.inc contains
 * the Field API, which should be always be loaded.  This file
 * contains some hook implementations which should probably be in an
 * include file.  So the file/code organization is all backwards.
 * Eventually we'll fix that, but for right now, just always include
 * content.crud.
 */
function content_init() {
  module_load_include('inc', 'content', 'includes/content.crud');
  module_load_include('inc', 'content', 'includes/content.alter');
}


/**
 * Implementation of hook_menu().
 */
function content_menu() {
  $items = array();

  // Callback for AHAH add more buttons.
  $items['content/js_add_more'] = array(
    'page callback' => 'content_add_more_js',
    'access arguments' => array('access content'),
    'file' => 'includes/content.node_form.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Hook elements().
 *
 * Used to add multiple value processing, validation, and themes.
 *
 * FAPI callbacks can be declared here, and the element will be
 * passed to those callbacks.
 *
 * Drupal will automatically theme the element using a theme with
 * the same name as the hook_elements key.
 */
function content_elements() {
  return array(
    'content_multiple_values' => array(),
    'content_field' => array(),
  );
}

/**
 * Implementation of hook_theme().
 */
function content_theme() {
  $path = drupal_get_path('module', 'content') .'/theme';

  return array(
    'content_field' => array(
      'template' => 'content-field',
      'arguments' => array('element' => NULL),
      'path' => $path,
    ),
    'content_exclude' => array(
      'arguments' => array('content' => NULL, 'object' => array(), 'context' => NULL),
    ),
    'content_multiple_values' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Load data for a node type's fields.
 * Implementation of hook_nodeapi_load.
 *
 * When loading one of the content.module nodes, we need to let each field handle
 * its own loading. This can make for a number of queries in some cases, so we
 * cache the loaded object structure and invalidate it during the update process.
 */
function content_nodeapi_load(&$node) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      $cid = 'content:'. $node->nid .':'. $node->vid;
      if ($cached = cache_get($cid, content_cache_tablename())) {
        foreach ($cached->data as $key => $value) {
          $node->$key = $value;
        }
      }
      else {
        $default_additions = _content_field_invoke_default('load', $node);
        if ($default_additions) {
          foreach ($default_additions as $key => $value) {
            $node->$key = $value;
          }
        }
        $additions = _content_field_invoke('load', $node);
        if ($additions) {
          foreach ($additions as $key => $value) {
            $node->$key = $value;
            $default_additions[$key] = $value;
          }
        }
        cache_set($cid, $default_additions, content_cache_tablename());
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi_validate.
 *
 */
function content_nodeapi_validate(&$node, $form = NULL) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      _content_field_invoke('validate', $node, $form);
      _content_field_invoke_default('validate', $node, $form);
    }
  }
}

/**
 * Implementation of hook_nodeapi_presave.
 */
function content_nodeapi_presave(&$node) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      _content_field_invoke('presave', $node);
      _content_field_invoke_default('presave', $node);
    }
  }
}

/**
 * Implementation of hook_nodeapi_insert.
 */
function content_nodeapi_insert(&$node) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      _content_field_invoke('insert', $node);
      _content_field_invoke_default('insert', $node);
    }
  }
}

/**
 * Implementation of hook_nodeapi_update.
 */
function content_nodeapi_update(&$node) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      _content_field_invoke('update', $node);
      _content_field_invoke_default('update', $node);
      cache_clear_all('content:'. $node->nid .':'. $node->vid, 'cache_content');
    }
  }
}

/**
 * Implementation of hook_nodeapi_delete.
 */
function content_nodeapi_delete(&$node) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      _content_field_invoke('delete', $node);
      _content_field_invoke_default('delete', $node);
      cache_clear_all('content:'. $node->nid .':', 'cache_content', TRUE);
    }
  }
}

/**
 * Implementation of hook_nodeapi_delete_revision.
 */
function content_nodeapi_delete_revision(&$node) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      _content_field_invoke('delete revision', $node);
      _content_field_invoke_default('delete revision', $node);
      cache_clear_all('content:'. $node->nid .':'. $node->vid, 'cache_content');
    }
  }
}

/**
 * Implementataion of content_nodeapi_view.
 */
function content_nodeapi_view(&$node, $teaser = FALSE, $page = FALSE) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      // Let field modules sanitize their data for output.
      // TODO D7 : we could reintegrate hook_field('view') for this ?
      _content_field_invoke('sanitize', $node, $teaser, $page);

      // Merge fields.
      $additions = _content_field_invoke_default('view', $node, $teaser, $page);
      $node->content = array_merge((array) $node->content, $additions);
    }
  }
}

/**
 * Render a single field, fully themed with label and multiple values.
 *
 * To be used by third-party code (Views, Panels...) that needs to output
 * an isolated field. Do *not* use inside node templates, use the
 * $FIELD_NAME_rendered variables instead.
 *
 * By default, the field is displayed using the settings defined for the
 * 'full node' or 'teaser' contexts (depending on the value of the $teaser param).
 * Set $node->build_mode to a different value to use a different context.
 *
 * Different settings can be specified by adjusting $field['display_settings'].
 *
 * @param $field
 *   The field definition.
 * @param $node
 *   The node containing the field to display. Can be a 'pseudo-node', containing
 *   at least 'type', 'nid', 'vid', and the field data.
 * @param $teaser
 * @param $page
 *   Similar to hook_nodeapi('view')
 * @return
 *   The themed output for the field.
 */
function content_view_field($field, $node, $teaser = FALSE, $page = FALSE) {
  $output = '';
  if (isset($node->$field['field_name'])) {
    $items = $node->$field['field_name'];

    // Use 'full'/'teaser' if not specified otherwise.
    $node->build_mode = isset($node->build_mode) ? $node->build_mode : NODE_BUILD_NORMAL;

    // One-field equivalent to _content_field_invoke('sanitize').
    $field_types = _content_field_types();
    $module = $field_types[$field['type']]['module'];
    $function = $module .'_field';
    if (function_exists($function)) {
      $function('sanitize', $node, $field, $items, $teaser, $page);
      $node->$field['field_name'] = $items;
    }

    $view = content_field('view', $node, $field, $items, $teaser, $page);
    // content_field('view') adds a wrapper to handle variables and 'excluded'
    // fields for node templates. We bypass it and render the actual field.
    $output = drupal_render($view[$field['field_name']]['field']);
  }
  return $output;
}

/**
 * Implementation of hook_nodeapi_alter.
 *
 * Add back the formatted values in the 'view' element for all fields,
 * so that node templates can use it.
 */
function content_nodeapi_alter(&$node, $teaser = FALSE, $page = FALSE) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      _content_field_invoke_default('alter', $node, $teaser, $page);
    }
  }
}

/**
 * Implementation of hook_nodeapi_prepare_translation.
 */
function content_nodeapi_prepare_translation(&$node) {
  // Prevent against invalid 'nodes' built by broken 3rd party code.
  if (isset($node->type)) {
    $type = content_types($node->type);
    // Save cycles if the type has no CCK fields.
    if (!empty($type['instances'])) {
      $default_additions = _content_field_invoke_default('prepare translation', $node);
      $additions = _content_field_invoke('prepare translation', $node);
      // Merge module additions after the default ones to enable overriding
      // of field values.
      $node = (object) array_merge((array) $node, $default_additions, $additions);
    }
  }
}

/**
 *  Implementation of hook_form_alter().
 */
function content_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {
    $type = content_types($form['#node']->type);
    if (!empty($type['instances'])) {
      module_load_include('inc', 'content', 'includes/content.node_form');
      // Merge field widgets.
      $form = array_merge($form, content_form($form, $form_state));
    }
  }
}

/**
 * Proxy function to call content_add_more_submit(), because it might not be
 * included yet when the form is processed and invokes the callback.
 */
function content_add_more_submit_proxy($form, &$form_state) {
  module_load_include('inc', 'content', 'includes/content.node_form');
  content_add_more_submit($form, $form_state);
}

/**
 * Theme an individual form element.
 *
 * Combine multiple values into a table with drag-n-drop reordering.
 */
function theme_content_multiple_values($element) {
  $field_name = $element['#field_name'];
  $field = content_fields($field_name);
  $output = '';

  if ($field['multiple'] >= 1) {
    $table_id = $element['#field_name'] .'_values';
    $order_class = $element['#field_name'] .'-delta-order';
    $required = !empty($element['#required']) ? '<span class="form-required" title="'. t('This field is required.') .'">*</span>' : '';

    $header = array(
      array(
        'data' => t('!title: !required', array('!title' => $element['#title'], '!required' => $required)),
        'colspan' => 2
      ),
      t('Order'),
    );
    $rows = array();

    // Sort items according to '_weight' (needed when the form comes back after
    // preview or failed validation)
    $items = array();
    foreach (element_children($element) as $key) {
      if ($key !== $element['#field_name'] .'_add_more') {
        $items[] = &$element[$key];
      }
    }
    usort($items, '_content_sort_items_value_helper');

    // Add the items as table rows.
    foreach ($items as $key => $item) {
      $item['_weight']['#attributes']['class'] = $order_class;
      $delta_element = drupal_render($item['_weight']);
      $cells = array(
        array('data' => '', 'class' => 'content-multiple-drag'),
        drupal_render($item),
        array('data' => $delta_element, 'class' => 'delta-order'),
      );
      $rows[] = array(
        'data' => $cells,
        'class' => 'draggable',
      );
    }

    $output .= theme('table', $header, $rows, array('id' => $table_id, 'class' => 'content-multiple-table'));
    $output .= $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '';
    $output .= drupal_render($element[$element['#field_name'] .'_add_more']);

    drupal_add_tabledrag($table_id, 'order', 'sibling', $order_class);
  }
  else {
    foreach (element_children($element) as $key) {
      $output .= drupal_render($element[$key]);
    }
  }

  return $output;
}

/**
 * Modules notify Content module when uninstalled, disabled, etc.
 *
 * @param string $op
 *   the module operation: uninstall, install, enable, disable
 * @param string $module
 *   the name of the affected module.
 * @TODO
 *   figure out exactly what needs to be done by content module when
 *   field modules are installed, uninstalled, enabled or disabled.
 */
function content_notify($op, $module) {
  switch ($op) {
    case 'install':
      content_clear_type_cache();
      break;
    case 'uninstall':
      module_load_include('inc', 'content', 'includes/content.crud');
      content_module_delete($module);
      break;
    case 'enable':
      content_associate_fields($module);
      content_clear_type_cache();
      break;
    case 'disable':
      db_update(content_field_tablename())
        ->fields(array('active' => 0))
        ->condition('module', $module)
        ->execute();
      db_update(content_instance_tablename())
        ->fields(array('widget_active' => 0))
        ->condition('widget_module', $module)
        ->execute();
      content_clear_type_cache(TRUE);
      break;
  }
}

/**
 * Allows a module to update the database for fields and columns it controls.
 *
 * @param string $module
 *   The name of the module to update on.
 */
function content_associate_fields($module) {
  $module_fields = module_invoke($module, 'field_info');
  if ($module_fields) {
    foreach ($module_fields as $name => $field_info) {
      watchdog('content', 'Updating field type %type with module %module.', array('%type' => $name, '%module' => $module));
      db_update(content_field_tablename())
        ->fields(array('module' => $module, 'active' => 1))
        ->condition('type', $name)
        ->execute();
    }
  }
  $module_widgets = module_invoke($module, 'widget_info');
  if ($module_widgets) {
    foreach ($module_widgets as $name => $widget_info) {
      watchdog('content', 'Updating widget type %type with module %module.', array('%type' => $name, '%module' => $module));
      db_update(content_instance_tablename())
        ->fields(array('widget_module' => $module, 'widget_active' => 1))
        ->condition('widget_type', $name)
        ->execute();
    }
  }
  // This is called from updates and installs, so get the install-safe
  // version of a fields array.
  $fields_set = array();
  module_load_include('install', 'content');
  $types = content_types_install();
  foreach ($types as $type_name => $fields) {
    foreach ($fields as $field) {
      if ($field['module'] == $module && !in_array($field['field_name'], $fields_set)) {
        $columns = module_invoke($field['module'], 'field_settings', 'database columns', $field);
        db_update(content_field_tablename())
          ->fields(array('db_columns' => serialize($columns)))
          ->condition('field_name', $field['field_name'])
          ->execute();
        $fields_set[] = $field['field_name'];
      }
    }
  }
}

/**
 * Implementation of hook_field(). Handles common field housekeeping.
 *
 * This implementation is special, as content.module does not define any field
 * types. Instead, this function gets called after the type-specific hook, and
 * takes care of default stuff common to all field types.
 *
 * Db-storage ops ('load', 'insert', 'update', 'delete', 'delete revisions')
 * are not executed field by field, and are thus handled separately in
 * content_storage.
 *
 * The 'view' operation constructs the $node in a way that you can use
 * drupal_render() to display the formatted output for an individual field.
 * i.e. print drupal_render($node->countent['field_foo']);
 *
 * The code now supports both single value formatters, which theme an
 * individual item value as has been done in previous version of CCK,
 * and multiple value formatters, which theme all values for the field
 * in a single theme. The multiple value formatters could be used, for
 * instance, to plot field values on a single map or display them
 * in a graph. Single value formatters are the default, multiple value
 * formatters can be designated as such in formatter_info().
 *
 * The node array will look like:
 *   $node->content['field_foo']['wrapper'] = array(
 *     '#type' => 'content_field',
 *     '#title' => 'label'
 *     '#field_name' => 'field_name',
 *     '#node' => $node,
 *     // Value of the $teaser param of hook_nodeapi('view').
 *     '#teaser' => $teaser,
 *     // Value of the $page param of hook_nodeapi('view').
 *     '#page' => $page,
 *     // The curent rendering context ('teaser', 'full', NODE_BUILD_SEARCH_INDEX...).
 *     '#context' => $context,
 *     'items' =>
 *       0 => array(
 *         '#item' => $items[0],
 *         // Only for 'single-value' formatters
 *         '#theme' => $theme,
 *         '#field_name' => 'field_name',
 *         '#type_name' => $node->type,
 *         '#formatter' => $formatter_name,
 *         '#node' => $node,
 *         '#delta' => 0,
 *       ),
 *       1 => array(
 *         '#item' => $items[1],
 *         // Only for 'single-value' formatters
 *         '#theme' => $theme,
 *         '#field_name' => 'field_name',
 *         '#type_name' => $node->type,
 *         '#formatter' => $formatter_name,
 *         '#node' => $node,
 *         '#delta' => 1,
 *       ),
 *       // Only for 'multiple-value' formatters
 *       '#theme' => $theme,
 *       '#field_name' => 'field_name',
 *       '#type_name' => $node->type,
 *       '#formatter' => $formatter_name,
 *     ),
 *   );
 */
function content_field($op, &$node, $instance, &$items, $teaser, $page) {
  $field = field_instance_get_field($instance);
  switch ($op) {
    case 'validate':
      // TODO: here we could validate that the number of multiple data is correct ?
      // We're controlling the number of fields to fill out and saving empty
      // ones if a specified number is requested, so no reason to do any validation
      // here right now, but if later create a method to indicate whether
      // 'required' means all values must be filled out, we can come back
      // here and check that they're not empty.
      break;

    case 'presave':

      // Manual node_save calls might not have all fields filled in.
      // On node insert, we need to make sure all tables get at least an empty
      // record, or subsequent edits, using drupal_write_record() in update mode,
      // won't insert any data.
      // Missing fields on node update are handled in content_storage().
      if (empty($items) && !isset($node->nid)) {
        foreach (array_keys($field['columns']) as $column) {
          $items[0][$column] = NULL;
        }
        $node->$field['field_name'] = $items;
      }

      // If there was an AHAH add more button in this field, don't save it.
      // TODO: is it still needed ?
      unset($items[$field['field_name'] .'_add_more']);

      if (content_handle_instance('multiple values', $instance) == CONTENT_HANDLE_CORE) {
        // Reorder items to account for drag-n-drop reordering.
        $items = _content_sort_items($field, $items);
      }

      // Filter out empty values.
      $items = content_set_empty($field, $items);

      break;

    case 'view':
      $addition = array();

      // Previewed nodes bypass the 'presave' op, so we need to some massaging.
      if ($node->build_mode == NODE_BUILD_PREVIEW && content_handle_widget('multiple values', $instance) == CONTENT_HANDLE_CORE) {
        if (content_handle_widget('multiple values', $instance) == CONTENT_HANDLE_CORE) {
          // Reorder items to account for drag-n-drop reordering.
          $items = _content_sort_items($field, $items);
        }

        // Filter out empty values.
        $items = content_set_empty($field, $items);
      }

      // NODE_BUILD_NORMAL is 0, and ('whatever' == 0) is TRUE, so we need a ===.
      if ($node->build_mode === NODE_BUILD_NORMAL || $node->build_mode == NODE_BUILD_PREVIEW) {
        $context = $teaser ? 'teaser' : 'full';
      }
      else {
        $context = $node->build_mode;
      }

      $formatter_name = isset($instance['display_settings'][$context]['format']) ? $instance['display_settings'][$context]['format'] : 'default';
      if ($formatter = _content_get_formatter($formatter_name, $field['type'])) {
        $theme = $formatter['module'] .'_formatter_'. $formatter_name;
        $single = (content_handle_formatter('multiple values', $formatter) == CONTENT_HANDLE_CORE);

        $label_display = isset($instance['display_settings']['label']['format']) ? $instance['display_settings']['label']['format'] : 'above';
        // Do not include field labels when indexing content.
        if ($context == NODE_BUILD_SEARCH_INDEX) {
          $label_display = 'hidden';
        }

        $element = array(
          '#type' => 'content_field',
          '#title' => check_plain(t($instance['widget']['label'])),
          '#field_name' => $field['field_name'],
          '#access' => $formatter_name != 'hidden',
          '#label_display' => $label_display,
          '#node' => $node,
          '#teaser' => $teaser,
          '#page' => $page,
          '#context' => $context,
          '#single' => $single,
          'items' => array(),
        );

        // Fill-in items.
        foreach ($items as $delta => $item) {
          $element['items'][$delta] = array(
            '#item' => $item,
            '#weight' => $delta,
          );
        }

        // Append formatter information either on each item ('single-value' formatter)
        // or at the upper 'items' level ('multiple-value' formatter)
        $format_info = array(
          '#theme' => $theme,
          '#field_name' => $field['field_name'],
          '#type_name' => $node->type,
          '#formatter' => $formatter_name,
          '#node' => $node,
        );
        if ($single) {
          foreach ($items as $delta => $item) {
            $element['items'][$delta] += $format_info;
            $element['items'][$delta]['#item']['#delta'] = $delta;
          }
        }
        else {
          $element['items'] += $format_info;
        }

        // The wrapper lets us get the themed output for the whole field
        // to populate the $FIELD_NAME_rendered variable for node templates,
        // and hide it from the $content variable if needed.
        // See 'preprocess_node' op and theme_content_field_wrapper()?
        $wrapper = array(
          'field' => $element,
          '#weight' => $instance['widget']['weight'],
        );

        $addition = array($field['field_name'] => $wrapper);
      }
      return $addition;

    case 'alter':
      // Add back the formatted values in the 'view' element,
      // so that node templates can use it.
      // TODO D7 : do we still need this ?
      $element = $node->content[$field['field_name']]['field'];
      // '#single' is not set if the field is hidden or inaccessible.
      if (isset($element['#single'])) {
        if (!empty($element['#single'])) {
          // Single value formatter.
          foreach (element_children($element['items']) as $delta) {
            // '#chilren' is not set if the field is empty.
            $items[$delta]['view'] = isset($element['items'][$delta]['#children']) ? $element['items'][$delta]['#children'] : '';
          }
        }
        elseif (isset($element['items']['#children']))  {
          // Multiple values formatter.
          $items[0]['view'] = $element['items']['#children'];
        }
      }
      else {
        // Hidden or inaccessible field.
        $items[0]['view'] = '';
      }
      break;

    case 'preprocess_node':
      // Add $FIELD_NAME_rendered variables.
      $addition = array();
      $element = $node->content[$field['field_name']];
      // '#chilren' is not set if the field is empty.
      $addition[$field['field_name'] .'_rendered'] = isset($element['#children']) ? $element['#children'] : '';

      return $addition;

    case 'prepare translation':
      $addition = array();
      if (isset($node->translation_source->$field['field_name'])) {
        $addition[$field['field_name']] = $node->translation_source->$field['field_name'];
      }
      return $addition;
  }
}

/**
 * Helper function to filter out empty values.
 *
 * On order to keep marker rows in the database, the function ensures
 * that the right number of 'all columns NULL' values is kept.
 *
 * @param array $field
 * @param array $items
 * @return array
 *   returns filtered and adjusted item array
 */
function content_set_empty($field, $items) {
  // Filter out empty values.
  $filtered = array();
  $function = $field['module'] .'_content_is_empty';
  foreach ((array) $items as $delta => $item) {
    if (!$function($item, $field)) {
      $filtered[] = $item;
    }
  }

  // Make sure we store the right number of 'empty' values.
  $empty = array();
  foreach (array_keys($field['columns']) as $column) {
    $empty[$column] = NULL;
  }
  $pad = $field['multiple'] > 1 ? $field['multiple'] : 1;
  $filtered = array_pad($filtered, $pad, $empty);

  return $filtered;
}

/**
 * Helper function to sort items in a field according to
 * user drag-n-drop reordering.
 */
function _content_sort_items($field, $items) {
  if ($field['multiple'] >= 1 && isset($items[0]['_weight'])) {
    usort($items, '_content_sort_items_helper');
    foreach ($items as $delta => $item) {
      if (is_array($items[$delta])) {
        unset($items[$delta]['_weight']);
      }
    }
  }
  return $items;
}

/**
 * Sort function for items order.
 * (copied form element_sort(), which acts on #weight keys)
 */
function _content_sort_items_helper($a, $b) {
  $a_weight = (is_array($a) && isset($a['_weight'])) ? $a['_weight'] : 0;
  $b_weight = (is_array($b) && isset($b['_weight'])) ? $b['_weight'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}

/**
 * Same as above, using ['_weight']['#value']
 */
function _content_sort_items_value_helper($a, $b) {
  $a_weight = (is_array($a) && isset($a['_weight']['#value'])) ? $a['_weight']['#value'] : 0;
  $b_weight = (is_array($b) && isset($b['_weight']['#value'])) ? $b['_weight']['#value'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}

/**
 * Handle storage ops for _content_field_invoke_default().
 */
function content_storage($op, $node) {
  $type_name = $node->type;
  $type = content_types($type_name);

  switch ($op) {
    case 'load':
      // OPTIMIZE: load all non multiple fields in a single JOIN query ?
      // warning: 61-join limit in MySQL ?
      $additions = array();
      // For each table used by this content type,
      foreach ($type['tables'] as $table) {
        $schema = drupal_get_schema($table);
        // The per-type table might not have any fields actually stored in it.
        if (!$schema['content fields']) {
          continue;
        }

        $query = db_select($table, 't')
          ->fields('t')
          ->condition('vid', $node->vid);
        // If we're loading a table for a multiple field,
        // we fetch all rows (values) ordered by delta,
        // else we only fetch one row.
        if (isset($schema['fields']['delta'])) {
          $query->orderBy('delta');
        }
        else {
          $query->range(0, 1);
        }
        $results = $query->execute();
        // For each table row, populate the fields.
        foreach ($results as $row) {
          // For each field stored in the table, add the field item.
          foreach ($schema['content fields'] as $field_name) {
            $item = array();
            $instance = content_fields($field_name, $type_name);
            $db_info = content_database_info($instance);
            // For each column declared by the field, populate the item.
            foreach ($db_info['columns'] as $column => $attributes) {
              $item[$column] = $row->$attributes['column'];
            }

            // Add the item to the field values for the node.
            if (!isset($additions[$field_name])) {
              $additions[$field_name] = array();
            }
            $additions[$field_name][] = $item;
          }
        }
      }
      return $additions;

    case 'insert':
    case 'update':
      // TODO D7 : we used [content|drupal]_write_record mainly because it generated placeholders for us. Unneeded now with PDO.
      // !! Be sure to check direct node_save with missing fields (leave field as is) / fields set to NULL (set field to empty)
      foreach ($type['tables'] as $table) {
        $schema = drupal_get_schema($table);
        $record = array();
        foreach ($schema['content fields'] as $field_name) {
          if (isset($node->$field_name)) {
            $instance = content_fields($field_name, $type_name);

            // Multiple fields need specific handling, we'll deal with
            // them later on.
            $field = field_instance_get_field($instance);
            if ($field['multiple']) {
              continue;
            }

            $db_info = content_database_info($instance);
            foreach ($db_info['columns'] as $column => $attributes) {
              $record[$attributes['column']] = $node->{$field_name}[0][$column];
            }
          }
        }
        // $record might be empty because
        // - the table stores a multiple field :
        //   we do nothing, this is handled later on
        // - this is the per-type table and no field is actually stored in it :
        //   we still store the nid and vid
        // TODO D7 : remove this specific case (empty per-type table) ?
        if (count($record) || empty($schema['content fields'])) {
          $record['nid'] = $node->nid;
          $record['vid'] = $node->vid;
          // Can't rely on the insert/update op of the node to decide if this
          // is an insert or an update, a node or revision may have existed
          // before any fields were created, so there may not be an entry here.

          // TODO - should we auto create an entry for all existing nodes when
          // fields are added to content types -- either a NULL value
          // or the default value? May need to offer the user an option of
          // how to handle that.

          // TODO D7 : merge query ?
          if (db_query("SELECT COUNT(*) FROM {". $table ."} WHERE vid = :vid", array(':vid' => $node->vid))->fetchField()) {
            content_write_record($table, $record, array('vid'));
          }
          else {
            content_write_record($table, $record);
          }
        }
      }

      // Handle multiple fields.
      foreach ($type['instances'] as $instance) {
        $field = field_instance_get_field($instance);
        $field_name = $field['field_name'];
        if ($field['multiple'] && isset($node->$field_name)) {
          $db_info = content_database_info($instance);
          // TODO D7 : Merge query ? multi update ?
          // Delete and insert, rather than update, in case a value was added.
          if ($op == 'update') {
            db_delete($db_info['table'])
              ->condition('vid', $node->vid)
              ->execute();
          }
          foreach ($node->$field_name as $delta => $item) {
            $record = array();
            foreach ($db_info['columns'] as $column => $attributes) {
              $record[$attributes['column']] = $item[$column];
            }
            $record['nid'] = $node->nid;
            $record['vid'] = $node->vid;
            $record['delta'] = $delta;
            content_write_record($db_info['table'], $record);
          }
        }
      }
      break;

    case 'delete':
      foreach ($type['tables'] as $table) {
        db_delete($table)
          ->condition('nid', $node->nid)
          ->execute();
      }
      break;

    case 'delete revision':
      foreach ($type['tables'] as $table) {
        db_delete($table)
          ->condition('vid', $node->vid)
          ->execute();
      }
      break;
  }
}

/**
 * Save a record to the database based upon the schema.
 *
 * Directly copied from core's drupal_write_record, which can't update a
 * column to NULL. See http://drupal.org/node/227677 and
 * http://drupal.org/node/226264 for more details about that problem.
 *
 * Default values are filled in for missing items, and 'serial' (auto increment)
 * types are filled in with IDs.
 *
 * @param $table
 *   The name of the table; this must exist in schema API.
 * @param $object
 *   The object to write. This is a reference, as defaults according to
 *   the schema may be filled in on the object, as well as ID on the serial
 *   type(s). Both array an object types may be passed.
 * @param $update
 *   If this is an update, specify the primary keys' field names. It is the
 *   caller's responsibility to know if a record for this object already
 *   exists in the database. If there is only 1 key, you may pass a simple string.
 * @return
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or
 *   SAVED_UPDATED is returned depending on the operation performed. The
 *   $object parameter contains values for any serial fields defined by
 *   the $table. For example, $object->nid will be populated after inserting
 *   a new node.
 */
function content_write_record($table, &$object, $update = array()) {
  // Standardize $update to an array.
  if (is_string($update)) {
    $update = array($update);
  }

  // Convert to an object if needed.
  if (is_array($object)) {
    $object = (object) $object;
    $array = TRUE;
  }
  else {
    $array = FALSE;
  }

  $schema = drupal_get_schema($table);
  if (empty($schema)) {
    return FALSE;
  }

  $fields = $defs = $values = $serials = $placeholders = array();

  // Go through our schema, build SQL, and when inserting, fill in defaults for
  // fields that are not set.
  foreach ($schema['fields'] as $field => $info) {
    // Special case -- skip serial types if we are updating.
    if ($info['type'] == 'serial' && count($update)) {
      continue;
    }

    // For inserts, populate defaults from Schema if not already provided
    if (!isset($object->$field) && !count($update) && isset($info['default'])) {
      $object->$field = $info['default'];
    }

    // Track serial fields so we can helpfully populate them after the query.
    if ($info['type'] == 'serial') {
      $serials[] = $field;
      // Ignore values for serials when inserting data. Unsupported.
      unset($object->$field);
    }

    // Build arrays for the fields, placeholders, and values in our query.
    if (isset($object->$field) || array_key_exists($field, $object)) {
      $fields[] = $field;
      if (isset($object->$field)) {
        $placeholders[] = db_type_placeholder($info['type']);

        if (empty($info['serialize'])) {
          $values[] = $object->$field;
        }
        else {
          $values[] = serialize($object->$field);
        }
      }
      else {
        $placeholders[] = 'NULL';
      }
    }
  }

  // Build the SQL.
  $query = '';
  if (!count($update)) {
    $query = "INSERT INTO {". $table ."} (". implode(', ', $fields) .') VALUES ('. implode(', ', $placeholders) .')';
    $return = SAVED_NEW;
  }
  else {
    $query = '';
    foreach ($fields as $id => $field) {
      if ($query) {
        $query .= ', ';
      }
      $query .= $field .' = '. $placeholders[$id];
    }

    foreach ($update as $key) {
      $conditions[] = "$key = ". db_type_placeholder($schema['fields'][$key]['type']);
      $values[] = $object->$key;
    }

    $query = "UPDATE {". $table ."} SET $query WHERE ". implode(' AND ', $conditions);
    $return = SAVED_UPDATED;
  }

  // Execute the SQL.
  if (db_query($query, $values)) {
    if ($serials) {
      // Get last insert ids and fill them in.
      foreach ($serials as $field) {
        $object->$field = db_last_insert_id($table, $field);
      }
    }

    // If we began with an array, convert back so we don't surprise the caller.
    if ($array) {
      $object = (array) $object;
    }

    return $return;
  }

  return FALSE;
}

/**
 * Invoke a field hook.
 *
 * For each operation, both this function and _content_field_invoke_default() are
 * called so that the default database handling can occur.
 */
function _content_field_invoke($op, &$node, $teaser = NULL, $page = NULL) {
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  $field_types = _content_field_types();

  $return = array();
  foreach ($type['instances'] as $instance) {
    $field = field_instance_get_field($instance);
    $field_name = $field['field_name'];
    $items = isset($node->$field_name) ? $node->$field_name : array();

    // Make sure AHAH 'add more' button isn't sent to the fields for processing.
    unset($items[$field_name .'_add_more']);

    // TODO D7 : the $field should already have 'module'
    $module = $field_types[$field['type']]['module'];
    $function = $module .'_field';
    if (drupal_function_exists($function)) {
      $result = $function($op, $node, $instance, $items, $teaser, $page);
      if (is_array($result)) {
        $return = array_merge($return, $result);
      }
      else if (isset($result)) {
        $return[] = $result;
      }
    }
    // test for values in $items in case modules added items on insert
    if (isset($node->$field_name) || count($items)) {
      $node->$field_name = $items;
    }
  }
  return $return;
}

/**
 * Invoke content.module's version of a field hook.
 */
function _content_field_invoke_default($op, &$node, $teaser = NULL, $page = NULL) {
  $type_name = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  $type = content_types($type_name);
  $field_types = _content_field_types();

  $return = array();
  // The operations involving database queries are better off handled by table
  // rather than by field.
  if (in_array($op, array('load', 'insert', 'update', 'delete', 'delete revision'))) {
    return content_storage($op, $node);
  }
  else {
    foreach ($type['instances'] as $instance) {
      $field_name = $instance['field_name'];
      $items = isset($node->$field_name) ? $node->$field_name : array();
      $result = content_field($op, $node, $instance, $items, $teaser, $page);
      if (is_array($result)) {
        $return = array_merge($return, $result);
      }
      else if (isset($result)) {
        $return[] = $result;
      }
      if (isset($node->$field_name)) {
        $node->$field_name = $items;
      }
    }
  }
  return $return;
}

/**
 * Return a list of all content types.
 *
 * Do some type checking and set up empty arrays for missing
 * info to avoid foreach errors elsewhere in the code.
 *
 * @param $content_type_name
 *   If set, return information on just this type.
 */
function content_types($type_name = NULL) {
  // handle type name with either an underscore or a dash
  $type_name = !empty($type_name) ? str_replace('-', '_', $type_name) : NULL;

  $info = _content_type_info();
  if (isset($info['content types'])) {
    if (!isset($type_name)) {
      return $info['content types'];
    }
    if (isset($info['content types'][$type_name])) {
      return $info['content types'][$type_name];
    }
  }
  return array('tables' => array(), 'instances' => array());
}

/**
 * Return a list of all fields.
 *
 * @param $field_name
 *   If set, return information on just this field.
 * @param $content_type_name
 *   If set, return information of the field within the context of this content
 *   type.
 * @return
 *   An array of Field objects, a single Field object, or a
 *   FieldInstance object, depending on the arguments.  TODO: This is
 *   horrible; make it into separate functions.
 */
function content_fields($field_name = NULL, $content_type_name = NULL) {
  $info = _content_type_info();
  if (isset($info['fields'])) {
    if (empty($field_name)) {
      return $info['fields'];
    }
    if (isset($info['fields'][$field_name])) {
      if (empty($content_type_name)) {
        return $info['fields'][$field_name];
      }
      if (isset($info['content types'][$content_type_name]['instances'][$field_name])) {
        return $info['content types'][$content_type_name]['instances'][$field_name];
      }
    }
  }
}

/**
 * Return a list of field types.
 */
function _content_field_types() {
  $info = _content_type_info();
  return isset($info['field types']) ? $info['field types'] : array();
}

/**
 * Return a list of widget types.
 */
function _content_widget_types() {
  $info = _content_type_info();
  return isset($info['widget types']) ? $info['widget types'] : array();
}

/**
 * Return the formatter description corresponding to a formatter name,
 * defaulting to 'default' if none is found.
 */
function _content_get_formatter($formatter_name, $field_type) {
  $field_types = _content_field_types();
  $formatters = $field_types[$field_type]['formatters'];

  if (!isset($formatters[$formatter_name]) && $formatter_name != 'hidden') {
    // This might happen when the selected formatter has been renamed in the
    // module, or if the module has been disabled since then.
    $formatter_name = 'default';
  }

  return isset($formatters[$formatter_name]) ? $formatters[$formatter_name] : FALSE;
}

/**
 * Collate all information on content types, fields, and related structures.
 *
 * @param $reset
 *   If TRUE, clear the cache and fetch the information from the
 *   database again.
 * @return
 *   An array containing the following elements:
 *
 * field types: array of hook_field_info() results, keyed by field_type
 *   * label, description, and callbacks: from hook_field_info()
 *   * module: the module that exports the field type
 *   * formatters: array of formatters, keyed by formatter name
 *     * label, field types, multiple values: from hook_field_formatter_info
 *
 * widget types: array of hook_widget_info() results, keyed by widget_type
 *   * label, field types, multiple vlaues, callbacks: from hook_widget_info()
 *   * module: module that exports the widget type
 *
 * fields: array of all defined Field objects, keyed by field name
 *
 * content types: array of content type info, keyed by type_name
 *   * all fields from node_get_types()
 *   * url_str: type name for URLs, s/_/-/g
 *   * instances: array of all FieldInstance objects for this type,
 *     keyed by field name
 *   * tables: array of table names for fields, keyed by table name,
 *     in the same order as fields
 */
function _content_type_info($reset = FALSE) {
  static $info;

  if ($reset || !isset($info)) {
    // Make sure this function doesn't run until the tables have been created.
    // For instance: when first enabled and called from content_menu(),
    // or when uninstalled and some subsequent field module uninstall
    // attempts to refresh the data.
    // TODO D7 : make sure this is still needed...

    if (!$reset && $cached = cache_get('content_type_info', content_cache_tablename())) {
      $info = $cached->data;
    }
    else {
      $info = array(
        'field types' => array(),
        'widget types' => array(),
        'fields' => array(),
        'content types' => array(),
      );

      // Populate field types.
      foreach (module_implements('field_info') as $module) {
        $module_field_types = module_invoke($module, 'field_info');
        if ($module_field_types) {
          foreach ($module_field_types as $name => $field_info) {
            // Truncate names to match the value that is stored in the database.
            $db_name = substr($name, 0, 32);
            $info['field types'][$db_name] = $field_info;
            $info['field types'][$db_name]['module'] = $module;
            $info['field types'][$db_name]['formatters'] = array();
          }
        }
      }

      // Populate widget types and formatters for known field types.
      foreach (module_implements('widget_info') as $module) {
        if ($module_widgets = module_invoke($module, 'widget_info')) {
          foreach ($module_widgets as $name => $widget_info) {
            // Truncate names to match the value that is stored in the database.
            $db_name = substr($name, 0, 32);
            $info['widget types'][$db_name] = $widget_info;
            $info['widget types'][$db_name]['module'] = $module;
            // Replace field types with db_compatible version of known field types.
            $info['widget types'][$db_name]['field types'] = array();
            foreach ($widget_info['field types'] as $field_type) {
              $field_type_db_name = substr($field_type, 0, 32);
              if (isset($info['field types'][$field_type_db_name])) {
                $info['widget types'][$db_name]['field types'][] = $field_type_db_name;
              }
            }
          }
        }
      }

      foreach (module_implements('field_formatter_info') as $module) {
        if ($module_formatters = module_invoke($module, 'field_formatter_info')) {
          foreach ($module_formatters as $name => $formatter_info) {
            foreach ($formatter_info['field types'] as $field_type) {
              // Truncate names to match the value that is stored in the database.
              $db_name = substr($field_type, 0, 32);
              if (isset($info['field types'][$db_name])) {
                $info['field types'][$db_name]['formatters'][$name] = $formatter_info;
                $info['field types'][$db_name]['formatters'][$name]['module'] = $module;
              }
            }
          }
        }
      }

      module_load_include('inc', 'content', 'includes/content.crud');

      // Populate Fields.
      $info['fields'] = field_get_field(NULL);

      // Populate content types and field instances.
      foreach (node_get_types('types', NULL, TRUE) as $type_name => $data) {
        $type = (array) $data;
        $type['url_str'] = str_replace('_', '-', $type['type']);
        $type['instances'] = array();
        $type['tables'] = array();
        if ($instances = field_get_instances(array('type_name' => $type_name))) {
          foreach ($instances as $instance) {
            $type['instances'][$instance['field_name']] = $instance;
            $db_info = content_database_info($instance);
            $type['tables'][$db_info['table']] = $db_info['table'];
          }
          // Make sure the per-type table is added, even if no field is actually
          // stored in it.
      // TODO D7: remove ?
          $table = _content_tablename($type['type'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
          $type['tables'][$table] = $table;
        }

// TODO D7 : move to fields_ui - storage ?
//        // Gather information about non-CCK 'fields'.
//        $extra = module_invoke_all('content_extra_fields', $type_name);
//        drupal_alter('content_extra_fields', $extra, $type_name);
//        // Add saved weights.
//        foreach (variable_get('content_extra_weights_'. $type_name, array()) as $key => $value) {
//          // Some stored entries might not exist anymore, for instance if uploads
//          // have been disabled, or vocabularies removed...
//          if (isset($extra[$key])) {
//            $extra[$key]['weight'] = $value;
//          }
//        }
//        $type['extra'] = $extra;

        $info['content types'][$type_name] = $type;
      }

      cache_set('content_type_info', $info, content_cache_tablename());
    }
  }
  return $info;
}

/**
 *  Implementation of hook_node_type()
 */
function content_node_type($op, $info) {
  switch ($op) {
    case 'insert':
      module_load_include('inc', 'content', 'includes/content.crud');
      content_type_create($info);
      break;
    case 'update':
      module_load_include('inc', 'content', 'includes/content.crud');
      content_type_update($info);
      break;
    case 'delete':
      module_load_include('inc', 'content', 'includes/content.crud');
      content_type_delete($info);
      break;
  }
}

/**
 * Clear the cache of content_types; called in several places when content
 * information is changed.
 */
function content_clear_type_cache($rebuild_schema = FALSE) {
  cache_clear_all('*', content_cache_tablename(), TRUE);
  _content_type_info(TRUE);

  // Refresh the schema to pick up new information.
  if ($rebuild_schema) {
    $schema = drupal_get_schema(NULL, TRUE);
  }

  // XXX TODO: Call invoke hook_content_clear_type_cache()
  // for instance : refresh views data
}

/**
 * Retrieve the database storage location(s) for a field instance.
 *
 * TODO : add a word about why it's not included in the global
 * _content_type_info array.
 * TODO D7: Figure out why that really is; I suspect it can be, now.
 *
 * @param $field
 *   The field whose database information is requested.
 * @return
 *   An array with the keys:
 *     "table": The name of the database table where the field data is stored.
 *     "columns": An array of columns stored for this field. Each is a collection
 *       of information returned from hook_field_settings('database columns'),
 *       with the addition of a "column" attribute which holds the name of the
 *       database column that stores the data.
 */
function content_database_info($instance) {
  $db_info = array();

  // XXX I do not understand why this is necessary; CCK used to take
  // care to load content.crud.inc when necessary.  We should use the
  // code registry instead, but figure out why this is necessary.
  drupal_function_exists('field_instance_get_field');

  $field = field_instance_get_field($instance);
  if ($field['db_storage'] == CONTENT_DB_STORAGE_PER_FIELD) {
    $db_info['table'] = _content_tablename($field['field_name'], CONTENT_DB_STORAGE_PER_FIELD);
  }
  else {
    $db_info['table'] = _content_tablename($instance['type_name'], CONTENT_DB_STORAGE_PER_CONTENT_TYPE);
  }

  $db_info['columns'] = (array) $field['columns'];
  // Generate column names for this field from generic column names.
  foreach ($db_info['columns'] as $column_name => $attributes) {
    $db_info['columns'][$column_name]['column'] = $field['field_name'] .'_'. $column_name;
  }

  return $db_info;
}

/**
 * Helper function for identifying the storage type for a field.
 *
 * TODO: This should depend on 'shareable', not # of instances.
 */
function content_storage_type($field) {
  if ($field['multiple'] > 0 || $field['shareable']) {
    return CONTENT_DB_STORAGE_PER_FIELD;
  }
  return CONTENT_DB_STORAGE_PER_CONTENT_TYPE;
}

/**
 * Manipulate a 2D array to reverse rows and columns.
 *
 *  // TODO D7 : do we need this ?
 * The default data storage for fields is delta first, column names second.
 * This is sometimes inconvenient for field modules, so this function can be
 * used to present the data in an alternate format.
 *
 * @param $array
 *   The array to be transposed. It must be at least two-dimensional, and
 *   the subarrays must all have the same keys or behavior is undefined.
 * @return
 *   The transposed array.
 */
function content_transpose_array_rows_cols($array) {
  $result = array();
  if (is_array($array)) {
    foreach ($array as $key1 => $value1) {
      if (is_array($value1)) {
        foreach ($value1 as $key2 => $value2) {
          if (!isset($result[$key2])) {
            $result[$key2] = array();
          }
          $result[$key2][$key1] = $value2;
        }
      }
    }
  }
  return $result;
}

/**
 *  Create an array of the allowed values for this field.
 *
 *  // TODO D7 : do we need this ?
 *  Used by number and text fields, expects to find either
 *  PHP code that will return the correct value, or a string
 *  with keys and labels separated with '|' and with each
 *  new value on its own line.
 */
function content_allowed_values($field) {
  static $allowed_values;

  if (isset($allowed_values[$field['field_name']])) {
    return $allowed_values[$field['field_name']];
  }

  $allowed_values[$field['field_name']] = array();

  if (isset($field['allowed_values_php'])) {
    ob_start();
    $result = eval($field['allowed_values_php']);
    if (is_array($result)) {
      $allowed_values[$field['field_name']] = $result;
    }
    ob_end_clean();
  }

  if (empty($allowed_values[$field['field_name']]) && isset($field['allowed_values'])) {
    $list = explode("\n", $field['allowed_values']);
    $list = array_map('trim', $list);
    $list = array_filter($list, 'strlen');
    foreach ($list as $opt) {
      // Sanitize the user input with a permissive filter.
      $opt = content_filter_xss($opt);
      if (strpos($opt, '|') !== FALSE) {
        list($key, $value) = explode('|', $opt);
        $allowed_values[$field['field_name']][$key] = (isset($value) && $value !=='') ? $value : $key;
      }
      else {
        $allowed_values[$field['field_name']][$opt] = $opt;
      }
    }
  }
  return $allowed_values[$field['field_name']];
}

/**
 * Like filter_xss_admin(), but with a shorter list of allowed tags.
 *
 * TODO D7 : edge case - only needed by UI-defined fields.
 * Used for items entered by administrators, like field descriptions,
 * allowed values, where some (mainly inline) mark-up may be desired
 * (so check_plain() is not acceptable).
 */
function content_filter_xss($string) {
  return filter_xss($string, _content_filter_xss_allowed_tags());
}

/**
 * List of tags allowed by content_filter_xss().
 */
function _content_filter_xss_allowed_tags() {
  return array('a', 'b', 'big',  'code', 'del', 'em', 'i', 'ins',  'pre', 'q', 'small', 'span', 'strong', 'sub', 'sup', 'tt', 'ol', 'ul', 'li', 'p', 'br', 'img');
}

/**
 * Human-readable list of allowed tags, for display in help texts.
 */
function _content_filter_xss_display_allowed_tags() {
  return '<'. implode('> <', _content_filter_xss_allowed_tags()) .'>';
}

/**
 * Format a field item for display.
 *
 * TODO D7 : do we still need content_format ? might be worth refactoring a little...
 *
 * Used to display a field's values outside the context of the $node, as
 * when fields are displayed in Views, or to display a field in a template
 * using a different formatter than the one set up on the Display Fields tab
 * for the node's context.
 *
 * @param $field
 *   Either a field array or the name of the field.
 * @param $item
 *   The field item(s) to be formatted (such as $node->field_foo[0],
 *   or $node->field_foo if the formatter handles multiple values itself)
 * @param $formatter_name
 *   The name of the formatter to use.
 * @param $node
 *   Optionally, the containing node object for context purposes and
 *   field-instance options.
 *
 * @return
 *   A string containing the contents of the field item(s) sanitized for display.
 *   It will have been passed through the necessary check_plain() or check_markup()
 *   functions as necessary.
 */
function content_format($field, $item, $formatter_name = 'default', $node = NULL) {
  if (!is_array($field)) {
    $field = content_fields($field);
  }

  if ($formatter = _content_get_formatter($formatter_name, $field['type'])) {
    $theme = $formatter['module'] .'_formatter_'. $formatter_name;

    $element = array(
      '#theme' => $theme,
      '#field_name' => $field['field_name'],
      '#type_name' => isset($node->type) ? $node->type :'',
      '#formatter' => $formatter_name,
      '#node' => $node,
      '#delta' => isset($item['#delta']) ? $item['#delta'] : NULL,
    );

    if (content_handle_formatter('multiple values', $formatter) == CONTENT_HANDLE_CORE) {
      // Single value formatter.

      // hook_field('sanitize') expects an array of items, so we build one.
      $items = array($item);
      $function = $field['module'] .'_field';
      if (function_exists($function)) {
        $function('sanitize', $node, $field, $items, FALSE, FALSE);
      }

      $element['#item'] = $items[0];
    }
    else {
      // Multiple values formatter.
      $items = $item;
      $function = $field['module'] .'_field';
      if (function_exists($function)) {
        $function('sanitize', $node, $field, $items, FALSE, FALSE);
      }

      foreach ($items as $delta => $item) {
        $element[$delta] = array(
          '#item' => $item,
          '#weight' => $delta,
        );
      }
    }

    return theme($theme, $element);
  }
}

/**
 * TODO D7: really belongs to field.modle ?
 * Registry of available node build modes.
 *
 * @param $selector
 *   Determines what information should be returned.
 * @return
 *   Depending on the value of the $selector parameter:
 *   - NULL: a flat list of all available build modes.
 *   The other two options are mainly used internally by CCK's UI:
 *   - '_tabs': the list of tabs to be shown on the 'Display fields' screens.
 *   - a string tab id: the build modes in this tab.
 */
function content_build_modes($selector = NULL) {
  static $info;

  if (!isset($info)) {
    $data = module_invoke_all('content_build_modes');
    $flat = array();
    foreach ($data as $tab) {
      // Use the + operator to preserve numeric indexes (core build modes).
      $flat += (array) $tab['build modes'];
    }
    $info = array('tabs' => $data, 'build modes' => $flat);
  }

  if ($selector === '_tabs') {
    return $info['tabs'];
  }
  elseif (isset($selector) && isset($info['tabs'][$selector])) {
    return isset($info['tabs'][$selector]) ? $info['tabs'][$selector]['build modes'] : array();
  }
  else {
    return $info['build modes'];
  }
}

/**
 * Implementations of hook_content_build_modes
 * on behalf of core modules.
 *
 * @return
 * An array describing the build modes used by the module.
 * They are grouped by secondary tabs on CCK's 'Display fields' screens.
 *
 * Expected format:
 * array(
 *   // The first level keys (tab1_url, tab2_url) will be used to generate
 *   // the url of the tab: admin/content/node-type/[type_name]/display/[tab1_url]
 *   // A module can add its render modes to a tab defined by another module.
 *   // In this case, there's no need to provide a 'title' for this tab.
 *   'tab1_url' => array(
 *     'title' => t('The human-readable title of the tab'),
 *     'build modes' => array(
 *       // The keys of the 'context' array are the values used in $node->build_mode.
 *       'mymodule_mode1' => array(
 *         'title' => t('The human-readable name of the build mode'),
 *        // The 'views style' property determines if the render mode should be
 *        // available as an option in Views' 'node' row style (not implemented yet).
 *        'views style' => TRUE,
 *       ),
 *       'mymodule_mode2' => array(
 *         'title' => t('Mode 2'),
 *         'views style' => TRUE,
 *       ),
 *     ),
 *   ),
 *   'tab2_url' => array(
 *     // ...
 *   ),
 * );
 */
function node_content_build_modes() {
  return array(
    'basic' => array(
      'title' => t('Basic'),
      'build modes' => array(
        'teaser' => array(
          'title' => t('Teaser'),
          'views style' => TRUE,
        ),
        'full' => array(
          'title' => t('Full node'),
          'views style' => TRUE,
        ),
      ),
    ),
    'rss' => array(
      'title' => t('RSS'),
      'build modes' => array(
        NODE_BUILD_RSS => array(
          'title' => t('RSS'),
          'views style' => FALSE,
        ),
      ),
    ),
  );
}
function search_content_build_modes() {
  return array(
    'search' => array(
      'title' => t('Search'),
      'build modes' => array(
        NODE_BUILD_SEARCH_INDEX => array(
          'title' => t('Search Index'),
          'views style' => FALSE,
        ),
        NODE_BUILD_SEARCH_RESULT => array(
          'title' => t('Search Result'),
          'views style' => FALSE,
        ),
      ),
    ),
  );
}

/**
 * Generate a table name for a field or a content type.
 *
 * @param $name
 *   The name of the content type or content field
 * @param $storage
 *   CONTENT_DB_STORAGE_PER_FIELD or CONTENT_DB_STORAGE_PER_CONTENT_TYPE
 * @return
 *   A string containing the generated name for the database table
 */
function _content_tablename($name, $storage) {
  // TODO D7 : table names rehaul...
  $name = str_replace('-', '_', $name);
  return ($storage == CONTENT_DB_STORAGE_PER_CONTENT_TYPE) ? "content_type_$name" : "content_$name";
}

/**
 * Generate table name for the content field table.
 *
 * Needed because the table name changes depending on version.
 * Using 'content_node_field' instead of 'content_field'
 * to avoid conflicts with field tables that will be prefixed
 * with 'content_field'.
 */
function content_field_tablename($version = NULL) {
  // TODO D7 : remove
  return 'content_node_field';
}

/**
 * Generate table name for the content field instance table.
 *
 * Needed because the table name changes depending on version.
 */
function content_instance_tablename($version = NULL) {
  // TODO D7 : remove
  return 'content_node_field_instance';
}

/**
 * Generate table name for the content cache table.
 */
function content_cache_tablename() {
  // TODO D7 : remove
  return 'cache_content';
}

/**
 * A basic schema used by all field and type tables.
 *
 * This will only add the columns relevant for the specified field.
 * Leave $field['columns'] empty to get only the base schema,
 * otherwise the function will return the whole thing.
 */
function content_table_schema($field = NULL) {
  $schema = array(
    'fields' => array(
      'vid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),
      'nid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0)
    ),
    'primary key' => array('vid'),
    'indexes' => array(
      'nid'    => array('nid'),
    ),
  );

  // Add delta column if needed.
  if (!empty($field['multiple'])) {
    $schema['fields']['delta'] = array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0);
    $schema['primary key'][] = 'delta';
  }
  $schema['content fields'] = array();

  // Add field columns column if needed.
  // This function is called from install files where it is not safe
  // to use content_fields() or content_database_info(), so we
  // just used the column values stored in the $field.
  // We also need the schema to include fields from disabled modules
  // or there will be no way to delete those fields.

  if (!empty($field['columns'])) {
    foreach ($field['columns'] as $column => $attributes) {
      $column_name =  $field['field_name'] .'_'. $column;
      unset($attributes['column']);
      unset($attributes['sortable']);
      $schema['fields'][$column_name] = $attributes;
    }
    $schema['content fields'][] = $field['field_name'];
  }
  return $schema;
}

/**
 * TODO D7: check what is actually needed here
 *  Helper function for determining the behavior of a field
 *  with respect to a given operation.
 *
 *  @param $op
 *    the name of the operation, must be 'view'
 *  @param $field
 *    The field array.
 *  @return
 *    CONTENT_CALLBACK_NONE    - do nothing for this operation
 *    CONTENT_CALLBACK_CUSTOM  - use the module's callback function.
 *    CONTENT_CALLBACK_DEFAULT - use content module default behavior
 */
function content_field_callback($op, $field) {
  $info = module_invoke($field['module'], "field_info");
  return isset($info[$field['type']]['callbacks'][$op]) ? $info[$field['type']]['callbacks'][$op] : CONTENT_CALLBACK_DEFAULT;
}

/**
 *  Helper function for determining the behavior of a field instance
 *  with respect to a given operation.
 *
 *  @param $op
 *    the name of the operation, must be 'default value' or 'multiple values'
 *  @param $instance
 *    The field instance array.
 *  @return
 *    CONTENT_CALLBACK_NONE    - do nothing for this operation
 *    CONTENT_CALLBACK_CUSTOM  - use the module's callback function.
 *    CONTENT_CALLBACK_DEFAULT - use content module default behavior
 */
function content_instance_callback($op, $instance) {
  $info = module_invoke($instance['widget']['module'], "widget_info");
  return isset($info[$instance['widget']['type']]['callbacks'][$op]) ? $info[$instance['widget']['type']]['callbacks'][$op] : CONTENT_CALLBACK_DEFAULT;
}

/**
 *  Helper function for determining the handling of a field.
 *
 *  @param $op
 *    the name of the operation ('default values'...)
 *  @param $field
 *    the field array
 *  @return
 *    CONTENT_HANDLE_CORE    - the content module handles this operation.
 *    CONTENT_HANDLE_MODULE  - the implementing module handles this operation.
 */
function content_handle_field($op, $field) {
  $info = module_invoke($field['module'], "field_info");
  return isset($info[$field['type']][$op]) ? $info[$field['type']][$op] : CONTENT_HANDLE_CORE;
}

/**
 *  Helper function for determining the handling of a field instance.
 *
 *  @param $op
 *    the name of the operation ('multiple values'...)
 *  @param $instance
 *    the field instance array
 *  @return
 *    CONTENT_HANDLE_CORE    - the content module handles this operation.
 *    CONTENT_HANDLE_MODULE  - the implementing module handles this operation.
 */
function content_handle_instance($op, $instance) {
  $info = module_invoke($instance['widget']['module'], "widget_info");
  return isset($info[$instance['widget']['type']][$op]) ? $info[$instance['widget']['type']][$op] : CONTENT_HANDLE_CORE;
}

/**
 *  Helper function for determining the handling of a formatter.
 *
 *  @param $op
 *    the name of the operation ('multiple values'...)
 *  @param $formatter
 *    the formatter array
 *  @return
 *    CONTENT_HANDLE_CORE    - the content module handles this operation.
 *    CONTENT_HANDLE_MODULE  - the implementing module handles this operation.
 */
function content_handle_formatter($op, $formatter) {
  // Much simpler, formatters arrays *are* the 'formatter_info' itself.
  // We let content_handle deal with them only for code consistency.
  return isset($formatter[$op]) ? $formatter[$op] : CONTENT_HANDLE_CORE;
}

/**
 *  Helper function to return the correct default value for a field.
 *
 *  @param $node
 *    The node.
 *  @param $field
 *    The field array.
 *  @param $items
 *    The value of the field in the node.
 *  @return
 *    The default value for that field.
 */
function content_default_value(&$form, &$form_state, $field, $delta) {
  $widget_types = _content_widget_types();
  $module = $widget_types[$field['widget']['type']]['module'];

  $default_value = array();
  if (!empty($field['widget']['default_value_php'])) {
    ob_start();
    $result = eval($field['widget']['default_value_php']);
    ob_end_clean();
    if (is_array($result)) {
      $default_value = $result;
    }
  }
  elseif (!empty($field['widget']['default_value'])) {
    $default_value = $field['widget']['default_value'];
  }
  return (array) $default_value;
}

/**
/**
 * Theme preprocess function for field.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $node
 * - $field
 * - $items
 * - $teaser
 * - $page
 *
 * @see field.tpl.php
 *
 * TODO : this should live in theme/theme.inc, but then the preprocessor
 * doesn't get called when the theme overrides the template. Bug in theme layer ?
 */
 // TODO D7: content_preprocess_ or template_preprocess_ ?
function content_preprocess_content_field(&$variables) {
  $element = $variables['element'];
  $instance = content_fields($element['#field_name'], $element['#node']->type);
  $field = field_instance_get_field($instance);

  $variables['node'] = $element['#node'];
  $variables['field'] = $field;
  $variables['instance'] = $instance;
  $variables['items'] = array();

  if ($element['#single']) {
    // Single value formatter.
    foreach (element_children($element['items']) as $delta) {
      $variables['items'][$delta] = $element['items'][$delta]['#item'];
      // Use isset() to avoid undefined index message on #children when field values are empty.
      $variables['items'][$delta]['view'] = isset($element['items'][$delta]['#children']) ? $element['items'][$delta]['#children'] : '';
    }
  }
  else {
    // Multiple values formatter.
    // We display the 'all items' output as $items[0], as if it was the
    // output of a single valued field.
    // Raw values are still exposed for all items.
    foreach (element_children($element['items']) as $delta) {
      $variables['items'][$delta] = $element['items'][$delta]['#item'];
    }
    $variables['items'][0]['view'] = $element['items']['#children'];
  }

  $variables['teaser'] = $element['#teaser'];
  $variables['page'] = $element['#page'];

  $field_empty = TRUE;

  foreach ($variables['items'] as $delta => $item) {
    if (!isset($item['view']) || (empty($item['view']) && (string)$item['view'] !== '0')) {
      $variables['items'][$delta]['empty'] = TRUE;
    }
    else {
      $field_empty = FALSE;
      $variables['items'][$delta]['empty'] = FALSE;
    }
  }

  $additions = array(
    'field_type' => $field['type'],
    'field_name' => $field['field_name'],
    'field_type_css' => strtr($field['type'], '_', '-'),
    'field_name_css' => strtr($field['field_name'], '_', '-'),
    'label' => check_plain(t($instance['widget']['label'])),
    'label_display' => $element['#label_display'],
    'field_empty' => $field_empty,
    'template_files' => array(
      'content-field',
      'content-field-'. $element['#field_name'],
      'content-field-'. $element['#node']->type,
      'content-field-'. $element['#field_name'] .'-'. $element['#node']->type,
    ),
  );
  $variables = array_merge($variables, $additions);
}

/**
 * Theme preprocess function for node.
 *
 * - Adds $FIELD_NAME_rendered variables
 *   containing the themed output for the whole field.
 * - Adds the formatted values in the 'view' key of the items.
 */
function content_preprocess_node(&$vars) {
  $additions = _content_field_invoke_default('preprocess_node', $vars['node']);
  $vars = array_merge($vars, $additions);
}

// TODO D7: needed ?
/**
 * Helper function to identify inactive fields.
 */
function content_inactive_fields($type_name = NULL) {
//  module_load_include('inc', 'content', 'includes/content.crud');
//  if (!empty($type_name)) {
//    $param = array('type_name' => $type_name);
//    $inactive = array($type_name => array());
//  }
//  else {
//    $param = array();
//    $inactive = array();
//  }
//  $all = content_field_instance_read($param, TRUE);
//  $active = array_keys(content_fields());
//  foreach ($all as $field) {
//    if (!in_array($field['field_name'], $active)) {
//      $inactive[$field['type_name']][$field['field_name']] = content_field_instance_expand($field);
//    }
//  }
//  if (!empty($type_name)) {
//    return $inactive[$type_name];
//  }
//  return $inactive;
}
