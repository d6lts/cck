<?php
// $Id$

/**
 * @file
 * Create field groups for CCK fields.
 *
 * New combo group treats all included fields as a single combo field,
 * keeping the related delta values of all included fields synchronized.
 * 
 * To use the combo group, create a new group, make it the 'Combo' type,
 * set the number of multiple values for all the fields in the combo
 * group, and drag into it the fields that should be included.
 * 
 * All fields in the combo group will automatically get the group
 * setting for multiple values. On the node form, the group is rearranged
 * to keep the delta values for each field in a single drag 'n drop group,
 * by transposing the normal array(field_name => delta => value) into
 * array(delta => field_name => value).
 * 
 * During validation and submission, the field values are restored to
 * their normal positions.
 * 
 * The combo group behaves exactly the same as a normal group
 * in node displays, only the node form is different.
 * 
 * TODO
 * 
 * May need to limit this to specific fields that are known to work
 * correctly and add validation and warning if other fields are added.
 * 
 * Need to get the AHAH add more button working to create a new delta
 * collection of all the group's fields.
 * 
 * Lots of validation. Dragging fields with data into and out of the
 * group can cause loss of data since the field's multiple value setting
 * will be changed.
 */
/**
 * Implementation of hook_init().
 */
function fieldgroup_init() {
  drupal_add_css(drupal_get_path('module', 'fieldgroup') .'/fieldgroup.css');
  if (module_exists('panels')) {
    module_load_include('inc', 'fieldgroup', 'fieldgroup.panels');
  }
}

/**
 * Implementation of hook_menu().
 */
function fieldgroup_menu() {
  $items = array();

  // Make sure this doesn't fire until content_types is working,
  // needed to avoid errors on initial installation.
  if (!defined('MAINTENANCE_MODE')) {
    foreach (node_get_types() as $type) {
      $type_name = $type->type;
      $content_type = content_types($type_name);
      $type_url_str = $content_type['url_str'];
      $items['admin/content/node-type/'. $type_url_str .'/groups/%'] = array(
        'title' => 'Edit group',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('fieldgroup_group_edit_form', $type_name, 5),
        'access arguments' => array('administer content types'),
        'type' => MENU_CALLBACK,
      );
      $items['admin/content/node-type/'. $type_url_str .'/groups/%/remove'] = array(
        'title' => 'Edit group',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('fieldgroup_remove_group', $type_name, 5),
        'access arguments' => array('administer content types'),
        'type' => MENU_CALLBACK,
      );
    }
  }
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function fieldgroup_theme() {
  return array(
    'fieldgroup_simple' => array(
      'template' => 'fieldgroup',
      'arguments' => array('element' => NULL),
    ),
    'fieldgroup_fieldset' => array(
      'arguments' => array('element' => NULL),
    ),
    'fieldgroup_display_overview_form' => array(
      'arguments' => array('form' => NULL),
    ),
    'fieldgroup_multiple_values' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implementation of hook_elements().
 */
function fieldgroup_elements() {
  return array(
    'fieldgroup_simple' => array(),
    'fieldgroup_fieldset' => array('#collapsible' => FALSE, '#collapsed' => FALSE, '#value' => NULL,),
  );
}

/**
 * Implementation of hook_fieldapi().
 */
function fieldgroup_content_fieldapi($op, $field) {
  switch ($op) {
    case 'delete':
      db_query("DELETE FROM {". fieldgroup_fields_tablename() ."} WHERE field_name = '%s'", $field['field_name']);
      break;
  }
  cache_clear_all('fieldgroup_data', content_cache_tablename());
}

function fieldgroup_group_edit_form(&$form_state, $type_name, $group_name) {
  $content_type = content_types($type_name);
  $groups = fieldgroup_groups($content_type['type']);

  if (!$group = $groups[$group_name]) {
    drupal_not_found();
    exit;
  }

  $form['label'] = array(
    '#type' => 'textfield',
    '#title' => t('Label'),
    '#default_value' => $group['label'],
    '#required' => TRUE,
  );
  $form['settings']['#tree'] = TRUE;
  $form['settings']['form'] = array(
    '#type' => 'fieldset',
    '#title' => t('Form settings'),
    '#description' => t('These settings apply to the group in the node editing form.'),
  );
  $form['settings']['form']['style'] = array(
    '#type' => 'radios',
    '#title' => t('Style'),
    '#default_value' => $group['settings']['form']['style'],
    '#options' => array(
      'fieldset' => t('always open'),
      'fieldset_collapsible' => t('collapsible'),
      'fieldset_collapsed' => t('collapsed'),
    )
  );
  $form['settings']['form']['description'] = array(
    '#type' => 'textarea',
    '#title' => t('Help text'),
    '#default_value' => $group['settings']['form']['description'],
    '#rows' => 5,
    '#description' => t('Instructions to present to the user on the editing form.'),
    '#required' => FALSE,
  );
  $form['settings']['display'] = array(
    '#type' => 'fieldset',
    '#title' => t('Display settings'),
    '#description' => t('These settings apply to the group on node display.'),
  );
  $form['settings']['display']['description'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $group['settings']['display']['description'],
    '#rows' => 5,
    '#description' => t('A description of the group.'),
    '#required' => FALSE,
  );
  module_load_include('inc', 'content', 'includes/content.admin');
  module_load_include('inc', 'content', 'includes/content.crud');
  foreach (array_merge(array_keys(_content_admin_display_contexts()), array('label')) as $key) {
    $form['settings']['display'][$key] = array('#type' => 'value', '#value' => $group['settings']['display'][$key]);
  }
  $form['settings']['combo'] = array(
    '#type' => 'fieldset',
    '#title' => t('Group type settings'),
    '#description' => t('Choose whether this is a standard or combo group. The fields in a standard group are independent of each other and have separate settings for multiple values. The fields in a combo group are treated as a single combined field with the same number of values.'),
  );
  $form['settings']['combo']['is_combo'] = array(
    '#type' => 'select',
    '#title' => t('Type of group'),
    '#options' => fieldgroup_types(),
    '#default_value' => isset($group['settings']['combo']['is_combo']) ? $group['settings']['combo']['is_combo'] : 0,
  );
  $description = t('Maximum number of values users can enter for combo fields. ');
  $description .= '<br/>'. t("'Unlimited' will provide an 'Add more' button so the users can add as many values as they like.");
  $description .= '<p class="error">'. t('Warning! This will limit will be applied to all fields in this group. Reducing the number of values after data has been created will result in the loss of data!') .'</p>';
  $form['settings']['combo']['multiple'] = array(
    '#type' => 'select',
    '#title' => t('Number of combo values'),
    '#options' => array('' => t('N/A'), 1 => t('Unlimited'), 0 => 1) + drupal_map_assoc(range(2, 10)),
    '#default_value' => isset($group['settings']['combo']['multiple']) ? $group['settings']['combo']['multiple'] : '',
    '#description' => $description,
  );

  $form['weight'] = array('#type' => 'hidden', '#default_value' => $group['weight']);
  $form['group_name'] = array('#type' => 'hidden', '#default_value' => $group_name);

  $form['#content_type'] = $content_type;

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 10,
  );

  return $form;
}

function fieldgroup_group_edit_form_validate($form, &$form_state) {
  $form_values = $form_state['values'];
  if (!$form_values['settings']['combo']['is_combo']) {
    return;
  }
  // Make sure we don't set the multiple values to a number that
  // would result in lost data.
  $content_type = $form['#content_type'];
  $groups = fieldgroup_groups($content_type['type']);
  $group = $groups[$form_values['group_name']];
  foreach ($group['fields'] as $field_name => $data) {
    $max_existing = content_max_delta($field_name, $content_type['type']);
    if ($max_existing > $form_values['settings']['combo']['multiple']) {
      form_set_error('settings][combo][multiple', t('The content type %type already has %multiple multiple values in the database, you cannot set the number of combo values to less than this or you would risk losing data.', array('%type' => $content_type['label'], '%multiple' => $max_existing)));
    }
  }
}

function fieldgroup_group_edit_form_submit($form, &$form_state) {
  $form_values = $form_state['values'];
  $content_type = $form['#content_type'];

  fieldgroup_save_group($content_type['type'], $form_values);
  $form_state['redirect'] = 'admin/content/node-type/'. $content_type['url_str'] .'/fields';
}

function fieldgroup_remove_group(&$form_state, $type_name, $group_name) {
  $content_type = content_types($type_name);
  $groups = fieldgroup_groups($content_type['type']);
  $group = isset($groups[$group_name]) ? $groups[$group_name] : '';

  if (empty($group)) {
    drupal_not_found();
    exit;
  }

  $form['#submit'][] = 'fieldgroup_remove_group_submit';
  $form['#content_type'] = $content_type;
  $form['#group_name'] = $group_name;

  return confirm_form($form,
                  t('Are you sure you want to remove the group %label?',
                  array('%label' => t($group['label']))),
                  'admin/content/node-type/'. $content_type['url_str'] .'/fields', t('This action cannot be undone.'),
                  t('Remove'), t('Cancel'));
}

function fieldgroup_remove_group_submit($form, &$form_state) {
  $form_values = $form_state['values'];
  $content_type = $form['#content_type'];
  $group_name = $form['#group_name'];
  fieldgroup_delete($content_type['type'], $group_name);
  drupal_set_message(t('The group %group_name has been removed.', array('%group_name' => $group_name)));
  $form_state['redirect'] = 'admin/content/node-type/'. $content_type['url_str'] .'/fields';
}

/*
 * Returns all groups for a content type
 */
function fieldgroup_groups($content_type = '', $sorted = FALSE, $reset = FALSE) {
  static $groups, $groups_sorted;
  if (!isset($groups) || $reset) {
    if ($cached = cache_get('fieldgroup_data', content_cache_tablename())) {
      $data = $cached->data;
      $groups = $data['groups'];
      $groups_sorted = $data['groups_sorted'];
    }
    else {
      $result = db_query("SELECT * FROM {". fieldgroup_tablename() ."} ORDER BY weight, group_name");
      $groups = array();
      $groups_sorted = array();
      while ($group = db_fetch_array($result)) {
        $group['settings'] = unserialize($group['settings']);
        $group['fields'] = array();
        $groups[$group['type_name']][$group['group_name']] = $group;
        $groups_sorted[$group['type_name']][] = &$groups[$group['type_name']][$group['group_name']];
      }
      //load fields
      $result = db_query("SELECT nfi.*, ng.group_name FROM {". fieldgroup_tablename() ."} ng ".
 "INNER JOIN {". fieldgroup_fields_tablename() ."} ngf ON ngf.type_name = ng.type_name AND ngf.group_name = ng.group_name ".
 "INNER JOIN {". content_instance_tablename() ."} nfi ON nfi.field_name = ngf.field_name AND nfi.type_name = ngf.type_name ".
 "WHERE nfi.widget_active = 1 ORDER BY nfi.weight");
      while ($field = db_fetch_array($result)) {
        $groups[$field['type_name']][$field['group_name']]['fields'][$field['field_name']] = $field;
      }
      cache_set('fieldgroup_data', array('groups' => $groups, 'groups_sorted' => $groups_sorted), content_cache_tablename());
    }
  }
  if (empty($content_type)) {
    return $groups;
  }
  elseif (empty($groups) || empty($groups[$content_type])) {
    return array();
  }
  return $sorted ? $groups_sorted[$content_type] : $groups[$content_type];
}


function _fieldgroup_groups_label($content_type) {
  $groups = fieldgroup_groups($content_type);

  $labels[''] = '<'. t('none') .'>';
  foreach ($groups as $group_name => $group) {
    $labels[$group_name] = t($group['label']);
  }
  return $labels;
}

function _fieldgroup_field_get_group($content_type, $field_name) {
  return db_result(db_query("SELECT group_name FROM {". fieldgroup_fields_tablename() ."} WHERE type_name = '%s' AND field_name = '%s'", $content_type, $field_name));
}

/**
 * Implementation of hook_form_alter()
 */
function fieldgroup_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {
    foreach (fieldgroup_groups($form['type']['#value']) as $group_name => $group) {
      $form[$group_name] = array(
        '#type' => 'fieldset',
        '#title' => check_plain(t($group['label'])),
        '#collapsed' => $group['settings']['form']['style'] == 'fieldset_collapsed',
        '#collapsible' => in_array($group['settings']['form']['style'], array('fieldset_collapsed', 'fieldset_collapsible')),
        '#weight' => $group['weight'],
        '#description' => content_filter_xss(t($group['settings']['form']['description'])),
        '#attributes' => array('class' => strtr($group['group_name'], '_', '-')),
      );

      $has_accessible_field = FALSE;
      foreach ($group['fields'] as $field_name => $field) {
        if (isset($form[$field_name])) {
          $form[$group_name][$field_name] = $form[$field_name];
          // Track whether this group has any accessible fields within it.
          if (!isset($form[$field_name]['#access']) || $form[$field_name]['#access'] !== FALSE) {
            $has_accessible_field = TRUE;
          }
          unset($form[$field_name]);
        }
      }
      if (!empty($group['fields']) && !element_children($form[$group_name])) {
        //hide the fieldgroup, because the fields are hidden too
        unset($form[$group_name]);
      }

      if (!$has_accessible_field) {
        // Hide the fieldgroup, because the fields are inaccessible.
        $form[$group_name]['#access'] = FALSE;
      }
      // If this is a combo group, alter it.
      if (!empty($group['settings']['combo']) && !empty($group['settings']['combo']['is_combo'])) {
//       if (!empty($group['settings']['combo']['is_combo'])) {
        fieldgroup_combo_form($form, $form_state, $form_id, $group);
      }
    }

  }
  // The group is only added here so it will appear in the export
  // when using Content Copy.
  elseif ($form_id == 'content_field_edit_form' && isset($form['widget'])) {
    $content_type = content_types($form['type_name']['#value']);
    $groups = fieldgroup_groups($content_type['type']);
    $group_name = _fieldgroup_field_get_group($content_type['type'], $form['field_name']['#value']);
    $group = isset($groups[$group_name]) ? $groups[$group_name] : array();
    $form['widget']['group'] = array(
      '#type' => 'value',
      '#value' => _fieldgroup_field_get_group($content_type['type'], $form['field_name']['#value']),
    );
    // If this field is in a combo group, override the multiple value settings.
    if (!empty($group) && !empty($group['settings']['combo']['is_combo'])) {
      $form['field']['multiple']['#value'] = $group['settings']['combo']['multiple'];
      $form['field']['multiple']['#access'] = FALSE;
    }
  }
  elseif ($form_id == 'content_field_overview_form') {
    $form['#validate'][] = 'fieldgroup_field_overview_form_validate';
    $form['#submit'][] = 'fieldgroup_field_overview_form_submit';
  }
  elseif ($form_id == 'content_display_overview_form' && !empty($form['#groups'])) {
    $form['#submit'][] = 'fieldgroup_display_overview_form_submit';
    if (!isset($form['submit'])) {
      $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 10);
    }
  }
  elseif ($form_id == 'content_field_remove_form') {
    $form['#submit'][] = 'fieldgroup_field_remove_form_submit';
  }
}

function fieldgroup_field_overview_form_validate($form, &$form_state) {
  $form_values = $form_state['values'];
  $group = $form_values['_add_new_group'];

  if (array_filter(array($group['label'], $group['group_name']))) {
    // No label.
    if (!$group['label']) {
      form_set_error('_add_new_group][label', t('Add new group: you need to provide a label.'));
    }

    // No group name.
    if (!$group['group_name']) {
      form_set_error('_add_new_group][group_name', t('Add new group: you need to provide a group name.'));
    }
    // Group name validation.
    else {
      $group_name = $group['group_name'];

      // Add the 'group_' prefix.
      if (substr($group_name, 0, 6) != 'group_') {
        $group_name = 'group_'. $group_name;
        form_set_value($form['_add_new_group']['group_name'], $group_name, $form_state);
      }

      // Invalid field name.
      if (!preg_match('!^group_[a-z0-9_]+$!', $group_name)) {
        form_set_error('_add_new_group][group_name', t('Add new group: the group name %group_name is invalid. The name must include only lowercase unaccentuated letters, numbers, and underscores.', array('%group_name' => $group_name)));
      }
      if (strlen($group_name) > 32) {
        form_set_error('_add_new_group][group_name', t('Add new group: the group name %group_name is too long. The name is limited to 32 characters, including the \'group_\' prefix.', array('%group_name' => $group_name)));
      }

      // Group name already exists.
      $used = FALSE;
      $groups = fieldgroup_groups();
      foreach ($groups as $type => $groups_per_type) {
        foreach ($groups_per_type as $existing_group) {
          $used |= ($existing_group['group_name'] == $group_name);
        }
      }
      if ($used) {
        form_set_error('_add_new_group][group_name', t('Add new group: the group name %group_name already exists.', array('%group_name' => $group_name)));
      }
    }
  }
  else {
    // Fail validation if attempt to nest fields under a new group without the
    // proper information. Not raising an error would cause the nested fields
    // to get weights the user doesn't expect.
    
    foreach ($form_values as $key => $values) {
      if ($values['parent'] == '_add_new_group') {
        form_set_error('_add_new_group][label', t('Add new group: you need to provide a label.'));
        form_set_error('_add_new_group][group_name', t('Add new group: you need to provide a group name.'));
        break;
      }
    }
  }
  
  // See if we have fields moving into or out of a combo group.
  $fields = array();
  $groups = array();
  foreach ($form_values as $key => $values) {
    if (!empty($form[$key]['#row_type']) && $form[$key]['#row_type'] == 'group') {
      // Gather up info about all groups.
      $groups[$key] = $form_values[$key]['group'];
    }
    if (!empty($form[$key]['#row_type']) && $form[$key]['#row_type'] == 'field') {
      if ($values['prev_parent'] != $values['parent']) {
        // Gather up fields that have moved in or out of a group.
        $fields[$key] = $form_values[$key]['field'];  
      }
    }
  }
    
  // TODO Add other validation here to prevent moving fields that
  // won't work in combo groups from being added to them.
    
  if (!empty($fields)) {
    foreach ($fields as $field_name => $field) {
      $new_group = $form_values[$field_name]['parent'];
      $old_group = $form_values[$field_name]['prev_parent'];
      if ($groups[$new_group]['settings']['combo']['is_combo']) {
        $content_type = content_types($form_values['type_name']);
        $max_existing = content_max_delta($field_name, $content_type['type']);
        if ($max_existing > $groups[$new_group]['settings']['combo']['multiple']) {
          form_set_error($field_name, t('You are moving the field %field, which already has %multiple values, into a combo group with fewer multiple values. You would lose data if you made this change.', array('%field' => $field['widget']['label'], '%multiple' => $max_existing)));  
        }
        else {
          drupal_set_message(t('You are moving %field into a combo group.', array('%field' => $field['widget']['label'])));
        }
      }
      elseif ($groups[$old_group]['settings']['combo']['is_combo']) {
        drupal_set_message(t('You are moving %field out of a combo group.', array('%field' => $field['widget']['label'])));  
      }
    }
  }
}

/**
 * Align the delta values of each field in the combo group.
 * 
 * Swap the field name and delta for each combo group so we can 
 * d-n-d each collection of fields as a single delta item.
 */
function fieldgroup_combo_form(&$form, &$form_state, $form_id, $group) {
  $fields = $group['fields'];
  $content_fields = content_fields();
  $group_name = $group['group_name'];
  $max = $group['settings']['combo']['multiple'];

  $form[$group_name]['#theme'] = 'fieldgroup_multiple_values';
  $form[$group_name]['#multiple'] = !empty($max);
  $form[$group_name]['#group_name'] = $group_name;
  $form[$group_name]['#group_label'] = $group['label'];
  $form[$group_name]['#element_validate'] = array('fieldgroup_combo_form_validate');
  $form[$group_name]['#tree'] = TRUE;
      
  for ($delta = 0; $delta < $max; $delta++) {
    foreach ($fields as $field_name => $field) {
      // Transfer the delta value of the field to the group delta.
      $form[$group_name][$delta][$field_name] = isset($form[$group_name][$field_name][$delta]) ? $form[$group_name][$field_name][$delta] : NULL;

      // Transfer attributes of the field to the new field location.
      foreach ($form[$group_name][$field_name] as $key => $value) {
        if (!is_numeric($key)) {
          $form[$group_name][$delta][$field_name][$key] = $value;
        }
      }
      
      // Each individual field should be a single value item.
      $form[$group_name][$delta][$field_name]['#multiple'] = FALSE;
      
      if (isset($form[$group_name][$field_name][$delta]['_weight'])) {
        $form[$group_name][$delta]['_weight'] = $form[$group_name][$field_name][$delta]['_weight'];
      }
       
      // Add in our validation step, and make sure it preceeds other processing
      // so we can massage the element back to the normal value.
      if (isset($form[$group_name][$delta][$field_name]['#element_validate'])) {
        array_unshift($form[$group_name][$delta][$field_name]['#element_validate'], 'fieldgroup_combo_item_validate');
      }
      else {
        $form[$group_name][$delta][$field_name]['#element_validate'] = array('fieldgroup_combo_item_validate');
      }
      
      unset($form[$group_name][$delta][$field_name]['_weight']);
      unset($form[$group_name][$delta][$field_name]['#theme']);
    }
  }
  // Unset the original group values.
  foreach ($fields as $field_name => $field) {
    unset($form[$group_name][$field_name]);
  }
  $form['#element_validate'][] = 'fieldgroup_combo_form_validate';
}

/**
 * Swap transposed field/delta values back to their normal positions.
 */
function fieldgroup_combo_item_validate($element, &$form_state) {
  $field_name = array_pop($element['#parents']);
  $delta = array_pop($element['#parents']);
  $group = array_pop($element['#parents']);
  
  // Examine the post values to see what order the new fields
  // belong in. This is very hackish and should be done better,
  // but it works for now.
  $new = array();
  foreach ($element['#post'][$group] as $count => $value) {
    $new[$value['_weight']] = $count;
  }
  ksort($new);
  $count = 0;
  foreach ($new as $value) {
    if ($delta == $value) {
      $delta = $count;
      break;
    }
    $count++;
  }
  // We figured out what the new order for the fields is, 
  // so set these values.
  array_push($element['#parents'], $field_name);
  array_push($element['#parents'], $delta);
  form_set_value($element, $element['#value'], $form_state);
}

function fieldgroup_field_overview_form_submit($form, &$form_state) {
  $form_values = $form_state['values'];
  $type_name = $form['#type_name'];

  // Create new group if needed.
  if (!empty($form_values['_add_new_group']['label'])) {
    $group = $form_values['_add_new_group'];
    $group['settings'] = _field_group_default_settings();
    fieldgroup_save_group($type_name, $group);
    $new_group_name = $group['group_name'];
  }

  // Parse incoming rows.
  $add_field_rows = array('_add_new_field', '_add_existing_field');
  $field_rows = array_merge($form['#fields'], $add_field_rows);
  foreach ($form_values as $key => $values) {
    // If 'field' row: update field parenting.
    if (in_array($key, $field_rows)) {
      // If newly added fields were added to a group:
      if (in_array($key, $add_field_rows)) {
        // We replace the '_add_*_field' key with the actual name of
        // the field that got added.
        // content_field_overview_form_submit() placed those
        // in $form_state['fields_added'] for us.
        if (isset($form_state['fields_added'][$key])) {
          $key = $form_state['fields_added'][$key];
        }
        else {
          // No field was actually created : skip to next row.
          continue;
        }
      }
      // If the field was added to the newly created group, replace the
      // '_add_new_group' value with the actual name of the group.
      $parent = ($values['parent'] == '_add_new_group' && isset($new_group_name)) ? $new_group_name : $values['parent'];
      // TODO: check the parent group does exist ?
      fieldgroup_update_fields(array('field_name' => $key, 'group' => $parent, 'type_name' => $type_name));
    }

    // If 'group' row:  update groups weights
    // (possible newly created group has already been taken care of).
    elseif (in_array($key, $form['#groups'])) {
      db_query("UPDATE {". fieldgroup_tablename() ."} SET weight = %d WHERE type_name = '%s' AND group_name = '%s'",
        $values['weight'], $type_name, $key);
    }
  }

  cache_clear_all('fieldgroup_data', content_cache_tablename());
}

function _field_group_default_settings() {
  $settings = array(
    'form' => array('style' => 'fieldset', 'description' => ''),
    'display' => array('description' => '', 'label' => 'above'),
  );
  module_load_include('inc', 'content', 'includes/content.admin');
  foreach (array_keys(_content_admin_display_contexts()) as $key) {
    $settings['display'][$key]['format'] = 'fieldset';
  }
  return $settings;
}

function fieldgroup_display_overview_form_submit($form, &$form_state) {
  $form_values = $form_state['values'];
  $groups = fieldgroup_groups($form['#type_name']);
  foreach ($form_values as $key => $values) {
    if (in_array($key, $form['#groups'])) {
      $group = $groups[$key];
      // We have some numeric keys here, so we can't use array_merge.
      $group['settings']['display'] = $values + $group['settings']['display'];
      fieldgroup_save_group($form['#type_name'], $group);
    }
  }
}

function fieldgroup_field_remove_form_submit($form, &$form_state) {
  $form_values = $form_state['values'];
  // TODO:
  // - when a (non last) field is removed from a group, a 'ghost row' remains in the fields overview
  // - when the last field is removed, the group disappears
  // seems to be fixed when emptying the cache.
  db_query("DELETE FROM {". fieldgroup_fields_tablename() ."} WHERE type_name = '%s' AND field_name = '%s'", $form_values['type_name'], $form_values['field_name']);
}

/**
 * Implementation of hook_nodeapi().
 */
function fieldgroup_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'view':
  	  // NODE_BUILD_NORMAL is 0, and ('whatever' == 0) is TRUE, so we need a ===.
      if ($node->build_mode === NODE_BUILD_NORMAL || $node->build_mode == NODE_BUILD_PREVIEW) {
        $context = $teaser ? 'teaser' : 'full';
      }
      else {
        $context = $node->build_mode;
      }

      foreach (fieldgroup_groups($node->type) as $group_name => $group) {
        // Do not include group labels when indexing content.
        if ($context == NODE_BUILD_SEARCH_INDEX) {
          $group['settings']['display']['label'] = 'hidden';
        }
        $label = $group['settings']['display']['label'] == 'above';
        $element = array(
          '#title' => $label ? check_plain(t($group['label'])) : '',
          '#description' => $label ? content_filter_xss(t($group['settings']['display']['description'])) : '',
        );
        $format = isset($group['settings']['display'][$context]['format']) ? $group['settings']['display'][$context]['format'] : 'fieldset';
        switch ($format) {
          case 'simple':
            $element['#type'] = 'fieldgroup_simple';
            $element['#group_name'] = $group_name;
            break;
          case 'hidden':
            $element['#access'] = FALSE;
            break;

          case 'fieldset_collapsed':
            $element['#collapsed'] = TRUE;
          case 'fieldset_collapsible':
            $element['#collapsible'] = TRUE;
          case 'fieldset':
            $element['#type'] = 'fieldgroup_fieldset';
            $element['#attributes'] = array('class' => 'fieldgroup '. strtr($group['group_name'], '_', '-'));
            break;
        }

        foreach ($group['fields'] as $field_name => $field) {
          if (isset($node->content[$field_name])) {
            $element[$field_name] = $node->content[$field_name];
            unset($node->content[$field_name]);
          }
        }

        // The wrapper lets us get the themed output for the whole group
        // once the $node->content has been rendered.
        // See fieldgroup_preprocess_node().
        $wrapper = array(
          'group' => $element,
          '#weight' => $group['weight'],
        );

        $node->content[$group_name] = $wrapper;
      }
      break;
  }
}

/*
 * Get the group name for a field.
 * If the field isn't in a group, FALSE will be returned.
 * @return The name of the group, or FALSE.
 */
function fieldgroup_get_group($content_type, $field_name) {
  foreach (fieldgroup_groups($content_type) as $group_name => $group) {
    if (in_array($field_name, array_keys($group['fields']))) {
      return $group_name;
    }
  }
  return FALSE;
}

/**
 *  Implementation of hook_node_type()
 *  React to change in node types
 */
function fieldgroup_node_type($op, $info) {
  if ($op == 'update' && !empty($info->old_type) && $info->type != $info->old_type) {
    // update the tables
    db_query("UPDATE {". fieldgroup_tablename() ."} SET type_name='%s' WHERE type_name='%s'", array($info->type, $info->old_type));
    db_query("UPDATE {". fieldgroup_fields_tablename() ."} SET type_name='%s' WHERE type_name='%s'", array($info->type, $info->old_type));
    cache_clear_all('fieldgroup_data', content_cache_tablename());
  }
  elseif ($op == 'delete') {
    db_query("DELETE FROM {". fieldgroup_tablename() ."} WHERE type_name = '%s'", $info->type);
    db_query("DELETE FROM {". fieldgroup_fields_tablename() ."} WHERE type_name = '%s'", $info->type);
  }
}

function fieldgroup_types() {
  return array(0 => t('Standard'), 1 => t('Combo'));
}

function fieldgroup_tablename($version = NULL) {
  if (is_null($version)) {
    $version = variable_get('fieldgroup_schema_version', 0);
  }
  return $version < 6000 ? 'node_group' : 'content_group';
}

function fieldgroup_fields_tablename($version = NULL) {
  if (is_null($version)) {
    $version = variable_get('fieldgroup_schema_version', 0);
  }
  return $version < 6000 ? 'node_group_fields' : 'content_group_fields';
}

/**
 * CRUD API for fieldgroup module.
 *
 * @todo
 * Make this into more of a real API for groups.
 */
/*
 * Saves the given group for this content-type
 */
function fieldgroup_save_group($type_name, $group) {
  $groups = fieldgroup_groups($type_name);

  if (!isset($groups[$group['group_name']])) {
    // Accept group name from programmed submissions if valid.
    db_query("INSERT INTO {". fieldgroup_tablename() ."} (type_name, group_name, label, settings, weight)
             VALUES ('%s', '%s', '%s', '%s', %d)", $type_name, $group['group_name'], $group['label'], serialize($group['settings']), $group['weight']);
    cache_clear_all('fieldgroup_data', content_cache_tablename());
    $ret = SAVED_NEW;
  }
  else {
    db_query("UPDATE {". fieldgroup_tablename() ."} SET label = '%s', settings = '%s', weight = %d ".
             "WHERE type_name = '%s' AND group_name = '%s'",
             $group['label'], serialize($group['settings']), $group['weight'], $type_name, $group['group_name']);
    cache_clear_all('fieldgroup_data', content_cache_tablename());
    $ret = SAVED_UPDATED;
  }

  // For a combo group, update all the included fields with the right multiple value setting.
  if ($group['settings']['combo']['is_combo']) {
    $types = content_types();
    $multiple = $group['settings']['combo']['multiple'];
    $result = db_query("SELECT field_name, type_name FROM {". fieldgroup_fields_tablename() ."} WHERE group_name = '%s'", $group['group_name']);
    while ($row = db_fetch_array($result)) {
      $field = $types[$row['type_name']]['fields'][$row['field_name']];
      $field['multiple'] = $multiple;
      content_field_instance_update($field);
    }
  }
  return $ret;
}

function fieldgroup_update_fields($form_values) {
  $default = _fieldgroup_field_get_group($form_values['type_name'], $form_values['field_name']);

  if ($default != $form_values['group']) {
    if ($form_values['group'] && !$default) {
      db_query("INSERT INTO {". fieldgroup_fields_tablename() ."} (type_name, group_name, field_name) VALUES ('%s', '%s', '%s')",
                $form_values['type_name'], $form_values['group'], $form_values['field_name']);
    }
    elseif ($form_values['group']) {
      db_query("UPDATE {". fieldgroup_fields_tablename() ."} SET group_name = '%s' WHERE type_name = '%s' AND field_name = '%s'",
                $form_values['group'], $form_values['type_name'], $form_values['field_name']);
    }
    else {
      db_query("DELETE FROM {". fieldgroup_fields_tablename() ."} WHERE type_name = '%s' AND field_name = '%s'", $form_values['type_name'], $form_values['field_name']);
    }
    cache_clear_all('fieldgroup_data', content_cache_tablename());
  }
}

function fieldgroup_delete($content_type, $group_name) {
  db_query("DELETE FROM {". fieldgroup_tablename() ."} WHERE  type_name = '%s' AND group_name = '%s'", $content_type, $group_name);
  db_query("DELETE FROM {". fieldgroup_fields_tablename() ."} WHERE  type_name = '%s' AND group_name = '%s'", $content_type, $group_name);
  cache_clear_all('fieldgroup_data', content_cache_tablename());
}

/**
 * Format a fieldgroup using a 'fieldset'.
 *
 * Derived from core's theme_fieldset, with no output if the content is empty.
 */
function theme_fieldgroup_fieldset($element) {
  if (empty($element['#children']) && empty($element['#value'])) {
    return '';
  }

  if ($element['#collapsible']) {
    drupal_add_js('misc/collapse.js');

    if (!isset($element['#attributes']['class'])) {
      $element['#attributes']['class'] = '';
    }

    $element['#attributes']['class'] .= ' collapsible';
    if ($element['#collapsed']) {
      $element['#attributes']['class'] .= ' collapsed';
    }
  }

  return '<fieldset'. drupal_attributes($element['#attributes']) .'>'. ($element['#title'] ? '<legend>'. $element['#title'] .'</legend>' : '') . (isset($element['#description']) && $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '') . (!empty($element['#children']) ? $element['#children'] : '') . (isset($element['#value']) ? $element['#value'] : '') ."</fieldset>\n";
}


/**
 * Theme an individual form element.
 *
 * Combine multiple values into a table with drag-n-drop reordering.
 * 
 * TODO 
 * With a little tweaking, the original theme, content_multiple_values,
 * could be made to work for the fieldgroup, too, and this could be
 * eliminated.
 */
function theme_fieldgroup_multiple_values($element) {
  $output = '';
  if ($element['#multiple'] >= 1) {
    $table_id = $element['#group_name'] .'_values';
    $order_class = $element['#group_name'] .'-delta-order';
    
    $header = array(
      array(
        'data' => $element['#group_label'],
        'colspan' => 2
      ),
      t('Order'),
    );
    $rows = array();

    foreach (element_children($element) as $key) {
      if ($key !== $element['#group_name'] .'_add_more') {
        $element[$key]['_weight']['#attributes']['class'] = $order_class;
        $delta_element = drupal_render($element[$key]['_weight']);
        $cells = array(
          array('data' => '', 'class' => 'content-multiple-drag'),
          drupal_render($element[$key]),
          array('data' => $delta_element, 'class' => 'delta-order'),
        );
        $rows[] = array(
          'data' => $cells,
          'class' => 'draggable',
        );
      }
    }

    $output .= theme('table', $header, $rows, array('id' => $table_id, 'class' => 'content-multiple-table'));
    $output .= $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '';
    $output .= drupal_render($element[$element['#group_name'] .'_add_more']);

    drupal_add_tabledrag($table_id, 'order', 'sibling', $order_class);
  }
  else {
    foreach (element_children($element) as $key) {
      $output .= drupal_render($element[$key]);
    }
  }

  return $output;
}

/**
 * Process variables for fieldgroup.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $group_name
 * - $group_name_css
 * - $label
 * - $description
 * - $content
 *
 * @see fieldgroup.tpl.php
 */
function fieldgroup_preprocess_fieldgroup_simple(&$vars) {
  $element = $vars['element'];

  $vars['group_name'] = $element['#group_name'];
  $vars['group_name_css'] = strtr($element['#group_name'], '_', '-');
  $vars['label'] = isset($element['#title']) ? $element['#title'] : '';;
  $vars['description'] = isset($element['#description']) ? $element['#description'] : '';;
  $vars['content'] = isset($element['#children']) ? $element['#children'] : '';
}

/**
 * Theme preprocess function for node.
 *
 * Adds $GROUP_NAME_rendered variables,
 * containing the themed output for the whole group.
 */
function fieldgroup_preprocess_node(&$vars) {
  $node = $vars['node'];

  foreach (fieldgroup_groups($node->type) as $group_name => $group) {
    // '#chilren' might not be set if the group is empty.
    $vars[$group_name .'_rendered'] = isset($node->content[$group_name]['#children']) ? $node->content[$group_name]['#children'] : '';
  }
}
