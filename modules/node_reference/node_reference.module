<?php
// $Id$

/**
 * @file
 * Defines a field type for referencing one node from another.
 */

/**
 * Implements hook_menu().
 */
function node_reference_menu() {
  $items = array();
  $items['node_reference/autocomplete'] = array(
    'title' => 'node_reference autocomplete',
    'page callback' => 'node_reference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  return $items;
}

/**
 * Implements hook_field_info().
 */
function node_reference_field_info() {
  return array(
    'node_reference' => array(
      'label'             => t('Node reference'),
      'description'       => t('This field stores the ID of a related node as an integer value.'),
      'settings'          => array('referenceable_types' => array()),
      // It probably make more sense to have the referenceable types be per-field than per-instance
      // 'instance settings' => array('referenceable_types' => array()),
      'default_widget'    => 'options_select', //  node_reference_autocomplete',
      'default_formatter' => 'node_reference_default',
    ),
  );
}

/**
 * Implements hook_field_schema().
 */
function node_reference_field_schema($field) {
  $columns = array(
    'nid' => array(
      'type'     => 'int',
      'unsigned' => TRUE,
      'not null' => FALSE,
    ),
  );
  return array(
    'columns' => $columns,
    'indexes' => array('nid' => array('nid')), // useful to find back-references
  );
}

/**
 * Implements hook_field_settings_form().
 */
function node_reference_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];

  $form = array();
  $form['referenceable_types'] = array(
    '#type'          => 'checkboxes',
    '#title'         => t('Content types that can be referenced'),
    '#multiple'      => TRUE,
    '#default_value' => is_array($settings['referenceable_types'])
       ? $settings['referenceable_types']
       : array(),
    '#options'       => array_map('check_plain', node_type_get_names()),
    '#disabled'      => $has_data,
  );
  return $form;
}

/**
 * Implements hook_field_validate().
 *
 * Possible error codes:
 * - 'invalid_nid': nid is not valid for the field (not a valid node id, or the node is not referenceable).
 */
function node_reference_field_validate($obj_type, $object, $field, $instance, $langcode, $items, &$errors) {
  // Extract nids to check.
  $ids = array();

  // First check non-numeric "nid's to avoid losing time with them.
  foreach ($items as $delta => $item) {
    if (is_array($item) && !empty($item['nid'])) {
      if (is_numeric($item['nid'])) {
        $ids[] = $item['nid'];
      }
      else {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'invalid_nid',
          'message' => t("%name: invalid input.",
             array('%name' => t($field['widget']['label']))),
        );
      }
    }
  }
  // Prevent performance hog if there are no ids to check.
  if ($ids) {
    $refs = _node_reference_potential_references($field, '', NULL, $ids);
    foreach ($items as $delta => $item) {
      if (is_array($item)) {
        if (!empty($item['nid']) && !isset($refs[$item['nid']])) {
          $errors[$field['field_name']][$langcode][$delta][] = array(
            'error' => 'invalid_nid',
            'message' => t("%name: this post can't be referenced.",
              array('%name' => t($field['widget']['label']))),
          );
        }
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function node_reference_field_is_empty($item, $field) {
  // nid = 0 Ã®s empty too, which is exactly what we want.
  return empty($item['nid']);
}

/**
 * Implements hook_field_formatter_info().
 */
function node_reference_field_formatter_info() {
  $ret = array(
    'node_reference_default' => array(
      'label'       => t('Title (link)'),
      'description' => t('Display the title of the referenced node as a link to the node page.'),
      'field types' => array('node_reference'),
    ),
    'node_reference_plain' => array(
      'label'       => t('Title (no link)'),
      'description' => t('Display the title of the referenced node as plain text.'),
      'field types' => array('node_reference'),
    ),
    // @todo Abstract on 'build mode' (see how image field does with image
    // styles).
    'node_reference_full' => array(
      'label'       => t('Full node'),
      'description' => t('Display the title of the referenced node as a full node view.'),
      'field types' => array('node_reference'),
    ),
    'node_reference_teaser' => array(
      'label'       => t('Teaser'),
      'description' => t('Display the title of the referenced node as a teaser node view.'),
      'field types' => array('node_reference'),
    ),
  );
  return $ret;
}

/**
 * Implements hook_field_formatter_view().
 */
function node_reference_field_formatter_view($obj_type, $object, $field, $instance, $langcode, $items, $display) {
  $result = array();

  // Collect the list of node ids.
  $nids = array();
  foreach ($items as $delta => $item) {
    $nids[$item['nid']] = $item['nid'];
  }

  switch ($display['type']) {
    case 'node_reference_default':
    case 'node_reference_plain':
      $titles = _node_reference_get_node_titles($nids);
      foreach ($items as $delta => $item) {
        if ($display['type'] == 'node_reference_default') {
          $result[$delta] = array(
            '#type' => 'link',
            '#title' => $titles[$item['nid']],
            '#href' => 'node/' . $item['nid'],
          );
        }
        else {
          $result[$delta] = array(
            '#markup' => check_plain($titles[$item['nid']]),
          );
        }
      }
      break;

    // @todo Abstract on 'build mode' (see how image field does with image
    // styles).
    case 'node_reference_full':
    case 'node_reference_teaser':
      // Extract build mode from the formatter name.
      $build_mode = str_replace('node_reference_', '', $display['type']);

      // To prevent infinite recursion caused by reference cycles, we store
      // diplayed nodes in a recursion queue.
      $recursion_queue = &drupal_static(__FUNCTION__, array());

      // If no 'referencing object' is set, we are starting a new 'reference
      // thread' and need to reset the queue.
      if (!isset($object->referencing_object)) {
        $recursion_queue = array();
      }

      // If the object being built is a node, add it to the recursion queue.
      if ($obj_type == 'node') {
        list($id) = entity_extract_ids($obj_type, $object);
        $recursion_queue[] = $id;
      }

      // Check the recursion queue to determine which nodes should be fully
      // displayed, and which nodes will ony be displayed as a title.
      $nids_titles = array();
      $nids_display = array();
      foreach ($nids as $nid) {
        if (in_array($item['nid'], $recursion_queue)) {
          $nids_titles[$nid] = $nid;
        }
        else {
          $nids_display[$nid] = $nid;
        }
      }

      // Load and build the fully displayed nodes.
      if ($nids_display) {
        $nodes = node_load_multiple($nids_display);
        foreach ($nids_display as $nid) {
          _node_reference_get_node_titles(array(), array($nodes[$nid]->title));
          $nodes[$nid]->referencing_object = $object;
          $nodes[$nid]->referencing_field = $field['field_name'];
        }
        $nodes_built = node_build_multiple($nodes, $build_mode);
      }

      // Fetch the titles of the other nodes.
      if ($nids_titles) {
        $titles = _node_reference_get_node_titles($nids_titles);
      }

      // Assemble the render array.
      foreach ($items as $delta => $item) {
        if (in_array($item['nid'], $nids_display)) {
          $result[$delta] = $nodes_built['nodes'][$item['nid']];
        }
        else {
          $result[$delta] = array(
            '#type' => 'link',
            '#title' => $titles[$item['nid']],
            '#href' => 'node/' . $item['nid'],
          );
        }
      }

      break;
  }

  return $result;
}

/**
 * Helper function for formatters.
 *
 * Store node titles collected in the curent request.
 */
function _node_reference_get_node_titles($nids, $known_titles = array()) {
  $titles = &drupal_static(__FUNCTION__, array());

  // Save titles we receive.
  $titles += $known_titles;

  // Collect nids to retrieve from database.
  $nids_query = array();
  foreach ($nids as $nid) {
    if (!isset($titles[$nid])) {
      $nids_query[] = $nid;
    }
  }
  if ($nids_query) {
    $query = db_select('node', 'n')
      ->fields('n', array('nid', 'title'))
      ->condition('n.nid', $nids)
      // @todo Node access should be checked in hook_field_sanitize() or
      // hook_field_prepare_view().
      ->addTag('node_access');
    $titles += $query->execute()->fetchAllKeyed();
  }

  // Build the results array.
  $return = array();
  foreach ($nids as $nid) {
    $return[$nid] = isset($titles[$nid]) ? $titles[$nid] : '';
  }

  return $return;
}


/**
 * Implements hook_field_widget_info().
 */
function node_reference_field_widget_info() {
  return array(
    'node_reference_autocomplete' => array(
      'label'       => t('Autocomplete text field'),
      'description' => t('Display the list of referenceable nodes as a textfield with autocomplete behaviour.'),
      'field types' => array('node_reference'),
      'settings'    => array(
        'autocomplete_match' => 'contains',
        'size'               => 60,
        'autocomplete_path' => 'node_reference/autocomplete',
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_info_alter().
 */
function node_reference_field_widget_info_alter(&$info) {
  $info['options_select']['field types'][] = 'node_reference';
  $info['options_buttons']['field types'][] = 'node_reference';
}

/**
 * Implements hook_field_widget_settings_form().
 */
function node_reference_field_widget_settings_form($field, $instance) {
  $widget   = $instance['widget'];
  $defaults = field_info_widget_settings($widget['type']);
  $settings = array_merge($defaults, $widget['settings']);

  $form = array();
  if ($widget['type'] == 'node_reference_autocomplete') {
    $form['autocomplete_match'] = array(
      '#type'             => 'select',
      '#title'            => t('Autocomplete matching'),
      '#default_value'    => $settings['autocomplete_match'],
      '#options'          => array(
        'starts_with'     => t('Starts with'),
        'contains'        => t('Contains'),
      ),
      '#description'      => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of nodes.'),
    );
    $form['size'] = array(
      '#type'             => 'textfield',
      '#title'            => t('Size of textfield'),
      '#default_value'    => $settings['size'],
      '#element_validate' => array('_element_validate_integer_positive'),
      '#required'         => TRUE,
    );
  }
  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function node_reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  switch ($instance['widget']['type']) {
    case 'node_reference_autocomplete':
      $element += array(
        '#type'              => 'textfield',
        '#default_value'     => isset($items[$delta]) ? $items[$delta] : NULL,
        '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $field['field_name'],
        '#size'              => $instance['widget']['settings']['size'],
        '#element_validate'  => array('node_reference_autocomplete_validate'),
        '#input'             => TRUE, // allow #value_callback to be invoked
        '#value_callback'    => 'node_reference_autocomplete_value',
      );
      break;
  }

  return $element;
}

/**
 * Value for a node_reference autocomplete element.
 *
 * Replace the node title with a node nid.
 */
function node_reference_autocomplete_value($element, $edit = FALSE, $form_state) {
  if (!empty($element['#default_value'])) {
    $nid = $element['#default_value'];

    $q = db_select('node', 'n');
    $node_title_alias = $q->addField('n', 'title');
    $q->addTag('node_access')
      ->condition('n.nid', $nid)
      ->range(0, 1);
    $result = $q->execute();

    $value = $result->fetchField();
    $value .= ' [nid:'. $nid .']';
  }
  else {
    $value = NULL;
  }
  return $value;
}

/**
 * Validate an autocomplete element.
 */
function node_reference_autocomplete_validate($element, &$form_state, $form) {
  $value = $element['#value'];
  $nid = NULL;
  if (!empty($value)) {
    $field_name = $element['#field_name'];
    $instance = field_info_instance('node', $field_name, $element['#bundle']);
    preg_match('/^(?:\s*|(.*) )?\[\s*nid\s*:\s*(\d+)\s*\]$/', $value, $matches);
    if (!empty($matches)) {
      // Explicit [nid:n].
      list(, $title, $nid) = $matches;
      if (!empty($title) && ($n = node_load($nid)) && $title != $n->title[LANGUAGE_NONE][0]['value']) {
        form_error($element, t('%name: title mismatch. Please check your selection.', array('%name' => t($instance['label']))));
      }
    }
    else {
      // No explicit nid.
      $field = field_info_field($field_name);
      $reference = _node_reference_potential_references($field, $value, 'equals', NULL, 1);
      if (empty($reference)) {
        form_error($element, t('%name: found no valid post with that title.', array('%name' => t($instance['label']))));
      }
      else {
        // @todo The best thing would be to present the user with an
        // additional form, allowing the user to choose between valid
        // candidates with the same title. ATM, we pick the first
        // matching candidate...
        $nid = key($reference);
      }
    }
  }
  form_set_value($element, $nid, $form_state);
}

/**
 * Implements hook_field_widget_error().
 */
function nodereference_field_widget_error($element, $error) {
  form_error($element['nid'], $error['message']);
}

/**
 * Fetch an array of all candidate referenced nodes.
 *
 * This info is used in various places (allowed values, autocomplete
 * results, input validation...). Some of them only need the nids,
 * others nid + titles, others yet nid + titles + rendered row (for
 * display in widgets).
 *
 * The array we return contains all the potentially needed information,
 * and lets consumers use the parts they actually need.
 *
 * @param $field
 *   The field description.
 * @param $string
 *   Optional string to filter titles on (used by autocomplete).
 * @param $match
 *   Operator to match filtered name against, can be any of:
 *   'contains', 'equals', 'starts_with'
 * @param $ids
 *   Optional node ids to lookup (the $string and $match arguments will be
 *   ignored).
 * @param $limit
 *   If non-zero, limit the size of the result set.
 *
 * @return
 *   An array of valid nodes in the form:
 *   array(
 *     nid => array(
 *       'title' => The node title,
 *       'rendered' => The text to display in widgets (can be HTML)
 *     ),
 *     ...
 *   )
 *  @todo Check whether we still need the 'rendered' value (hook_options_list()
 *  does not need it anymore). Should probably be clearer after the 'Views'
 *  mode is ported.
 */
function _node_reference_potential_references($field, $string = '', $match = 'contains', $ids = array(), $limit = NULL) {
  static $results = array();

  // Create unique id for static cache.
  $cid = $field['field_name'] . ':' . $match . ':'
    . ($string !== '' ? $string : implode('-', $ids))
    . ':' . $limit;
  if (!isset($results[$cid])) {
    $references = _node_reference_potential_references_standard($field, $string, $match, $ids, $limit);

    // Store the results.
    $results[$cid] = !empty($references) ? $references : array();
  }

  return $results[$cid];
}

/**
 * Helper function for _node_reference_potential_references().
 *
 * List of referenceable nodes defined by content types.
 */
function _node_reference_potential_references_standard($field, $string = '', $match = 'contains', $ids = array(), $limit = NULL) {
  // Avoid useless work
  if (!count($field['settings']['referenceable_types'])) {
    return array();
  }

  $query = db_select('node', 'n');
  $node_nid_alias   = $query->addField('n', 'nid');
  $node_title_alias = $query->addField('n', 'title', 'node_title');
  $node_type_alias  = $query->addField('n', 'type',  'node_type');
  $query->addTag('node_access');

  if (is_array($field['settings']['referenceable_types'])) {
    $query->condition('n.type', $field['settings']['referenceable_types'], 'IN');
  }

  if ($string !== '') {
    $args = array();
    switch ($match) {
      case 'contains':
        $title_clause = 'n.title LIKE :match';
        $args['match'] = '%' . $string . '%';
        break;

      case 'starts_with':
        $title_clause = 'n.title LIKE :match';
        $args['match'] = $string . '%';
        break;

      case 'equals':
      default: // no match type or incorrect match type: use "="
        $title_clause = 'n.title = :match';
        $args['match'] = $string;
        break;
    }
    $query->where($title_clause, $args);
  }
  elseif ($ids) {
    $query->condition($node_nid_alias, $ids, 'IN', $ids);
  }

  $query
    ->orderBy($node_title_alias)
    ->orderBy($node_type_alias);

  if ($limit) {
    $query->range(0, $limit);
  }

  $result = $query->execute();
  $references = array();
  foreach ($result->fetchAll() as $node) {
    $references[$node->nid] = array(
      'title'    => $node->node_title,
      'rendered' => check_plain($node->node_title),
    );
  }
  return $references;
}

/**
 * Menu callback for the autocomplete results.
 */
function node_reference_autocomplete($field_name, $string = '') {
  $field = field_info_field($field_name);

  $match = isset($field['widget']['autocomplete_match']) ? $field['widget']['autocomplete_match'] : 'contains';
  $matches = array();

  $references = _node_reference_potential_references($field, $string, $match, array(), 10);
  foreach ($references as $id => $row) {
    // Add a class wrapper for a few required CSS overrides.
    $matches[$row['title'] ." [nid:$id]"] = '<div class="reference-autocomplete">'. $row['rendered'] . '</div>';
  }
  drupal_json_output($matches);
}

/**
 * Implements hook_node_type_update().
 *
 * Reflect type name changes to the 'referenceable types' settings: when
 * the name of a type changes, the change needs to be reflected in the
 * "referenceable types" setting for any node_reference field
 * referencing it.
 */
function node_reference_node_type_update($info) {
  if (!empty($info->old_type) && $info->old_type != $info->type) {
    $fields = field_info_fields();
    foreach ($fields as $field_name => $field) {
      if ($field['type'] == 'node_reference' && isset($field['settings']['referenceable_types'][$info->old_type])) {
        $field['settings']['referenceable_types'][$info->type] = empty($field['settings']['referenceable_types'][$info->old_type]) ? 0 : $info->type;
        unset($field['settings']['referenceable_types'][$info->old_type]);
        field_update_field($field);
      }
    }
  }
}

/**
 * Theme preprocess function.
 *
 * Allows specific node templates for nodes displayed as values of a
 * node_reference field with the 'full node' / 'teaser' formatters.
 */
function node_reference_preprocess_node(&$vars) {
  // The 'referencing_field' attribute of the node is added by the 'teaser'
  // and 'full node' formatters.
  if (!empty($vars['node']->referencing_field)) {
    $node = $vars['node'];
    $field = $node->referencing_field;
    $vars['template_files'][] = 'node-node_reference';
    $vars['template_files'][] = 'node-node_reference-' . $field['field_name'];
    $vars['template_files'][] = 'node-node_reference-' . $node->type;
    $vars['template_files'][] = 'node-node_reference-' . $field['field_name'] .'-'. $node->type;
  }
}

/**
 * Implements hook_field_prepare_translation().
 *
 * When preparing a translation, load any translations of existing
 * references.
 * @todo Core doc: "This hook may or may not survive in Field API".
 * So it is currently not verified.
 */
function node_reference_field_prepare_translation($obj_type, $object, $field, $instance, $langcode, &$items) {
  $addition = array();
  $addition[$field['field_name']] = array();
  if (isset($object->translation_source->$field['field_name'])
  && is_array($object->translation_source->$field['field_name'])) {
    foreach ($object->translation_source->$field['field_name'] as $key => $reference) {
      $reference_node = node_load($reference['nid']);
      // Test if the referenced node type is translatable and, if so,
      // load translations if the reference is not for the current language.
      // We can assume the translation module is present because it invokes 'prepare translation'.
      if (translation_supported_type($reference_node->type)
      && !empty($reference_node->language)
      && $reference_node->language != $node->language
      && $translations = translation_node_get_translations($reference_node->tnid)) {
        // If there is a translation for the current language, use it.
        $addition[$field['field_name']][] = array(
          'nid' => isset($translations[$node->language])
            ? $translations[$node->language]->nid
            : $reference['nid'],
        );
      }
    }
  }

  return $addition;
}

/**
 * Implements hook_options_list().
 */
function node_reference_options_list($field) {
  $references = _node_reference_potential_references($field);

  // @todo Support optgroups ? I think this was added in late CCK D6.
  $options = array();
  foreach ($references as $key => $value) {
    $options[$key] = $value['title'];
  }
  return $options;
}
