<?php
// $Id$

/**
 * Base class for CCK CRUD tests.
 * Defines many helper functions useful for writing CCK CRUD tests.
 */
class ContentCrudTestCase extends DrupalWebTestCase {
  var $enabled_schema = FALSE;
  var $content_types  = array();
  var $nodes          = array();
  var $last_field     = NULL;
  var $next_field_n   = 1;
    
  /**
   * Enable CCK, Text, and Schema modules.
   */
  function setUp() {
    parent::setUp('content', 'schema', 'text');
  }

  // Database schema related helper functions

  /**
   * Checks that the database itself and the reported database schema match the
   * expected columns for the given tables.
   * @param $tables An array containing the key 'per_field' and/or the key 'per_type'.
   *  These keys should have array values with table names as the keys (without the 'content_' / 'content_type_' prefix)
   *  These keys should have either NULL value to indicate the table should be absent, or
   *  array values containing column names. The column names can themselves be arrays, in
   *  which case the contents of the array are treated as column names and prefixed with
   *  the array key.
   *
   * For example, if called with the following as an argument:
   * array(
   *   'per_field' => array(
   *     'st_f1' => array('delta', 'field_f1' => array('value, 'format')),
   *     'st_f2' => NULL,    // no content_field_f2 table
   *   ),
   *   'per_type' => array(
   *     'st_t1' => array('field_f2' => array('value'), 'field_f3' => array('value', 'format')),
   *     'st_t2' => array(), // only 'nid' and 'vid' columns
   *     'st_t3' => NULL,    // no content_type_t3 table
   *   ),
   * )
   * Then the database and schema will be checked to ensure that:
   *   content_st_f1 table contains fields nid, vid, delta, field_f1_value, field_f1_format
   *   content_st_f2 table is absent
   *   content_type_st_t1 table contains fields nid, vid, field_f2_value, field_f3_value, field_f3_format
   *   content_type_st_t2 table contains fields nid, vid
   *   content_type_st_t3 table is absent
   */
  function assertSchemaMatchesTables($tables) {
    $groups = array('per_field' => 'content_', 'per_type' => 'content_type_');

    foreach ($groups as $group => $table_prefix) {
      if (isset($tables[$group])) {
        foreach ($tables[$group] as $entity => $columns) {
          if (isset($columns)) {
            $db_columns = array('nid', 'vid');
            foreach ($columns as $prefix => $items) {
              if (is_array($items)) {
                foreach ($items as $item) {
                  $db_columns[] = $prefix .'_'. $item;
                }
              }
              else {
                $db_columns[] = $items;
              }
            }
            $this->_assertSchemaMatches($table_prefix . $entity, $db_columns);
          }
          else {
            $this->_assertTableNotExists($table_prefix . $entity);
          }
        }
      }
    }
  }

  /**
   * Helper function for assertSchemaMatchesTables
   * Checks that the given database table does NOT exist
   * @param $table Name of the table to check
   */
  function _assertTableNotExists($table) {
    $this->assertFalse(db_table_exists($table), t('Table !table is absent', array('!table' => $table)));
  }

  /**
   * Helper function for assertSchemaMatchesTables
   * Checks that the database and schema for the given table contain only the correct fields
   * @param $table Name of the table to check
   * @param $columns Array of column names
   */
  function _assertSchemaMatches($table, $columns) {
    $schema = drupal_get_schema($table, TRUE);
    $mismatches = array();
    if ($schema === FALSE) {
      $mismatches[] = t('table does not exist');
    }
    else {
      $fields = $schema['fields'];
      foreach ($columns as $field) {
        if (!isset($fields[$field])) {
          $mismatches[] = t('field !field is missing from table', array('!field' => $field));
        }
      }
      $columns_reverse = array_flip($columns);
      foreach ($fields as $name => $info) {
        if(!isset($columns_reverse[$name])) {
          $mismatches[] = t('table contains unexpected field !field', array('!field' => $name));
        }
      }
    }
    $this->assertEqual(count($mismatches), 0, t('Table !table matches schema: !details',
      array('!table' => $table, '!details' => implode($mismatches, ', '))));

    if (!$this->enabled_schema) {
      $this->enabled_schema = module_exists('schema');
    }
    if ($this->enabled_schema) {
      // Clunky workaround for http://drupal.org/node/215198
      $prefixed_table = db_prefix_tables('{'. $table .'}');
      $inspect = schema_invoke('inspect', $prefixed_table);
      $inspect = isset($inspect[$table]) ? $inspect[$table] : NULL;
      $compare = schema_compare_table($schema, $inspect);
      if ($compare['status'] == 'missing') {
        $compare['reasons'] = array(t('table does not exist'));
      }
    }
    else {
      $compare = array('status' => 'unknown', 'reasons' => array(t('cannot enable schema module')));
    }
    $this->assertEqual($compare['status'], 'same', t('Table schema for !table matches database: !details',
      array('!table' => $table, '!details' => implode($compare['reasons'], ', '))));
  }

  // Node data helper functions

  /**
   * Helper function for assertNodeSaveValues. Recursively checks that
   * all the keys of a table are present in a second and have the same value.
   */
  function _compareArrayForChanges($fields, $data, $message, $prefix = '') {
    foreach ($fields as $key => $value) {
      $newprefix = ($prefix == '') ? $key : $prefix .']['. $key;
      if (is_array($value)) {
        $compare_to = isset($data[$key]) ? $data[$key] : array();
        $this->_compareArrayForChanges($value, $compare_to, $message, $newprefix);
      }
      else {
        $this->assertEqual($value, $data[$key], t($message, array('!key' => $newprefix)));
      }
    }
  }

  /**
   * Checks that after a node is saved using node_save, the values to be saved
   * match up with the output from node_load.
   * @param $node Either a node object, or the index of an acquired node
   * @param $values Array of values to be merged with the node and passed to node_save
   * @return The values array
   */
  function assertNodeSaveValues($node, $values) {
    if (is_numeric($node) && isset($this->nodes[$node])) {
      $node = $this->nodes[$node];
    }
    $node = $values + (array)$node;
    $node = (object)$node;
    node_save($node);
    $this->assertNodeValues($node, $values);
    return $values;
  }

  /**
   * Checks that the output from node_load matches the expected values.
   * @param $node Either a node object, or the index of an acquired node (only the nid field is used)
   * @param $values Array of values to check against node_load. The node object must contain the keys in the array,
   *  and the values must be equal, but the node object may also contain other keys.
   */
  function assertNodeValues($node, $values) {
    if (is_numeric($node) && isset($this->nodes[$node])) {
      $node = $this->nodes[$node];
    }
    $node = node_load($node->nid, NULL, TRUE);
    $this->_compareArrayForChanges($values, (array)$node, 'Node data [!key] is correct');
  }

  /**
   * Checks that the output from node_load is missing certain fields
   * @param $node Either a node object, or the index of an acquired node (only the nid field is used)
   * @param $fields Array containing a list of field names
   */
  function assertNodeMissingFields($node, $fields) {
    if (is_numeric($node) && isset($this->nodes[$node])) {
      $node = $this->nodes[$node];
    }
    $node = (array)node_load($node->nid, NULL, TRUE);
    foreach ($fields as $field) {
      $this->assertFalse(isset($node[$field]), t('Node should be lacking field !key', array('!key' => $field)));
    }
  }

  /**
   * Creates random values for a text field
   * @return An array containing a value key and a format key
   */
  function createRandomTextFieldData() {
    return array(
      'value' => '!SimpleTest! test value' . $this->randomName(60),
      'format' => 2,
    );
  }

  // Login/user helper functions

  /**
   * Creates a user / role with certain permissions and then logs in as that user
   * @param $permissions Array containing list of permissions. If not given, defaults to
   *  access content, administer content types, administer nodes and administer filters.
   */
  function loginWithPermissions($permissions = NULL) {
    if (!isset($permissions)) {
      $permissions = array(
        'access content',
        'administer content types',
        'administer nodes',
        'administer filters',
      );
    }
    $user = $this->drupalCreateUser($permissions);
    $this->drupalLogin($user);
  }

  // Creation helper functions

  /**
   * Creates a number of content types with predictable names (simpletest_t1 ... simpletest_tN)
   * These content types can later be accessed via $this->content_types[0 ... N-1]
   * @param $count Number of content types to create
   */
  function acquireContentTypes($count) {
    $this->content_types = array();
    for ($i = 0; $i < $count; $i++) {
      $name = 'simpletest_t'. ($i + 1);
      $this->content_types[$i] = $this->drupalCreateContentType(array(
        'name' => $name,
        'type' => $name,
      ));
    }
    content_clear_type_cache();
  }

  /**
   * Creates a number of nodes of each acquired content type.
   * Remember to call acquireContentTypes() before calling this, else the content types won't exist.
   * @param $count Number of nodes to create per acquired content type (defaults to 1)
   */
  function acquireNodes($count = 1) {
    $this->nodes = array();
    foreach ($this->content_types as $content_type) {
      for ($i = 0; $i < $count; $i++) {
        $this->nodes[] = $this->drupalCreateNode(array('type' => $content_type->type));
      }
    }
  }

  /**
   * Creates a field instance with a predictable name. Also makes all future calls to functions
   * which take an optional field use this one as the default.
   * @param $settings Array to be passed to content_field_instance_create. If the field_name
   *  or type_name keys are missing, then they will be added. The default field name is
   *  simpletest_fN, where N is 1 for the first created field, and increments. The default
   *  type name is type name of the $content_type argument.
   * @param $content_type Either a content type object, or the index of an acquired content type
   * @return The newly created field instance.
   */
  function createField($settings, $content_type = 0) {
    if (is_numeric($content_type) && isset($this->content_types[$content_type])) {
      $content_type = $this->content_types[$content_type];
    }
    $defaults = array(
      'field_name' => 'simpletest_f'. $this->next_field_n++,
      'type_name' => $content_type->type,
    );
    $settings = $settings + $defaults;
    $this->last_field = content_field_instance_create($settings);
    return $this->last_field;
  }

  /**
   * Creates a textfield instance. Identical to createField() except it ensures that the text module
   * is enabled, and adds default settings of type (text) and widget_type (text_textfield) if they
   * are not given in $settings.
   * @sa createField()
   */
  function createFieldText($settings, $content_type = 0) {
    $defaults = array(
      'type' => 'text',
      'widget_type' => 'text_textfield',
    );
    $settings = $settings + $defaults;
    return $this->createField($settings, $content_type);
  }

  // Field manipulation helper functions

  /**
   * Updates a field instance. Also makes all future calls to functions which take an optional
   * field use the updated one as the default.
   * @param $settings New settings for the field instance. If the field_name or type_name keys
   *  are missing, then they will be taken from $field.
   * @param $field The field instance to update (defaults to the last worked upon field)
   * @return The updated field instance.
   */
  function updateField($settings, $field = NULL) {
    if (!isset($field)) {
      $field = $this->last_field;
    }
    $defaults = array(
      'field_name' => $field['field_name'],
      'type_name'  => $field['type_name'] ,
    );
    $settings = $settings + $defaults;
    $this->last_field = content_field_instance_update($settings);
    return $this->last_field;
  }

  /**
   * Makes a copy of a field instance on a different content type, effectively sharing the field with a new
   * content type. Also makes all future calls to functions which take an optional field use the shared one
   * as the default.
   * @param $new_content_type Either a content type object, or the index of an acquired content type
   * @param $field The field instance to share (defaults to the last worked upon field)
   * @return The shared (newly created) field instance.
   */
  function shareField($new_content_type, $field = NULL) {
    if (!isset($field)) {
      $field = $this->last_field;
    }
    if (is_numeric($new_content_type) && isset($this->content_types[$new_content_type])) {
      $new_content_type = $this->content_types[$new_content_type];
    }
    $field['type_name'] = $new_content_type->type;
    $this->last_field = content_field_instance_create($field);
    return $this->last_field;
  }

  /**
   * Deletes an instance of a field.
   * @param $content_type Either a content type object, or the index of an acquired content type (used only
   *  to get field instance type name).
   * @param $field The field instance to delete (defaults to the last worked upon field, used only to get
   *  field instance field name).
   */
  function deleteField($content_type, $field = NULL) {
    if (!isset($field)) {
      $field = $this->last_field;
    }
    if (is_numeric($content_type) && isset($this->content_types[$content_type])) {
      $content_type = $this->content_types[$content_type];
    }
    content_field_instance_delete($field['field_name'], $content_type->type);
  }
}

class ContentCrudSingleToMultipleTest extends ContentCrudTestCase {
  function getInfo() {
    return array(
      'name' => t('CCK CRUD API - Single to multiple'),
      'description' => t('Tests the CRUD (create, read, update, delete) API for content types by creating a single value field and chaning it to a multivalue field, sharing it between several content types. <b>Requires !schema_link.</b>', array('!schema_link' => l('Schema module', 'http://www.drupal.org/projects/schema'))),
      'group' => t('CCK'),
    );
  }

  function testSingleToMultiple() {
    // Acquire the context
    $this->loginWithPermissions();
    $this->acquireContentTypes(3);
    $this->acquireNodes();

    // Create a simple text field
    $this->createFieldText(array('text_processing' => 1));
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => array('simpletest_f1' => array('value', 'format')),
      ),
    ));
    $node0values = $this->assertNodeSaveValues(0, array(
      'simpletest_f1' => array(
        0 => $this->createRandomTextFieldData(),
      )
    ));

    // Change the text field to allow multiple values
    $this->updateField(array('multiple' => 1));
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => array(),
      ),
      'per_field' => array(
        'simpletest_f1' => array('delta', 'simpletest_f1' => array('value', 'format')),
      ),
    ));
    $this->assertNodeValues(0, $node0values);

    // Share the text field with other content types
    for ($share_with_content_type = 1; $share_with_content_type <= 2; $share_with_content_type++) {
      $this->shareField($share_with_content_type);
      $this->assertSchemaMatchesTables(array(
        'per_type' => array(
          'simpletest_t'. ($share_with_content_type + 1) => array(),
        ),
      ));
      // The acquired node index will match the content type index as exactly one node is acquired per content type
      $this->assertNodeSaveValues($share_with_content_type, array(
        'simpletest_f1' => array(
          0 => $this->createRandomTextFieldData(),
        )
      ));
    }

    // Delete the text field from all content types
    for ($delete_from_content_type = 2; $delete_from_content_type >= 0; $delete_from_content_type--) {
      $this->deleteField($delete_from_content_type);
      // The acquired node index will match the content type index as exactly one node is acquired per content type
      $this->assertNodeMissingFields($this->nodes[$delete_from_content_type], array('simpletest_f1'));
    }
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => NULL,
        'simpletest_t2' => NULL,
        'simpletest_t3' => NULL,
      ),
    ));
  }
}

class ContentCrudMultipleToSingleTest extends ContentCrudTestCase {
  function getInfo() {
    return array(
      'name' => t('CCK CRUD API - Multiple to single'),
      'description' => t('Tests the CRUD (create, read, update, delete) API for content types by creating a multivalue field and chaning it to a single value field, sharing it between several content types. <b>Requires !schema_link.</b>', array('!schema_link' => l('Schema module', 'http://www.drupal.org/projects/schema'))),
      'group' => t('CCK'),
    );
  }

  function testMultipleToSingle() {
    // Acquire the context
    $this->loginWithPermissions();
    $this->acquireContentTypes(3);
    $this->acquireNodes();

    // Create a multivalue text field
    $this->createFieldText(array('text_processing' => 1, 'multiple' => 1));
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => array(),
      ),
      'per_field' => array(
        'simpletest_f1' => array('delta', 'simpletest_f1' => array('value', 'format')),
      ),
    ));
    $this->assertNodeSaveValues(0, array(
      'simpletest_f1' => array(
        0 => $this->createRandomTextFieldData(),
        1 => $this->createRandomTextFieldData(),
        2 => $this->createRandomTextFieldData(),
      )
    ));

    // Change to a simple text field
    $this->updateField(array('multiple' => 0));
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => array('simpletest_f1' => array('value', 'format')),
      ),
      'per_field' => array(
        'simpletest_f1' => NULL,
      ),
    ));
    $node0values = $this->assertNodeSaveValues(0, array(
      'simpletest_f1' => array(
        0 => $this->createRandomTextFieldData(),
      )
    ));

    // Share the text field with other content type
    $this->shareField(1);
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => array(),
        'simpletest_t2' => array(),
      ),
      'per_field' => array(
        'simpletest_f1' => array('simpletest_f1' => array('value', 'format')),
      ),
    ));
    $node1values = $this->assertNodeSaveValues(1, array(
      'simpletest_f1' => array(
        0 => $this->createRandomTextFieldData(),
      )
    ));
    $this->assertNodeValues(0, $node0values);

    // Share the text field with a 3rd type
    $this->shareField(2);
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t3' => array(),
      )
    ));
    $this->assertNodeSaveValues(2, array(
      'simpletest_f1' => array(
        0 => $this->createRandomTextFieldData(),
      )
    ));
    $this->assertNodeValues(1, $node1values);
    $this->assertNodeValues(0, $node0values);

    // Remove text field from 3rd type
    $this->deleteField(2);
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t3' => NULL,
      )
    ));
    $this->assertNodeMissingFields($this->nodes[2], array('simpletest_f1'));

    // Remove text field from other type
    $this->deleteField(1);
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => array('simpletest_f1' => array('value', 'format')),
        'simpletest_t2' => NULL,
      ),
      'per_field' => array(
        'simpletest_f1' => NULL,
      ),
    ));
    $this->assertNodeMissingFields(1, array('simpletest_f1'));
    $this->assertNodeValues(0, $node0values);

    // Remove text field from original type
    $this->deleteField(0);
    $this->assertSchemaMatchesTables(array(
      'per_type' => array(
        'simpletest_t1' => NULL,
      )
    ));
    $this->assertNodeMissingFields(0, array('simpletest_f1'));
  }
}